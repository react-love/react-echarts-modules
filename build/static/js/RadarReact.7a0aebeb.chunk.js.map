{"version":3,"sources":["../static/js/RadarReact.7a0aebeb.chunk.js","EchartsDemo/RadarReact.js","webpack:///./~/zrender/lib/core/util.js?10f4*****","webpack:///./~/echarts/lib/echarts.js?68a2*****","webpack:///./~/echarts/lib/util/graphic.js?e267*****","webpack:///./~/echarts/lib/util/number.js?43e3*****","webpack:///./~/echarts/lib/util/model.js?e2bd*****","webpack:///./~/zrender/lib/core/vector.js?6654*****","webpack:///./~/zrender/lib/graphic/Path.js?c119*****","webpack:///./~/echarts/lib/util/format.js?7f72*****","webpack:///./~/zrender/lib/core/env.js?9ccc*****","webpack:///./~/echarts/lib/model/Model.js?f4df*****","webpack:///./~/zrender/lib/core/BoundingRect.js?76f6*****","webpack:///./~/echarts/lib/util/clazz.js?3e66*****","webpack:///./~/echarts/lib/model/Component.js?0e02*****","webpack:///./~/echarts/lib/util/layout.js?2b1e*****","webpack:///./~/zrender/lib/core/matrix.js?97a2*****","webpack:///./~/echarts/lib/coord/axisHelper.js?4730*****","webpack:///./~/zrender/lib/contain/text.js?3a43*****","webpack:///./~/zrender/lib/core/curve.js?9511*****","webpack:///./~/zrender/lib/tool/color.js?284f*****","webpack:///./~/zrender/lib/core/event.js?24ff*****","webpack:///./~/zrender/lib/mixin/Eventful.js?223b*****","webpack:///./~/echarts/lib/data/List.js?b096*****","webpack:///./~/zrender/lib/core/PathProxy.js?69e9*****","webpack:///./~/echarts/lib/scale/Scale.js?c922*****","webpack:///./~/zrender/lib/config.js?2861*****","webpack:///./~/zrender/lib/container/Group.js?8d57*****","webpack:///./~/echarts/lib/CoordinateSystem.js?2b30*****","webpack:///./~/echarts/lib/model/Series.js?186c*****","webpack:///./~/echarts/lib/data/helper/completeDimensions.js?9c9e*****","webpack:///./~/echarts/lib/util/symbol.js?be2c*****","webpack:///./~/echarts/lib/model/mixin/makeStyleMapper.js?e2b1*****","webpack:///./~/echarts/lib/scale/Interval.js?08e9*****","webpack:///./~/zrender/lib/graphic/Displayable.js?5c45*****","webpack:///./~/zrender/lib/graphic/Gradient.js?5165*****","webpack:///./~/echarts/lib/util/component.js?cc72*****","webpack:///./~/zrender/lib/core/timsort.js?0a74*****","webpack:///./~/echarts/lib/coord/Axis.js?736c*****","webpack:///./~/echarts/lib/chart/helper/createListFromArray.js?e3fc*****","webpack:///./~/echarts/lib/component/axis/AxisBuilder.js?6417*****","webpack:///./~/echarts/lib/coord/axisModelCommonMixin.js?a8d0*****","webpack:///./~/echarts/lib/util/throttle.js?56b3*****","webpack:///./~/echarts/lib/view/Chart.js?72f3*****","webpack:///./~/zrender/lib/core/log.js?26a2*****","webpack:///./~/zrender/lib/graphic/Image.js?bf1b*****","webpack:///./~/zrender/lib/mixin/Transformable.js?f61b*****","webpack:///./~/echarts/lib/model/mixin/colorPalette.js?b454*****","webpack:///./~/echarts/lib/scale/helper.js?370b*****","webpack:///./~/zrender/lib/Element.js?325b*****","webpack:///./~/zrender/lib/animation/Animator.js?d2b9*****","webpack:///./~/zrender/lib/animation/requestAnimationFrame.js?6d88*****","webpack:///./~/zrender/lib/contain/util.js?0031*****","webpack:///./~/zrender/lib/core/LRU.js?018e*****","webpack:///./~/zrender/lib/core/guid.js?f0e4*****","webpack:///./~/zrender/lib/graphic/Pattern.js?a97e*****","webpack:///./~/zrender/lib/graphic/Style.js?22d9*****","webpack:///./~/zrender/lib/graphic/helper/poly.js?788c*****","webpack:///./~/echarts/lib/data/DataDiffer.js?f330*****","webpack:///./~/echarts/lib/view/Component.js?415a*****","webpack:///./~/zrender/lib/core/bbox.js?1b56*****","webpack:///./~/zrender/lib/contain/line.js?4326*****","webpack:///./~/zrender/lib/contain/quadratic.js?f589*****","webpack:///./~/zrender/lib/contain/windingLine.js?625a*****","webpack:///./~/zrender/lib/graphic/LinearGradient.js?4250*****","webpack:///./~/zrender/lib/graphic/Text.js?3244*****","webpack:///./~/zrender/lib/graphic/mixin/RectText.js?94ea*****","webpack:///./~/zrender/lib/zrender.js?5dcd*****","webpack:///./~/echarts/lib/ExtensionAPI.js?e283*****","webpack:///./~/echarts/lib/helper.js?5794*****","webpack:///./~/echarts/lib/loading/default.js?8a5f*****","webpack:///./~/echarts/lib/model/Global.js?b9d3*****","webpack:///./~/echarts/lib/model/OptionManager.js?a7a5*****","webpack:///./~/echarts/lib/model/globalDefault.js?fd54*****","webpack:///./~/echarts/lib/model/mixin/areaStyle.js?4e41*****","webpack:///./~/echarts/lib/model/mixin/boxLayout.js?92d7*****","webpack:///./~/echarts/lib/model/mixin/itemStyle.js?9011*****","webpack:///./~/echarts/lib/model/mixin/lineStyle.js?3579*****","webpack:///./~/echarts/lib/model/mixin/textStyle.js?e4c8*****","webpack:///./~/echarts/lib/preprocessor/backwardCompat.js?f171*****","webpack:///./~/echarts/lib/preprocessor/helper/compatStyle.js?aff6*****","webpack:///./~/echarts/lib/scale/Log.js?0ad0*****","webpack:///./~/echarts/lib/scale/Ordinal.js?3a6b*****","webpack:///./~/echarts/lib/scale/Time.js?6fdf*****","webpack:///./~/echarts/lib/visual/seriesColor.js?4b6a*****","webpack:///./~/zrender/lib/Handler.js?fbeb*****","webpack:///./~/zrender/lib/Layer.js?f586*****","webpack:///./~/zrender/lib/Painter.js?ee99*****","webpack:///./~/zrender/lib/Storage.js?7e93*****","webpack:///./~/zrender/lib/animation/Animation.js?8743*****","webpack:///./~/zrender/lib/animation/Clip.js?fef9*****","webpack:///./~/zrender/lib/animation/easing.js?64b6*****","webpack:///./~/zrender/lib/contain/arc.js?7367*****","webpack:///./~/zrender/lib/contain/cubic.js?b90e*****","webpack:///./~/zrender/lib/contain/path.js?2e7f*****","webpack:///./~/zrender/lib/core/GestureMgr.js?00fd*****","webpack:///./~/zrender/lib/dom/HandlerProxy.js?2fc7*****","webpack:///./~/zrender/lib/graphic/CompoundPath.js?8636*****","webpack:///./~/zrender/lib/graphic/RadialGradient.js?895e*****","webpack:///./~/zrender/lib/graphic/helper/roundRect.js?418d*****","webpack:///./~/zrender/lib/graphic/helper/smoothBezier.js?2713*****","webpack:///./~/zrender/lib/graphic/helper/smoothSpline.js?a17c*****","webpack:///./~/zrender/lib/graphic/shape/Arc.js?2994*****","webpack:///./~/zrender/lib/graphic/shape/BezierCurve.js?f5c4*****","webpack:///./~/zrender/lib/graphic/shape/Circle.js?076e*****","webpack:///./~/zrender/lib/graphic/shape/Line.js?7728*****","webpack:///./~/zrender/lib/graphic/shape/Polygon.js?d37d*****","webpack:///./~/zrender/lib/graphic/shape/Polyline.js?3cdb*****","webpack:///./~/zrender/lib/graphic/shape/Rect.js?3b3d*****","webpack:///./~/zrender/lib/graphic/shape/Ring.js?b71c*****","webpack:///./~/zrender/lib/graphic/shape/Sector.js?9767*****","webpack:///./~/zrender/lib/mixin/Animatable.js?35cb*****","webpack:///./~/zrender/lib/mixin/Draggable.js?fbca*****","webpack:///./~/zrender/lib/tool/path.js?dc4b*****","webpack:///./~/zrender/lib/tool/transformPath.js?ddb2*****","webpack:///./~/echarts/lib/coord/axisDefault.js?4492****","webpack:///./~/echarts/lib/visual/symbol.js?518b**","webpack:///./~/echarts/lib/processor/dataFilter.js?d6e4*","webpack:///./~/echarts/lib/visual/dataColor.js?fa8e*","webpack:///./~/echarts/lib/chart/radar.js?7042","webpack:///./~/echarts/lib/chart/radar/RadarSeries.js?5e4c","webpack:///./~/echarts/lib/chart/radar/RadarView.js?5582","webpack:///./~/echarts/lib/chart/radar/backwardCompat.js?4e3a","webpack:///./~/echarts/lib/chart/radar/radarLayout.js?e617","webpack:///./~/echarts/lib/component/radar.js?0c9b","webpack:///./~/echarts/lib/component/radar/RadarView.js?f1fd","webpack:///./~/echarts/lib/coord/radar/IndicatorAxis.js?4578","webpack:///./~/echarts/lib/coord/radar/Radar.js?ea59","webpack:///./~/echarts/lib/coord/radar/RadarModel.js?625c"],"names":["webpackJsonp","Array","concat","module","__webpack_exports__","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","n","__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__","__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default","__WEBPACK_IMPORTED_MODULE_2_echarts_lib_chart_radar__","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","RadarReact","_React$Component","this","_this","getPrototypeOf","initPie","bind","_props$option","option","undefined","myChart","a","init","ID","setOption","window","onresize","resize","_this2","_props","_props$width","width","_props$height","height","createElement","ref","style","Component","exports","clone","source","result","typeStr","objToString","len","TYPED_ARRAY","from","BUILTIN_OBJECT","isPrimitive","isDom","hasOwnProperty","merge","overwrite","isObject","targetProp","sourceProp","isArray","isBuiltInObject","mergeAll","targetAndSources","extend","defaults","overlay","createCanvas","document","getContext","_ctx","util","indexOf","array","inherits","clazz","baseClazz","F","clazzPrototype","prop","mixin","isArrayLike","data","each","obj","cb","context","forEach","nativeForEach","map","nativeMap","push","reduce","memo","nativeReduce","filter","nativeFilter","find","func","args","nativeSlice","arguments","apply","curry","isFunction","isString","type","nodeType","ownerDocument","eqNaN","retrieve","values","slice","Function","assert","condition","message","Error","setAsPrimitive","primitiveKey","HashMap","set","createHashMap","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","toString","arrayProto","get","prefixedKey","removeKey","noop","global","createRegisterEventWithLowercaseName","method","eventName","handler","toLowerCase","Eventful","MessageCenter","ECharts","dom","theme","opts","prioritySortFunc","b","prio","themeStorage","id","group","_dom","zr","_zr","zrender","renderer","devicePixelRatio","_throttledZrFlush","throttle","zrUtil","flush","_theme","_chartsViews","_chartsMap","_componentsViews","_componentsMap","_coordSysMgr","CoordinateSystemManager","_api","createExtensionAPI","_messageCenter","_initEvents","_pendingActions","timsort","visualFuncs","dataProcessorFuncs","animation","on","_onframe","doConvertPixel","methodName","finder","ecModel","_model","coordSysList","getCoordinateSystems","modelUtil","parseFinder","coordSys","__DEV__","console","warn","updateDirectly","ecIns","payload","mainType","subType","callView","view","__alive","__model","query","eachComponent","model","index","__viewId","doDispatchAction","silent","payloadType","escapeConnect","actionWrap","actions","actionInfo","cptType","update","split","updateMethod","pop","parseClassType","IN_MAIN_PROCESS","payloads","batched","batch","item","eventObj","eventObjBatch","isHighDown","batchItem","action","event","main","sub","OPTION_UPDATED","updateMethods","prepareAndUpdate","trigger","flushPendingActions","pendingActions","shift","triggerUpdatedEvent","invokeUpdateMethod","api","component","componentModel","updateZ","eachSeries","seriesModel","idx","chart","updateProgressiveAndBlend","updateHoverLayerStatus","postUpdateFuncs","prepareView","isComponent","viewList","viewMap","componentType","viewId","classType","Clazz","ComponentView","getClass","ChartView","add","__id","__ecComponentInfo","componentIndex","remove","dispose","splice","processData","process","stackSeriesData","stackedDataMap","series","stack","getData","previousStack","stackedOn","doLayout","visual","isLayout","doVisualEncoding","excludesLayout","clearColorPalette","doRender","componentView","render","chartView","storage","elCount","traverse","el","isGroup","env","node","useHoverLayer","ignore","frameDrawNum","needProgressive","progressive","Math","floor","stopAnimation","blendMode","canvasSupported","setStyle","z","zlevel","ecInstance","coordSysMgr","ExtensionAPI","getComponentByElement","modelInfo","getComponent","parent","enableConnect","updateConnectedChartsStatus","charts","status","STATUS_KEY","eventActionMap","actionType","eventType","connectedGroups","makeActionFromEvent","otherCharts","instances","otherChart","dispatchAction","GlobalModel","OptionManager","ComponentModel","SeriesModel","graphic","colorTool","ACTION_REG","off","one","echartsProto","getDom","getZr","notMerge","lazyUpdate","optionManager","optionPreprocessorFuncs","setTheme","log","getModel","getOption","getWidth","getHeight","getDevicePixelRatio","painter","dpr","getRenderedCanvas","pixelRatio","backgroundColor","list","getDisplayList","getDataURL","excludeComponents","excludesComponentViews","url","toDataURL","getConnectedDataURL","groupId","mathMin","min","mathMax","max","left","Infinity","top","right","bottom","canvasList","canvas","boundingRect","getBoundingClientRect","targetCanvas","img","Image","x","y","image","refreshImmediately","convertToPixel","convertFromPixel","containPixel","models","coordinateSystem","containPoint","getVisual","visualType","defaultMainType","dataIndexInside","indexOfRawIndex","dataIndex","getItemVisual","getViewOfComponentModel","getViewOfSeriesModel","restoreData","isSingleCanvas","configLayer","clearColor","colorArr","parse","stringify","colorStops","background","updateView","clearAllVisual","updateVisual","updateLayout","optionChanged","resetOption","_loadingFX","showLoading","name","cfg","hideLoading","loadingEffects","opt","browser","weChat","MOUSE_EVENT_NAMES","eveName","e","params","dataModel","getSeriesByIndex","seriesIndex","getDataParams","dataType","eventData","isDisposed","_disposed","clear","idBase","Date","groupIdBase","echarts","version","dependencies","replace","existInstance","getInstanceByDom","nodeName","toUpperCase","clientWidth","clientHeight","setAttribute","connect","disConnect","disconnect","getAttribute","getInstanceById","registerTheme","registerPreprocessor","preprocessorFunc","registerProcessor","priority","processorFunc","isNaN","registerPostUpdate","postUpdateFunc","registerAction","test","registerCoordinateSystem","CoordinateSystem","register","getCoordinateSystemDimensions","coordSysCreator","getDimensionsInfo","dimensions","registerLayout","layoutFunc","registerVisual","visualFunc","registerLoading","loadingFx","extendComponentModel","extendComponentView","extendSeriesModel","extendChartView","setCanvasCreator","creator","List","Model","Axis","number","format","matrix","vector","color","helper","PRIORITY","PROCESSOR","FILTER","STATISTIC","VISUAL","LAYOUT","GLOBAL","CHART","COMPONENT","BRUSH","hasFillOrStroke","fillOrStroke","liftColor","lift","cacheElementStl","__hoverStlDirty","stroke","fill","hoverStyle","__hoverStl","normalStyle","__normalStl","doSingleEnterHover","__isHover","__zr","addHover","z2","doSingleLeaveHover","normalStl","removeHover","doEnterHover","child","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__hoverSilentOnTouch","zrByTouch","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","animatableModel","isAnimationEnabled","postfix","duration","getShallow","animationEasing","animationDelay","getAnimationDelayParams","animateTo","attr","pathTool","Path","Transformable","BoundingRect","round","Group","Text","Circle","Sector","Ring","Polygon","Polyline","Rect","Line","BezierCurve","Arc","CompoundPath","LinearGradient","RadialGradient","extendShape","extendPath","pathData","extendFromString","makePath","rect","layout","path","createFromString","getBoundingRect","aspect","cx","cy","resizePath","mergePath","applyTransform","pathRect","m","calculateTransform","subPixelOptimizeLine","param","subPixelOptimize","shape","lineWidth","x1","x2","y1","y2","subPixelOptimizeRect","originX","originY","originWidth","originHeight","position","positiveOrNegative","doubledPosition","setHoverStyle","hoverSilentOnTouch","setText","textStyle","labelModel","labelPosition","labelOffset","labelColor","textStyleModel","textDistance","textFont","getFont","textPosition","textOffset","textFill","getTextColor","gTextStyleModel","fontStyle","fontWeight","fontSize","fontFamily","join","updateProps","initProps","getTransform","ancestor","mat","identity","mul","getLocalTransform","transform","invert","transformDirection","direction","hBase","abs","vBase","vertex","groupTransition","g1","g2","getAnimatableProps","rotation","elMap1","g","elMap","anid","oldEl","newProp","clipPointsByRect","points","point","clipRectByRect","targetRect","_trim","str","quantityExponent","val","LN10","linearMap","domain","range","clamp","subDomain","subRange","parsePercent","percent","all","match","parseFloat","NaN","precision","returnStr","toFixed","asc","arr","sort","getPrecision","count","getPrecisionSafe","eIndex","dotIndex","getPixelPrecision","dataExtent","pixelExtent","dataQuantity","sizeQuantity","isFinite","getPercentWithPrecision","valueList","sum","acc","digits","pow","votesPerQuota","targetSeats","seats","votes","currentSum","remainder","Number","NEGATIVE_INFINITY","maxId","MAX_SAFE_INTEGER","remRadian","radian","pi2","PI","isRadianAroundZero","TIME_REG","getTimezoneOffset","parseDate","exec","timezoneOffset","timeOffset","quantity","nice","nf","exponent","exp10","f","reformIntervals","littleThan","lg","interval","close","curr","currClose","isNumeric","v","has","formatUtil","nubmerUtil","normalizeToArray","defaultEmphasis","subOpts","emphasisOpt","emphasis","normalOpt","normal","subOptName","LABEL_OPTIONS","getDataItemValue","dataItem","isDataItemOption","converDataValue","dimInfo","dimType","createDataFormatModel","dataFormatMixin","rawValue","getRawValue","rawDataIndex","getRawIndex","getName","itemOpt","getRawDataItem","componentSubType","seriesType","seriesId","seriesName","marker","getTooltipMarker","$vars","getFormattedLabel","dimIndex","labelProp","itemModel","getItemModel","formatter","formatTpl","formatTooltip","mappingToExists","exists","newCptOptions","exist","cptOption","isIdInner","makeIdAndName","mapResult","idMap","existCpt","keyInfo","idNum","compressBatches","batchA","batchB","makeMap","sourceBatch","otherMap","dataIndices","otherDataIndices","j","lenj","mapToArray","isData","mapA","mapB","queryDataIndex","indexOfName","makeGetter","hostObj","parsedKey","queryType","includeMainTypes","queryParam","queryComponents","dataDimToCoordDim","dataDim","getDimension","dimItem","getDimensionInfo","coordDim","coordDimToDataDim","dimName","coordDimIndex","otherDimToDataDim","otherDim","otherDims","ArrayCtor","Float32Array","out","copy","v1","v2","scaleAndAdd","sqrt","lenSquare","div","dot","scale","s","normalize","d","distance","distanceSquare","negate","lerp","t","lengthSquare","dist","distSquare","Displayable","PathProxy","pathContain","Pattern","getCanvasPattern","pathProxyForDraw","__dirtyPath","strokeContainThreshold","brush","ctx","prevEl","hasStroke","hasFill","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","__dirty","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","getGlobalScale","setScale","beginPath","setLineDashOffset","buildPath","rebuildPath","restoreTransform","text","drawRectText","shapeCfg","inBundle","createPathProxy","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","w","lineScale","strokeNoScale","getLineScale","contain","localPos","transformCoordToLocal","containStroke","dirty","dirtyPath","refresh","__clipTarget","animateShape","loop","animate","attrKV","setShape","Sub","extendFrom","defaultShape","thisShape","numberUtil","textContain","addCommas","toCamelCase","upperCaseFirst","group1","charAt","normalizeCssArray","encodeHTML","String","TPL_VAR_ALIAS","wrapVar","varName","seriesIdx","tpl","paramsList","encode","seriesLen","alias","k","formatTplSimple","extraCssText","s2d","formatTime","isUTC","date","utc","M","h","capitalFirst","substr","truncateText","navigator","os","ua","firefox","ie","edge","touchEventsSupported","pointerEventsSupported","userAgent","parentModel","doGet","pathArr","getParent","getParentMethod","clazzUtil","mergeOption","ignoreParent","parsePath","thisParentModel","isEmpty","Ctor","setReadOnly","properties","customizeGetParent","enableClassExtend","vec2","v2ApplyTransform","union","other","lt","rb","lb","rt","maxX","maxY","sx","sy","translate","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","checkClassType","superCall","superApply","IS_CONTAINER","host","hasOwn","ret","RootClass","mandatoryMethods","$constructor","proto","ExtendedClass","enableClassManagement","entity","options","makeContainer","container","registerClass","componentMainType","throwWhenNotFound","getClassesByMainType","o","hasClass","getAllClassMainTypes","types","hasSubTypes","registerWhenExtend","originalExtend","getDependencies","deps","arrayPush","componentUtil","defaultOption","dependentModels","uid","layoutMode","extraOpt","getUID","mergeDefaultAndTheme","inputPositionParams","getLayoutParams","themeModel","getTheme","getDefaultOption","mergeLayoutParam","optionUpdated","newCptOption","isInit","optList","Class","getReferringComponents","enableSubTypeDefaulter","enableTopologicalTravel","boxLayout","orient","gap","maxWidth","maxHeight","currentLineMaxSize","eachChild","nextX","nextY","nextChild","childAt","nextChildRect","moveX","newline","moveY","LOCATION_PARAMS","HV_NAMES","box","vbox","hbox","getAvailableSize","positionInfo","containerRect","margin","containerWidth","containerHeight","getLayoutRect","verticalMargin","horizontalMargin","positionElement","hv","boundingMode","needLocalTransform","elPos","dx","dy","sizeCalculable","hvIdx","targetOption","newOption","names","newParams","newValueCount","merged","mergedValueCount","hasProp","hasValue","ignoreSize","hResult","vResult","copyLayoutParams","m1","m2","out0","out1","out2","out3","out4","out5","rotate","rad","aa","ac","atx","ab","ad","aty","st","sin","ct","cos","vx","vy","det","OrdinalScale","IntervalScale","Scale","axisHelper","getScaleExtent","axisDataLen","boundaryGap","span","scaleType","getMin","getMax","fixMin","fixMax","originalExtent","getExtent","setBlank","getNeedCrossZero","niceScaleExtent","extent","splitNumber","base","setExtent","niceExtent","minInterval","setInterval","createScaleByModel","axisType","getCategories","ifAxisCrossZero","axis","getAxisLabelInterval","tickCoords","labels","font","isAxisHorizontal","textSpaceTakenRect","autoLabelInterval","accumulatedLabelInterval","step","tickCoord","getFormattedLabels","labelFormatter","getTicksLabels","ticks","getTicks","tick","getAxisRawValue","getLabel","getTextWidth","textWidthCache","textLines","l","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getTextRect","textAlign","textBaseline","textLineLen","lineHeight","adjustTextPositionOnRect","textRect","textHeight","halfHeight","ellipsis","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","isAroundZero","EPSILON","isNotAroundZero","cubicAt","p0","p1","p2","p3","onet","cubicDerivativeAt","cubicRootAt","roots","c","A","B","C","t1","disc","K","t2","discSqrt","mathSqrt","Y1","Y2","mathPow","ONE_THIRD","T","theta","acos","ASqrt","tmp","THREE_SQRT","t3","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","x0","y0","x3","y3","prev","next","d1","d2","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","v2Create","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseInt","parseCssFloat","cssHueToRgb","p","setRgba","r","copyRgba","putToCache","colorStr","rgbaArr","lastRemovedArr","colorCache","put","cached","kCSSColorTable","op","ep","fname","alpha","hsla2rgba","iv","hsla","rgba","rgba2hsla","H","S","R","G","vMin","vMax","delta","L","deltaR","deltaG","deltaB","level","toHex","fastMapToColor","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","LRU","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","clientToLocal","calculate","defaultGetZrXY","layerX","offsetX","zrX","zrY","layerY","offsetY","clientX","clientY","normalizeEvent","touch","targetTouches","changedTouches","zrDelta","wheelDelta","detail","addEventListener","isDomLevel2","attachEvent","removeEventListener","detachEvent","stop","preventDefault","stopPropagation","cancelBubble","returnValue","Dispatcher","arrySlice","_$handlers","_h","isSilent","newList","argLen","triggerWithContext","transferProperties","TRANSFERABLE_PROPERTIES","__wrappedMethods","propName","DefaultDataProvider","dataArray","_array","normalizeDimensions","cloneListForMapAndSample","original","excludeDimensions","allDimensions","hostModel","_storage","originalStorage","dim","dimStore","globalObj","Float64Array","Int32Array","dataCtors","float","int","ordinal","time","DataDiffer","pure","getItem","dimensionInfos","dimensionNames","dimensionName","dimensionInfo","stackable","_dimensionInfos","indices","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawData","_extent","listProto","hasItemOption","initData","nameList","dimValueGetter","isDataArray","nameDimIdx","dimensionInfoMap","size","idList","nameRepeatCount","itemName","DataCtor","stackedValue","getValues","getDataExtent","dimData","dimExtent","getSum","rawIndex","mid","indicesOfNearest","maxDistance","nearestIndices","minDist","MAX_VALUE","minDiff","diff","rawIdx","getId","dims","dimSize","filterSelf","newIndices","keep","mapArray","tmpRetValue","retValue","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","originalIndices","frameValues","frameIndices","frameSize","otherList","otherIdList","setVisual","setLayout","getLayout","getItemLayout","setItemLayout","clearItemLayouts","itemVisual","setItemVisual","setItemDataAndSeriesIndex","setItemGraphicEl","getItemGraphicEl","eachItemGraphicEl","cloneShallow","dimensionInfoList","wrapMethod","injectFunction","originalMethod","res","TRANSFERABLE_METHODS","CHANGABLE_METHODS","curve","bbox","CMD","Q","Z","min2","max2","mathCos","mathSin","mathAbs","hasTypedArray","notSaveData","_saveData","_xi","_yi","_x0","_y0","_ux","_uy","_len","_lineDash","_dashOffset","_dashIdx","_dashSum","moveTo","addData","lineTo","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","_dashedBezierTo","quadraticCurveTo","_dashedQuadraticTo","arc","startAngle","endAngle","anticlockwise","arcTo","radius","closePath","toStatic","lineDashSum","offset","setData","appendPath","appendSize","appendPathData","cmd","_expandData","_prevCmd","newData","dash","dashSum","nDash","bezierLen","tmpLen","xi","yi","fromLine","fromCubic","fromQuadratic","rx","ry","fromArc","ux","uy","dTheta","psi","fs","scaleX","scaleY","isEllipse","setting","_setting","_interval","scaleProto","getSetting","unionExtent","unionExtentFromData","start","end","thisExtent","isBlank","_isBlank","config","debugMode","Element","_children","__storage","children","childOfName","childCount","_doAdd","addBefore","nextSibling","addToStorage","addChildrenToStorage","delFromStorage","delChildrenFromStorage","removeAll","includeChildren","tmpRect","tmpMat","invisible","childRect","_coordinateSystems","coordinateSystemCreators","coordinateSystems","creater","coordinateSystemCreator","classUtil","colorPaletteMixin","legendDataProvider","visualColorAccessPath","getInitialData","label","fillDataTextStyle","newSeriesOption","getLinkedData","getRawData","getBaseAxis","multipleSeries","formattedValue","setEachItem","dimIdx","tooltip","valStr","vertially","tooltipName","tooltipDims","colorEl","animationEnabled","getColorFromPalette","scope","getAxisTooltipData","getTooltipPosition","completeDimensions","sysDims","applyDim","resultItem","OTHER_DIMS","coordDimNameMap","genName","fromZero","dimsDef","encodeDef","dataDimNameMap","dimCount","value0","retrieveValue","sysDimItem","sysDimItemDimsDef","dimDefItem","userDimName","dataDims","resultDimIdx","availDimIdx","sysDimIndex","sysDimItemOtherDims","extra","extraPrefix","extraFromZero","isExtraCoord","guessOrdinal","Triangle","Diamond","Pin","angle","asin","tanX","tanY","cpLen","cpLen2","Arrow","symbolCtors","line","roundRect","square","circle","diamond","pin","arrow","triangle","symbolShapeMakers","symbolBuildProxies","Symbol","symbolType","beforeBrush","textVerticalAlign","proxySymbol","symbolPathSetColor","symbolStyle","symbolShape","__isEmptyBrush","symbolUtil","createSymbol","symbolPath","setColor","excludes","includes","roundNumber","_intervalPrecision","getInterval","_niceExtent","getIntervalPrecision","intervalScaleGetTicks","niceTicks","reverse","intervalScaleNiceTicks","intervalPrecision","niceTickExtent","expandSize","Style","__clipPaths","RectText","draggable","dragging","culling","cursor","rectHover","afterBrush","rectContain","coord","animateStyle","useStyle","Gradient","addColorStop","random","subTypeDefaulters","registerSubTypeDefaulter","defaulter","determineSubType","componentTypeMain","dependencyGetter","makeDepndencyGraph","fullNameList","graph","noEntryList","thisItem","createDependencyGraphItem","originalDeps","availableDeps","getAvailableDependencies","entryCount","dependentName","predecessor","thatItem","successor","dep","topologicalTravel","targetNameList","callback","removeEdge","succComponentType","removeEdgeAndAdd","targetNameSet","currComponentType","currVertex","isInTargetNameSet","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","pivot","gallopLeft","hint","lastOffset","maxOffset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","remaining","ts","minRun","force","fixExtentWithBands","nTick","normalizedExtent","inverse","onBand","_labelInterval","containData","dataToCoord","coordToData","pointToData","getTicksCoords","alignWithLabel","bands","getBands","coords","getLabelsCoords","getBandWidth","axisExtent","getLabelInterval","labelInterval","axisModel","isHorizontal","firstDataNotNull","ifNeedCompleteOrdinalData","sampleItem","createListFromArray","coordSysName","creators","registeredCoordSys","completeDimOpt","axesInfo","categoryIndex","createNameList","categories","categoryAxesModels","isStackable","getDimTypeByAxis","categoryAxisModel","categoryDim","dataLen","cartesian2d","axesModels","xAxisModel","yAxisModel","xAxisType","yAxisType","isXAxisCateogry","isYAxisCategory","singleAxis","singleAxisModel","singleAxisType","isCategory","single","polar","polarModel","angleAxisModel","findAxisModel","radiusAxisModel","radiusAxisType","angleAxisType","isAngleAxisCateogry","isRadiusAxisCateogry","geo","makeAxisEventDataBase","endTextLayout","textRotate","rotationDiff","onLeft","tooltipOpt","show","fixMinMaxLabelShow","textEls","showMinLabel","showMaxLabel","firstLabel","nextLabel","lastLabel","prevLabel","isTwoLabelOverlapped","current","labelLayout","firstRect","nextRect","mRotationBack","AxisBuilder","nameDirection","tickDirection","labelDirection","dumbGroup","updateTransform","_transform","_dumbGroup","hasBuilder","builders","getGroup","axisLine","pt1","pt2","lineCap","getLineStyle","axisTick","tickModel","lineStyleModel","tickLen","tickInterval","ticksCoords","ifIgnoreOnTick","axisLabel","axisLabelShow","labelMargin","labelRotation","labelRotate","innerTextLayout","categoryData","triggerEvent","tickVal","itemTextStyleModel","textColor","pos","labelStr","textEl","targetType","decomposeTransform","axisName","nameLocation","gapSignal","nameRotation","axisNameAvailableWidth","truncateOpt","nameTruncateMaxWidth","truncatedText","formatterParams","__fullText","__truncatedText","content","axisRotation","textRotation","rawTick","origin","rangeStart","rangeEnd","getCoordSysModel","setRange","resetRange","lib","ORIGIN_METHOD","RATE","fn","delay","debounce","lastExec","getTime","timer","currCall","debounceNextCall","lastCall","thisDelay","thisDebounce","clearTimeout","setTimeout","debounceDelay","createOrUpdate","fnAttr","throttleType","originFn","lastThrottleType","Chart","elSetState","state","toggleHighlight","dataIdx","highlight","downplay","chartProto","ZImage","globalImageCache","src","_image","cachedImgObj","onload","pending","sWidth","sHeight","drawImage","mIdentity","transformableProto","parentHasTransform","invTransform","tmpTransform","atan2","transformCoordToGlobal","colorIdx","colorNameMap","colorPalette","fixExtent","guid","Animatable","clipPath","drift","beforeUpdate","afterUpdate","hide","setClipPath","addSelfToZr","removeClipPath","removeSelfFromZr","animators","addAnimator","removeAnimator","defaultGetter","defaultSetter","interpolateNumber","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","arraySlice","isArraySame","catmullRomInterpolateArray","catmullRomInterpolate","v0","cloneValue","rgba2String","getArrayDim","keyframes","lastValue","createTrackClip","animator","easing","oneTrackDone","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","_target","lastFrame","lastFramePercent","onframe","frame","clip","Clip","life","_loop","_delay","ondestroy","Animator","_tracks","_clipCount","_doneList","_onframeList","_clipList","when","tracks","during","pause","_paused","resume","isPaused","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","forwardToLast","clipList","removeClip","done","getClips","requestAnimationFrame","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","PI2","normalizeRadian","LinkedList","head","tail","linkedListProto","insert","entry","Entry","insertEntry","maxSize","_list","_map","_maxSize","_lastRemovedEntry","LRUProto","removed","leastUsedEntry","idStart","repeat","createPattern","createLinearGradient","createRadialGradient","STYLE_COMMON_PROPS","opacity","shadowBlur","shadowOffsetX","shadowOffsetY","textStroke","textPositionRect","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","blend","prevStyle","firstDraw","styleName","globalAlpha","globalCompositeOperation","otherStyle","newStyle","canvasGradient","styleProto","smoothSpline","smoothBezier","smooth","controlPoints","smoothConstraint","cp1","cp2","defaultKeyGetter","oldArr","newArr","oldKeyGetter","newKeyGetter","_old","_new","_oldKeyGetter","_newKeyGetter","initIndexMap","keyArr","keyGetter","existence","_add","_update","_remove","execute","oldDataIndexMap","newDataIndexMap","oldDataKeyArr","newDataKeyArr","unshift","componentProto","extremity","fromPoints","xDim","yDim","tx","ty","vec2Min","vec2Max","_l","_a","_b","dir","globalCoord","strokeText","fillText","maxValue","lastIndexOf","save","align","baseline","verticalAlign","shadowColor","textShadowColor","restore","delInstance","Handler","Storage","Animation","HandlerProxy","useVML","painterCtors","ZRender","getInstance","registerPainter","rendererType","vml","handerProxy","getViewportRoot","root","stage","_needsRefresh","oldDelFromStorage","oldAddToStorage","addRoot","delRoot","zLevel","_needsRefreshHover","refreshHoverImmediately","refreshHover","clearHover","clearAnimation","pathToImage","setCursorStyle","cursorStyle","findHover","eventHandler","chartInstance","echartsAPIList","axisModelCommonMixin","createList","createScale","mixinAxisModelCommonMethods","maskColor","mask","labelRect","mergeTheme","themeItem","initBase","baseOption","OPTION_INNER_KEY","_seriesIndices","globalDefault","getComponentsByTypes","componentsMap","existComponent","createSeriesIndices","seriesModels","filterBySubType","components","cpt","assertSeriesInitialized","_optionManager","mountOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","mediaOption","visitComponent","newCptOptionList","ComponentModelClass","newCptTypes","componentOption","cpts","isIdArray","isNameArray","findComponents","queryCond","q","indexAttr","idAttr","nameAttr","queryResult","getSeriesByName","oneSeries","getSeriesByType","getSeries","rawSeriesIndex","eachRawSeries","eachSeriesByType","eachRawSeriesByType","isSeriesFiltered","getCurrentSeriesIndices","filterSeries","filteredSeries","componentTypes","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","parseRawOption","rawOption","isNew","mediaDefault","timelineOptions","mediaList","timelineOpt","timeline","media","singleMedia","preProcess","applyMediaQuery","ecWidth","ecHeight","realMap","aspectratio","applicatable","matched","QUERY_REG","operator","realAttr","real","expect","indicesEquals","indices1","indices2","oldOption","newCptOpt","oldCptOpt","oldOptionBackup","newParsedOption","isRecreate","optionBackup","timelineModel","getCurrentIndex","platform","animationDuration","animationDurationUpdate","animationEasingUpdate","animationThreshold","progressiveThreshold","hoverLayerThreshold","useUTC","getAreaStyle","getBoxLayoutParams","getItemStyle","getBorderLineDash","lineType","getLineDash","dotSize","dashSize","graphicUtil","compatLayoutProperties","LAYOUT_PROPERTIES","compatStyle","COMPATITABLE_COMPONENTS","COMPATITABLE_SERIES","seriesOpt","clockWise","clockwise","pointerColor","dataRange","visualMap","componentName","compatItemStyle","itemStyleOpt","itemStyle","POSSIBLE_STYLES","normalItemStyleOpt","emphasisItemStyleOpt","markPoint","markLine","mpData","mlData","fixRoundingError","originalVal","roundingErrorFix","intervalScaleProto","mathFloor","mathCeil","mathLog","LogScale","_originalScale","originalScale","powVal","__fixMin","__fixMax","approxTickNum","err","_data","rank","scaleHelper","bisect","TimeScale","stepLvl","_stepLvl","ONE_HOUR","getFullYear","getMonth","getDate","approxInterval","scaleLevelsLen","scaleLevels","yearSpan","ONE_SECOND","ONE_MINUTE","ONE_DAY","encodeColor","colorAccessPath","makeEventPacket","eveType","targetInfo","topTarget","gestureEvent","pinchX","pinchY","pinchScale","EmptyProxy","isHover","displayable","SILENT","Draggable","handlerNames","proxy","painterRoot","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","lastHovered","hovered","hoveredTarget","lastHoveredTarget","setCursor","dispatchToElement","mouseout","innerDom","element","toElement","relatedTarget","parentNode","dispatch","eventArgs","eventPacket","eachOtherLayer","layer","exclude","hoverCheckResult","_downel","_upel","returnFalse","createDom","newDom","newDomStyle","Layer","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","initContext","createBackBuffer","clearAll","haveMotionBLur","clearRect","clearColorGradientOrPattern","__canvasGradient","fillRect","parseInt10","isLayerValid","__builtin__","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","clipPaths","prevClipPaths","doClip","createRoot","domRoot","cssText","Painter","singleCanvas","_opts","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","_domRoot","_getSize","appendChild","_progressiveLayers","_hoverlayer","_hoverElements","paintAll","_paintList","_startProgessive","__hoverMir","elMirror","__from","hoverElements","hoverLayer","displayableSortFunc","getLayer","originalEl","_doPaintEl","token","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuiltinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","MAX_PROGRESSIVE_LAYER_NUMBER","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","virtual","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","removeChild","display","clearLayer","findAndDrawOtherLayer","smaller","larger","intermediateLayer","renderToCanvas","imageLayer","displayList","whIdx","wh","cwh","plt","prb","stl","defaultView","getComputedStyle","shadowBlurSize","leftMargin","rightMargin","topMargin","bottomMargin","pathTransform","ImageShape","imgShape","shapeCompareFunc","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","_updateAndAddDisplayable","userSetClipPath","currentClipPath","parentClipPath","_renderList","_clips","_running","_time","_pausedTime","_pauseStart","clips","deferredEvents","deferredClips","_needsRemove","fire","_startLoop","_life","_initialized","onrestart","easingFuncs","globalTime","deltaTime","_startTime","easingFunc","schedule","restart","arg","linear","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","windingQuadratic","y_","x_","windingArc","containPath","isStroke","windingLine","cubic","quadratic","_x","pointPair","center","eventUtil","GestureMgr","_track","recognize","_doTrack","_recognize","touches","trackItem","recognizers","gestureInfo","pinch","track","pinchEnd","pinchPre","pinchCenter","eventNameFix","processGesture","gestureMgr","_gestureMgr","setTouchTimer","_touching","_touchTimer","isPointerFromTouch","pointerType","initDomHandler","makeMouseHandler","touchHandlerNames","_handlers","domHandlers","pointerHandlerNames","mouseHandlerNames","HandlerDomProxy","mountHandlers","eventTool","pointerEventNames","pointerdown","pointerup","pointermove","pointerout","nm","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","paths","_updatePathDirty","r1","r2","r3","r4","total","v2Min","v2Max","v2Scale","v2Distance","v2Add","isLoop","constraint","prevPoint","nextPoint","cps","d0","cp0","interpolate","segs","w2","w3","unitX","unitY","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","curveTool","pointAt","tangentAt","polyHelper","roundRectHelper","r0","shadowTemp","modified","animatingShape","pathSplitted","_animateToShallow","objShallow","propertyCount","_dragStart","_drag","_dragEnd","draggingTarget","_draggingTarget","_y","dropTarget","lastDropTarget","_dropTarget","processArc","fa","psiDeg","xp","yp","lambda","cxp","cyp","vAngle","u","vRatio","createPathProxyFromString","cs","cc","RegExp","prevCmd","cpx","cpy","ctlPtx","ctlPty","createPathOptions","pathProxy","transformPath","vMag","pathEls","pathList","pathEl","pathBundle","nPoint","mathAtan2","nameRotate","nameTruncate","nameTextStyle","nameGap","axisPointer","onZero","lineStyle","inside","splitLine","splitArea","areaStyle","categoryAxis","valueAxis","timeAxis","logAxis","logBase","defaultSymbolType","legendSymbol","symbolSize","symbol","itemSymbolType","itemSymbolSize","legendModels","isSelected","paletteScope","dataAll","idxMap","filteredIdx","singleDataColor","RadarSeries","indicatorAxes","getIndicatorAxes","legendHoverLink","radarIndex","normalizeSymbolSize","updateSymbols","oldPoints","newPoints","symbolGroup","__dimIdx","getInitialPoints","pt","oldData","polygon","polyline","itemGroup","newIdx","oldIdx","onEmphasis","hoverPolygonIgnore","onNormal","polygonIgnore","areaStyleModel","hoverAreaStyleModel","itemHoverStyle","labelHoverModel","defaultText","polarOptArr","polarNotRadar","polarOpt","indicator","radar","polarIndex","pointsConverter","dataToPoint","axisBuilderAttrs","radarModel","_buildAxes","_buildSplitLineAndArea","axisBuilders","indicatorAxis","axisBuilder","getColorIndex","areaOrLine","areaOrLineColorList","colorIndex","splitLineModel","splitAreaModel","showSplitLine","showSplitArea","splitLineColors","splitAreaColors","splitLines","splitAreas","ticksRadius","realSplitNumber","axesTicksPoints","coordToPoint","prevPoints","error","IndicatorAxis","radiusExtent","Radar","_indicatorAxes","getIndicatorModels","indicatorModel","indicatorIndex","closestAxis","minRadianDiff","closestAxisIdx","coodToData","viewWidth","viewHeight","viewSize","increaseInterval","radarSeries","rawExtent","fixedMin","fixedMax","nicedSplitNumber","halfSplitNumber","radarList","defaultsShow","axisDefault","valueAxisDefault","RadarModel","showName","nameFormatter","indicatorModels","indicatorOpt","indName"],"mappings":"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","file":"static/js/RadarReact.7a0aebeb.chunk.js","sourcesContent":["webpackJsonp([6],Array(188).concat([\n/* 188 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(28);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__ = __webpack_require__(191);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_echarts_lib_chart_radar__ = __webpack_require__(387);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_echarts_lib_chart_radar___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_echarts_lib_chart_radar__);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**\n * Created by yongyuehuang on 2017/8/5.\n *///\n//\nvar RadarReact=function(_React$Component){_inherits(RadarReact,_React$Component);function RadarReact(props){_classCallCheck(this,RadarReact);var _this=_possibleConstructorReturn(this,(RadarReact.__proto__||Object.getPrototypeOf(RadarReact)).call(this,props));_this.initPie=_this.initPie.bind(_this);return _this;}_createClass(RadarReact,[{key:'initPie',value:function initPie(){var _props$option=this.props.option,option=_props$option===undefined?{}:_props$option;//data\nvar myChart=__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default.a.init(this.ID);//echarts\n//options\nmyChart.setOption(option);window.onresize=function(){myChart.resize();};}},{key:'componentDidMount',value:function componentDidMount(){this.initPie();}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initPie();}},{key:'render',value:function render(){var _this2=this;var _props=this.props,_props$width=_props.width,width=_props$width===undefined?\"100%\":_props$width,_props$height=_props.height,height=_props$height===undefined?\"400px\":_props$height;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div',{ref:function ref(ID){return _this2.ID=ID;},style:{width:width,height:height}});}}]);return RadarReact;}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);/* harmony default export */ __webpack_exports__[\"default\"] = (RadarReact);\n\n/***/ }),\n/* 189 */,\n/* 190 */\n/***/ (function(module, exports) {\n\n/**\n * @module zrender/core/util\n */\n\n\n    // mergeDate\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuiltInObject(sourceProp)\n                    && !isBuiltInObject(targetProp)\n                    && !isPrimitive(sourceProp)\n                    && !isPrimitive(targetProp)\n                ) {\n                    // merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // overwritetrue\n                    // NOTE target[key] \n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * \n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz \n     * @param {Function} baseClazz \n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * Consider typed array.\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuiltInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * Whether is exactly NaN. Notice isNaN('a') returns true.\n     * @param {*} value\n     * @return {boolean}\n     */\n    function eqNaN(value) {\n        return value !== value;\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var primitiveKey = '__ec_primitive__';\n    /**\n     * Set an object as primitive to be ignored traversing children in clone or merge\n     */\n    function setAsPrimitive(obj) {\n        obj[primitiveKey] = true;\n    }\n\n    function isPrimitive(obj) {\n        return obj[primitiveKey];\n    }\n\n    /**\n     * @constructor\n     * @param {Object} obj Only apply `ownProperty`.\n     */\n    function HashMap(obj) {\n        obj && each(obj, function (value, key) {\n            this.set(key, value);\n        }, this);\n    }\n\n    // Add prefix to avoid conflict with Object.prototype.\n    var HASH_MAP_PREFIX = '_ec_';\n    var HASH_MAP_PREFIX_LENGTH = 4;\n\n    HashMap.prototype = {\n        constructor: HashMap,\n        // Do not provide `has` method to avoid defining what is `has`.\n        // (We usually treat `null` and `undefined` as the same, different\n        // from ES6 Map).\n        get: function (key) {\n            return this[HASH_MAP_PREFIX + key];\n        },\n        set: function (key, value) {\n            this[HASH_MAP_PREFIX + key] = value;\n            // Comparing with invocation chaining, `return value` is more commonly\n            // used in this case: `var someVal = map.set('a', genVal());`\n            return value;\n        },\n        // Although util.each can be performed on this hashMap directly, user\n        // should not use the exposed keys, who are prefixed.\n        each: function (cb, context) {\n            context !== void 0 && (cb = bind(cb, context));\n            for (var prefixedKey in this) {\n                this.hasOwnProperty(prefixedKey)\n                    && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n            }\n        },\n        // Do not use this method if performance sensitive.\n        removeKey: function (key) {\n            delete this[key];\n        }\n    };\n\n    function createHashMap(obj) {\n        return new HashMap(obj);\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuiltInObject: isBuiltInObject,\n        isDom: isDom,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        assert: assert,\n        setAsPrimitive: setAsPrimitive,\n        createHashMap: createHashMap,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n/***/ }),\n/* 191 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {// Enable DEV mode when using source code without build. which has no __DEV__ variable\n// In build process 'typeof __DEV__' will be replace with 'boolean'\n// So this code will be removed or disabled anyway after built.\nif (typeof __DEV__ === 'undefined') {\n    // In browser\n    if (typeof window !== 'undefined') {\n        window.__DEV__ = true;\n    }\n    // In node\n    else if (typeof global !== 'undefined') {\n        global.__DEV__ = true;\n    }\n}\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\n/**\n * @module echarts\n */\n\n\n    var env = __webpack_require__(198);\n\n    var GlobalModel = __webpack_require__(270);\n    var ExtensionAPI = __webpack_require__(266);\n    var CoordinateSystemManager = __webpack_require__(216);\n    var OptionManager = __webpack_require__(271);\n\n    var ComponentModel = __webpack_require__(202);\n    var SeriesModel = __webpack_require__(217);\n\n    var ComponentView = __webpack_require__(256);\n    var ChartView = __webpack_require__(232);\n    var graphic = __webpack_require__(192);\n    var modelUtil = __webpack_require__(194);\n    var throttle = __webpack_require__(231);\n\n    var zrender = __webpack_require__(265);\n    var zrUtil = __webpack_require__(190);\n    var colorTool = __webpack_require__(208);\n    var Eventful = __webpack_require__(210);\n    var timsort = __webpack_require__(226);\n\n    var each = zrUtil.each;\n    var parseClassType = ComponentModel.parseClassType;\n\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\n\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    // FIXME\n    // necessary?\n    var PRIORITY_VISUAL_BRUSH = 5000;\n\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flagInMainProcess';\n    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\n    var OPTION_UPDATED = '__optionUpdated';\n    var ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts(dom, theme, opts) {\n        opts = opts || {};\n\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        var zr = this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height\n        });\n\n        /**\n         * Expect 60 pfs.\n         * @type {Function}\n         * @private\n         */\n        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = createExtensionAPI(this);\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n\n        // Init mouse events\n        this._initEvents();\n\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n\n        zr.animation.on('frame', this._onframe, this);\n\n        // ECharts instance can be used as value.\n        zrUtil.setAsPrimitive(this);\n    }\n\n    var echartsProto = ECharts.prototype;\n\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            var silent = this[OPTION_UPDATED].silent;\n\n            this[IN_MAIN_PROCESS] = true;\n\n            updateMethods.prepareAndUpdate.call(this);\n\n            this[IN_MAIN_PROCESS] = false;\n\n            this[OPTION_UPDATED] = false;\n\n            flushPendingActions.call(this, silent);\n\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n\n    /**\n     * Usage:\n     * chart.setOption(option, notMerge, lazyUpdate);\n     * chart.setOption(option, {\n     *     notMerge: ...,\n     *     lazyUpdate: ...,\n     *     silent: ...\n     * });\n     *\n     * @param {Object} option\n     * @param {Object|boolean} [opts] opts or notMerge.\n     * @param {boolean} [opts.notMerge=false]\n     * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n\n        var silent;\n        if (zrUtil.isObject(notMerge)) {\n            lazyUpdate = notMerge.lazyUpdate;\n            silent = notMerge.silent;\n            notMerge = notMerge.notMerge;\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n\n        this._model.setOption(option, optionPreprocessorFuncs);\n\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = {silent: silent};\n            this[IN_MAIN_PROCESS] = false;\n        }\n        else {\n            updateMethods.prepareAndUpdate.call(this);\n            // Ensure zr refresh sychronously, and then pixel in canvas can be\n            // fetched after `setOption`.\n            this._zr.flush();\n\n            this[OPTION_UPDATED] = false;\n            this[IN_MAIN_PROCESS] = false;\n\n            flushPendingActions.call(this, silent);\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getDevicePixelRatio = function () {\n        return this._zr.painter.dpr || window.devicePixelRatio || 1;\n    };\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     * @param {string} [opts.excludeComponents]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({\n                mainType: componentType\n            }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n\n        var url = this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n\n\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = (opts && opts.pixelRatio) || 1;\n\n            zrUtil.each(instances, function (chart, id) {\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(\n                        zrUtil.clone(opts)\n                    );\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            });\n\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                    style: {\n                        x: item.left * dpr - left,\n                        y: item.top * dpr - top,\n                        image: item.dom\n                    }\n                });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        }\n        else {\n            return this.getDataURL(opts);\n        }\n    };\n\n    /**\n     * Convert from logical coordinate system to pixel coordinate system.\n     * See CoordinateSystem#convertToPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId, geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\n    /**\n     * Convert from pixel coordinate system to logical coordinate system.\n     * See CoordinateSystem#convertFromPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\n    function doConvertPixel(methodName, finder, value) {\n        var ecModel = this._model;\n        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n            if (coordSys[methodName]\n                && (result = coordSys[methodName](ecModel, finder, value)) != null\n            ) {\n                return result;\n            }\n        }\n\n        if (__DEV__) {\n            console.warn(\n                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n            );\n        }\n    }\n\n    /**\n     * Is the specified coordinate systems or components contain the given pixel point.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {boolean} result\n     */\n    echartsProto.containPixel = function (finder, value) {\n        var ecModel = this._model;\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        zrUtil.each(finder, function (models, key) {\n            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n                var coordSys = model.coordinateSystem;\n                if (coordSys && coordSys.containPoint) {\n                    result |= !!coordSys.containPoint(value);\n                }\n                else if (key === 'seriesModels') {\n                    var view = this._chartsMap[model.__viewId];\n                    if (view && view.containPoint) {\n                        result |= view.containPoint(value, model);\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.warn(key + ': ' + (view\n                                ? 'The found component do not support containPoint.'\n                                : 'No view mapping to the found component.'\n                            ));\n                        }\n                    }\n                }\n                else {\n                    if (__DEV__) {\n                        console.warn(key + ': containPoint is not supported');\n                    }\n                }\n            }, this);\n        }, this);\n\n        return !!result;\n    };\n\n    /**\n     * Get visual from series or data.\n     * @param {string|Object} finder\n     *        If string, e.g., 'series', means {seriesIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            dataIndex / dataIndexInside\n     *        }\n     *        If dataIndex is not specified, series visual will be fetched,\n     *        but not data item visual.\n     *        If all of seriesIndex, seriesId, seriesName are not specified,\n     *        visual will be fetched from first series.\n     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n     */\n    echartsProto.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n\n        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n        var seriesModel = finder.seriesModel;\n\n        if (__DEV__) {\n            if (!seriesModel) {\n                console.warn('There is no specified seires model');\n            }\n        }\n\n        var data = seriesModel.getData();\n\n        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n            ? finder.dataIndexInside\n            : finder.hasOwnProperty('dataIndex')\n            ? data.indexOfRawIndex(finder.dataIndex)\n            : null;\n\n        return dataIndexInside != null\n            ? data.getItemVisual(dataIndexInside, visualType)\n            : data.getVisual(visualType);\n    };\n\n    /**\n     * Get view of corresponding component model\n     * @param  {module:echarts/model/Component} componentModel\n     * @return {module:echarts/view/Component}\n     */\n    echartsProto.getViewOfComponentModel = function (componentModel) {\n        return this._componentsMap[componentModel.__viewId];\n    };\n\n    /**\n     * Get view of corresponding series model\n     * @param  {module:echarts/model/Series} seriesModel\n     * @return {module:echarts/view/Chart}\n     */\n    echartsProto.getViewOfSeriesModel = function (seriesModel) {\n        return this._chartsMap[seriesModel.__viewId];\n    };\n\n\n    var updateMethods = {\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        update: function (payload) {\n            // console.profile && console.profile('update');\n\n            var ecModel = this._model;\n            var api = this._api;\n            var coordSysMgr = this._coordSysMgr;\n            var zr = this._zr;\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            // Fixme First time update ?\n            ecModel.restoreData();\n\n            // TODO\n            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n            // Create new coordinate system each update\n            // In LineView may save the old coordinate system and use it to get the orignal point\n            coordSysMgr.create(this._model, this._api);\n\n            processData.call(this, ecModel, api);\n\n            stackSeriesData.call(this, ecModel);\n\n            coordSysMgr.update(ecModel, api);\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            doRender.call(this, ecModel, payload);\n\n            // Set background\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n            var painter = zr.painter;\n            // TODO all use clearColor ?\n            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n            }\n            else {\n                // In IE8\n                if (!env.canvasSupported) {\n                    var colorArr = colorTool.parse(backgroundColor);\n                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                    if (colorArr[3] === 0) {\n                        backgroundColor = 'transparent';\n                    }\n                }\n                if (backgroundColor.colorStops || backgroundColor.image) {\n                    // Gradient background\n                    // FIXME Fixed layer\n                    zr.configLayer(0, {\n                        clearColor: backgroundColor\n                    });\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                    this._dom.style.background = 'transparent';\n                }\n                else {\n                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                        zr.configLayer(0, {\n                            clearColor: null\n                        });\n                    }\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                    this._dom.style.background = backgroundColor;\n                }\n            }\n\n            each(postUpdateFuncs, function (func) {\n                func(ecModel, api);\n            });\n\n            // console.profile && console.profileEnd('update');\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateView: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateVisual: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload, true);\n\n            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateLayout: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            doLayout.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        prepareAndUpdate: function (payload) {\n            var ecModel = this._model;\n\n            prepareView.call(this, 'component', ecModel);\n\n            prepareView.call(this, 'chart', ecModel);\n\n            updateMethods.update.call(this, payload);\n        }\n    };\n\n    /**\n     * @private\n     */\n    function updateDirectly(ecIns, method, payload, mainType, subType) {\n        var ecModel = ecIns._model;\n\n        // broadcast\n        if (!mainType) {\n            each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);\n            return;\n        }\n\n        var query = {};\n        query[mainType + 'Id'] = payload[mainType + 'Id'];\n        query[mainType + 'Index'] = payload[mainType + 'Index'];\n        query[mainType + 'Name'] = payload[mainType + 'Name'];\n\n        var condition = {mainType: mainType, query: query};\n        subType && (condition.subType = subType); // subType may be '' by parseClassType;\n\n        // If dispatchAction before setOption, do nothing.\n        ecModel && ecModel.eachComponent(condition, function (model, index) {\n            callView(ecIns[\n                mainType === 'series' ? '_chartsMap' : '_componentsMap'\n            ][model.__viewId]);\n        }, ecIns);\n\n        function callView(view) {\n            view && view.__alive && view[method] && view[method](\n                view.__model, ecModel, ecIns._api, payload\n            );\n        }\n    }\n\n    /**\n     * Resize the chart\n     * @param {Object} opts\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @param {boolean} [opts.silent=false]\n     */\n    echartsProto.resize = function (opts) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        this._zr.resize(opts);\n\n        var optionChanged = this._model && this._model.resetOption('media');\n        var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n\n        updateMethods[updateMethod].call(this);\n\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n\n        this[IN_MAIN_PROCESS] = false;\n\n        var silent = opts && opts.silent;\n\n        flushPendingActions.call(this, silent);\n\n        triggerUpdatedEvent.call(this, silent);\n    };\n\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (__DEV__) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n\n        zr.add(el);\n    };\n\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n     * @param {boolean} [opt.silent=false] Whether trigger events.\n     * @param {boolean} [opt.flush=undefined]\n     *                  true: Flush immediately, and then pixel in canvas can be fetched\n     *                      immediately. Caution: it might affect performance.\n     *                  false: Not not flush.\n     *                  undefined: Auto decide whether perform flush.\n     */\n    echartsProto.dispatchAction = function (payload, opt) {\n        if (!zrUtil.isObject(opt)) {\n            opt = {silent: !!opt};\n        }\n\n        if (!actions[payload.type]) {\n            return;\n        }\n\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n\n        doDispatchAction.call(this, payload, opt.silent);\n\n        if (opt.flush) {\n            this._zr.flush(true);\n        }\n        else if (opt.flush !== false && env.browser.weChat) {\n            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n            // hang when sliding page (on touch event), which cause that zr does not\n            // refresh util user interaction finished, which is not expected.\n            // But `dispatchAction` may be called too frequently when pan on touch\n            // screen, which impacts performance if do not throttle them.\n            this._throttledZrFlush();\n        }\n\n        flushPendingActions.call(this, opt.silent);\n\n        triggerUpdatedEvent.call(this, opt.silent);\n    };\n\n    function doDispatchAction(payload, silent) {\n        var payloadType = payload.type;\n        var escapeConnect = payload.escapeConnect;\n        var actionWrap = actions[payloadType];\n        var actionInfo = actionWrap.actionInfo;\n\n        var cptType = (actionInfo.update || 'update').split(':');\n        var updateMethod = cptType.pop();\n        cptType = cptType[0] != null && parseClassType(cptType[0]);\n\n        this[IN_MAIN_PROCESS] = true;\n\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n\n        each(payloads, function (batchItem) {\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model, this._api);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            // light update does not perform data process, layout and visual.\n            if (isHighDown) {\n                // method, payload, mainType, subType\n                updateDirectly(this, updateMethod, batchItem, 'series');\n            }\n            else if (cptType) {\n                updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n            }\n        }, this);\n\n        if (updateMethod !== 'none' && !isHighDown && !cptType) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            }\n            else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payloadType,\n                escapeConnect: escapeConnect,\n                batch: eventObjBatch\n            };\n        }\n        else {\n            eventObj = eventObjBatch[0];\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n    }\n\n    function flushPendingActions(silent) {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            doDispatchAction.call(this, payload, silent);\n        }\n    }\n\n    function triggerUpdatedEvent(silent) {\n        !silent && this.trigger('updated');\n    }\n\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, component);\n        }, this);\n\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n\n            updateZ(seriesModel, chart);\n\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Post render\n        each(postUpdateFuncs, function (func) {\n            func(ecModel, api);\n        });\n    }\n\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            }\n            else {\n                model = componentType;\n            }\n\n            // Consider: id same and type changed.\n            var viewId = '_ec_' + model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = parseClassType(model.type);\n                var Clazz = isComponent\n                    ? ComponentView.getClass(classType.main, classType.sub)\n                    : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                }\n                else {\n                    // Error\n                    return;\n                }\n            }\n\n            model.__viewId = view.__id = viewId;\n            view.__alive = true;\n            view.__model = model;\n            view.group.__ecComponentInfo = {\n                mainType: model.mainType,\n                index: model.componentIndex\n            };\n        }, this);\n\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n                view.__id = view.group.__ecComponentInfo = null;\n            }\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                // Avoid conflict with Object.prototype\n                if (stackedDataMap.hasOwnProperty(stack) && previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @param {object} layout\n     * @param {boolean} [excludesLayout]\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload, excludesLayout) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            (!excludesLayout || !visual.isLayout)\n                && visual.func(ecModel, api, payload);\n        });\n    }\n\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, componentView);\n        }, this);\n\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n\n            chartView.group.silent = !!seriesModel.get('silent');\n\n            updateZ(seriesModel, chartView);\n\n            updateProgressiveAndBlend(seriesModel, chartView);\n\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n\n    var MOUSE_EVENT_NAMES = [\n        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n    ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                var params;\n\n                // no e.target when 'globalout'.\n                if (eveName === 'globalout') {\n                    params = {};\n                }\n                else if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                }\n                // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    params = zrUtil.extend({}, el.eventData);\n                }\n\n                if (params) {\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }\n\n            }, this);\n        }, this);\n\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (__DEV__) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n\n        var api = this._api;\n        var ecModel = this._model;\n\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n\n        // Dispose after all views disposed\n        this._zr.dispose();\n\n        delete instances[this.id];\n    };\n\n    zrUtil.mixin(ECharts, Eventful);\n\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ?\n                        Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (__DEV__) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n\n    function createExtensionAPI(ecInstance) {\n        var coordSysMgr = ecInstance._coordSysMgr;\n        return zrUtil.extend(new ExtensionAPI(ecInstance), {\n            // Inject methods\n            getCoordinateSystems: zrUtil.bind(\n                coordSysMgr.getCoordinateSystems, coordSysMgr\n            ),\n            getComponentByElement: function (el) {\n                while (el) {\n                    var modelInfo = el.__ecComponentInfo;\n                    if (modelInfo != null) {\n                        return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);\n                    }\n                    el = el.parent;\n                }\n            }\n        });\n    }\n\n    /**\n     * @type {Object} key: actionType.\n     * @inner\n     */\n    var actions = {};\n\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var postUpdateFuncs = [];\n\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n\n\n    var instances = {};\n    var connectedGroups = {};\n\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n        /**\n         * @type {number}\n         */\n        version: '3.6.2',\n        dependencies: {\n            zrender: '3.5.2'\n        }\n    };\n\n    function enableConnect(chart) {\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    if (event && event.escapeConnect) {\n                        return;\n                    }\n\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n\n                    zrUtil.each(instances, function (otherChart) {\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    });\n\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n    }\n\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n     *                              Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n     *                               Can be 'auto' (the same as null/undefined)\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (__DEV__) {\n            // Check version\n            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n                throw new Error(\n                    'ZRender ' + zrender.version\n                    + ' is too old for ECharts ' + echarts.version\n                    + '. Current version need ZRender '\n                    + echarts.dependencies.zrender + '+'\n                );\n            }\n\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n        }\n\n        var existInstance = echarts.getInstanceByDom(dom);\n        if (existInstance) {\n            if (__DEV__) {\n                console.warn('There is a chart instance already initialized on the dom.');\n            }\n            return existInstance;\n        }\n\n        if (__DEV__) {\n            if (zrUtil.isDom(dom)\n                && dom.nodeName.toUpperCase() !== 'CANVAS'\n                && (\n                    (!dom.clientWidth && (!opts || opts.width == null))\n                    || (!dom.clientHeight && (!opts || opts.height == null))\n                )\n            ) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n\n        if (dom.setAttribute) {\n            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n        }\n        else {\n            dom[DOM_ATTRIBUTE_KEY] = chart.id;\n        }\n\n        enableConnect(chart);\n\n        return chart;\n    };\n\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || ('g_' + groupIdBase++);\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n\n    /**\n     * @DEPRECATED\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n\n    /**\n     * @return {string} groupId\n     */\n    echarts.disconnect = echarts.disConnect;\n\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        else if (!(chart instanceof ECharts)){\n            // Try to treat as dom\n            chart = echarts.getInstanceByDom(chart);\n        }\n        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key;\n        if (dom.getAttribute) {\n            key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        }\n        else {\n            key = dom[DOM_ATTRIBUTE_KEY];\n        }\n        return instances[key];\n    };\n\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n\n    /**\n     * Register postUpdater\n     * @param {Function} postUpdateFunc\n     */\n    echarts.registerPostUpdate = function (postUpdateFunc) {\n        postUpdateFuncs.push(postUpdateFunc);\n    };\n\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo)\n            ? actionInfo.type\n            : ([actionInfo, actionInfo = {\n                event: eventName\n            }][0]);\n\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n\n        // Validate action type and event name.\n        zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n        if (!actions[actionType]) {\n            actions[actionType] = {action: action, actionInfo: actionInfo};\n        }\n        eventActionMap[eventName] = actionType;\n    };\n\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n\n    /**\n     * Get dimensions of specified coordinate system.\n     * @param {string} type\n     * @return {Array.<string|Object>}\n     */\n    echarts.getCoordinateSystemDimensions = function (type) {\n        var coordSysCreator = CoordinateSystemManager.get(type);\n        if (coordSysCreator) {\n            return coordSysCreator.getDimensionsInfo\n                    ? coordSysCreator.getDimensionsInfo()\n                    : coordSysCreator.dimensions.slice();\n        }\n    };\n\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts/*, superClass*/) {\n        // var Clazz = ComponentModel;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts/*, superClass*/) {\n        // var Clazz = ComponentView;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentView.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts/*, superClass*/) {\n        // var Clazz = SeriesModel;\n        // if (superClass) {\n        //     superClass = 'series.' + superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return SeriesModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts/*, superClass*/) {\n        // var Clazz = ChartView;\n        // if (superClass) {\n        //     superClass = superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ChartView.getClass(classType.main, true);\n        // }\n        return ChartView.extend(opts);\n    };\n\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, __webpack_require__(283));\n    echarts.registerPreprocessor(__webpack_require__(278));\n    echarts.registerLoading('default', __webpack_require__(269));\n\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n\n\n    // --------\n    // Exports\n    // --------\n    echarts.zrender = zrender;\n\n    echarts.List = __webpack_require__(211);\n    echarts.Model = __webpack_require__(199);\n\n    echarts.Axis = __webpack_require__(227);\n\n    echarts.graphic = __webpack_require__(192);\n    echarts.number = __webpack_require__(193);\n    echarts.format = __webpack_require__(197);\n    echarts.throttle = throttle.throttle;\n    echarts.matrix = __webpack_require__(204);\n    echarts.vector = __webpack_require__(195);\n    echarts.color = __webpack_require__(208);\n\n    echarts.util = {};\n    each([\n            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n            'extend', 'defaults', 'clone', 'merge'\n        ],\n        function (name) {\n            echarts.util[name] = zrUtil[name];\n        }\n    );\n\n    echarts.helper = __webpack_require__(268);\n\n\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n\n    module.exports = echarts;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(80)))\n\n/***/ }),\n/* 192 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var pathTool = __webpack_require__(312);\n    var Path = __webpack_require__(196);\n    var colorTool = __webpack_require__(208);\n    var matrix = __webpack_require__(204);\n    var vector = __webpack_require__(195);\n    var Transformable = __webpack_require__(236);\n    var BoundingRect = __webpack_require__(200);\n\n    var round = Math.round;\n    var mathMax = Math.max;\n    var mathMin = Math.min;\n\n    var graphic = {};\n\n    graphic.Group = __webpack_require__(215);\n\n    graphic.Image = __webpack_require__(235);\n\n    graphic.Text = __webpack_require__(263);\n\n    graphic.Circle = __webpack_require__(303);\n\n    graphic.Sector = __webpack_require__(309);\n\n    graphic.Ring = __webpack_require__(308);\n\n    graphic.Polygon = __webpack_require__(305);\n\n    graphic.Polyline = __webpack_require__(306);\n\n    graphic.Rect = __webpack_require__(307);\n\n    graphic.Line = __webpack_require__(304);\n\n    graphic.BezierCurve = __webpack_require__(302);\n\n    graphic.Arc = __webpack_require__(301);\n\n    graphic.CompoundPath = __webpack_require__(296);\n\n    graphic.LinearGradient = __webpack_require__(262);\n\n    graphic.RadialGradient = __webpack_require__(297);\n\n    graphic.BoundingRect = BoundingRect;\n\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                }\n                else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n\n            graphic.resizePath(path, rect);\n        }\n        return path;\n    };\n\n    graphic.mergePath = pathTool.mergePath,\n\n    /**\n     * Resize a path to fit the rect\n     * @param {module:zrender/graphic/Path} path\n     * @param {Object} rect\n     */\n    graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n\n        var pathRect = path.getBoundingRect();\n\n        var m = pathRect.calculateTransform(rect);\n\n        path.applyTransform(m);\n    };\n\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n            originWidth === 0 ? 0 : 1\n        );\n        shape.height = Math.max(\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n            originHeight === 0 ? 0 : 1\n        );\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill\n                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke\n                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n\n            el.__normalStl = normalStyle;\n\n            el.__hoverStlDirty = false;\n        }\n    }\n\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n\n        cacheElementStl(el);\n\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        }\n        else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n\n        el.__isHover = true;\n    }\n\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        }\n        else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n\n        el.__isHover = false;\n    }\n\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleEnterHover(child);\n                }\n            })\n            : doSingleEnterHover(el);\n    }\n\n    function doLeaveHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleLeaveHover(child);\n                }\n            })\n            : doSingleLeaveHover(el);\n    }\n\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOver(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOut(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n\n    /**\n     * Set hover style of element.\n     * This method can be called repeatly without side-effects.\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     * @param {Object} [opt]\n     * @param {boolean} [opt.hoverSilentOnTouch=false]\n     *        In touch device, mouseover event will be trigger on touchstart event\n     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n     *        conviniently use hoverStyle when tap on touch screen without additional\n     *        code for compatibility.\n     *        But if the chart/component has select feature, which usually also use\n     *        hoverStyle, there might be conflict between 'select-highlight' and\n     *        'hover-highlight' especially when roam is enabled (see geo for example).\n     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n     *        on touch device.\n     */\n    graphic.setHoverStyle = function (el, hoverStyle, opt) {\n        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    setElementHoverStl(child, hoverStyle);\n                }\n            })\n            : setElementHoverStl(el, hoverStyle);\n\n        // Duplicated function will be auto-ignored, see Eventful.js.\n        el.on('mouseover', onElementMouseOver)\n          .on('mouseout', onElementMouseOut);\n\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis)\n          .on('normal', leaveEmphasis);\n    };\n\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelOffset = labelModel.getShallow('offset');\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textOffset: labelOffset,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n\n    graphic.getFont = function (opt, ecModel) {\n        var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n        return [\n            // FIXME in node-canvas fontWeight is before fontStyle\n            opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '',\n            opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '',\n            (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px',\n            opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'\n        ].join(' ');\n    };\n\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        // Do not check 'animation' property directly here. Consider this case:\n        // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n        // but its parent model (`seriesModel`) does.\n        var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(\n                    dataIndex,\n                    animatableModel.getAnimationDelayParams\n                        ? animatableModel.getAnimationDelayParams(el, dataIndex)\n                        : null\n                );\n            }\n            if (typeof duration === 'function') {\n                duration = duration(dataIndex);\n            }\n\n            duration > 0\n                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n                : (el.stopAnimation(), el.attr(props), cb && cb());\n        }\n        else {\n            el.stopAnimation();\n            el.attr(props);\n            cb && cb();\n        }\n    }\n\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n\n        return mat;\n    };\n\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} target [x, y]\n     * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:\n     *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n     *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (target, transform, invert) {\n        if (transform && !zrUtil.isArrayLike(transform)) {\n            transform = Transformable.getLocalTransform(transform);\n        }\n\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], target, transform);\n    };\n\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n        var vertex = [\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n        ];\n\n        vertex = graphic.applyTransform(vertex, transform, invert);\n\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n            ? (vertex[0] > 0 ? 'right' : 'left')\n            : (vertex[1] > 0 ? 'bottom' : 'top');\n    };\n\n    /**\n     * Apply group transition animation from g1 to g2.\n     * If no animatableModel, no animation.\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                position: vector.clone(el.position),\n                rotation: el.rotation\n            };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }\n                // else {\n                //     if (el.previousProps) {\n                //         graphic.updateProps\n                //     }\n                // }\n            }\n        });\n    };\n\n    /**\n     * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]\n     * @param {Object} rect {x, y, width, height}\n     * @return {Array.<Array.<number>>} A new clipped points.\n     */\n    graphic.clipPointsByRect = function (points, rect) {\n        return zrUtil.map(points, function (point) {\n            var x = point[0];\n            x = mathMax(x, rect.x);\n            x = mathMin(x, rect.x + rect.width);\n            var y = point[1];\n            y = mathMax(y, rect.y);\n            y = mathMin(y, rect.y + rect.height);\n            return [x, y];\n        });\n    };\n\n    /**\n     * @param {Object} targetRect {x, y, width, height}\n     * @param {Object} rect {x, y, width, height}\n     * @return {Object} A new clipped rect. If rect size are negative, return undefined.\n     */\n    graphic.clipRectByRect = function (targetRect, rect) {\n        var x = mathMax(targetRect.x, rect.x);\n        var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n        var y = mathMax(targetRect.y, rect.y);\n        var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);\n\n        if (x2 >= x && y2 >= y) {\n            return {\n                x: x,\n                y: y,\n                width: x2 - x,\n                height: y2 - y\n            };\n        }\n    };\n\n    module.exports = graphic;\n\n\n\n/***/ }),\n/* 193 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module echarts/util/number\n */\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var number = {};\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n\n        if (subDomain === 0) {\n            return subRange === 0\n                ? range[0]\n                : (range[0] + range[1]) / 2;\n        }\n\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                }\n                else if (val >= domain[1]) {\n                    return range[1];\n                }\n            }\n            else {\n                if (val >= domain[0]) {\n                    return range[0];\n                }\n                else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        }\n        else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function(percent, all) {\n        switch (percent) {\n            case 'center':\n            case 'middle':\n                percent = '50%';\n                break;\n            case 'left':\n            case 'top':\n                percent = '0%';\n                break;\n            case 'right':\n            case 'bottom':\n                percent = '100%';\n                break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n\n            return parseFloat(percent);\n        }\n\n        return percent == null ? NaN : +percent;\n    };\n\n    /**\n     * (1) Fix rounding error of float numbers.\n     * (2) Support return string to avoid scientific notation like '3.5e-7'.\n     *\n     * @param {number} x\n     * @param {number} [precision]\n     * @param {boolean} [returnStr]\n     * @return {number|string}\n     */\n    number.round = function (x, precision, returnStr) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // Avoid range error\n        precision = Math.min(Math.max(0, precision), 20);\n        x = (+x).toFixed(precision);\n        return returnStr ? x : +x;\n    };\n\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n\n    /**\n     * @param {string|number} val\n     * @return {number}\n     */\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n\n        // Consider scientific notation: '3.4e-12' '3.4e+12'\n        var eIndex = str.indexOf('e');\n        if (eIndex > 0) {\n            var precision = +str.slice(eIndex + 1);\n            return precision < 0 ? -precision : 0;\n        }\n        else {\n            var dotIndex = str.indexOf('.');\n            return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n        }\n    };\n\n    /**\n     * Minimal dicernible data precisioin according to a single pixel.\n     *\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number} precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        // toFixed() digits argument must be between 0 and 20.\n        var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n        return !isFinite(precision) ? 20 : precision;\n    };\n\n    /**\n     * Get a data of given precision, assuring the sum of percentages\n     * in valueList is 1.\n     * The largest remainer method is used.\n     * https://en.wikipedia.org/wiki/Largest_remainder_method\n     *\n     * @param {Array.<number>} valueList a list of all data\n     * @param {number} idx index of the data to be processed in valueList\n     * @param {number} precision integer number showing digits of precision\n     * @return {number} percent ranging from 0 to 100\n     */\n    number.getPercentWithPrecision = function (valueList, idx, precision) {\n        if (!valueList[idx]) {\n            return 0;\n        }\n\n        var sum = zrUtil.reduce(valueList, function (acc, val) {\n            return acc + (isNaN(val) ? 0 : val);\n        }, 0);\n        if (sum === 0) {\n            return 0;\n        }\n\n        var digits = Math.pow(10, precision);\n        var votesPerQuota = zrUtil.map(valueList, function (val) {\n            return (isNaN(val) ? 0 : val) / sum * digits * 100;\n        });\n        var targetSeats = digits * 100;\n\n        var seats = zrUtil.map(votesPerQuota, function (votes) {\n            // Assign automatic seats.\n            return Math.floor(votes);\n        });\n        var currentSum = zrUtil.reduce(seats, function (acc, val) {\n            return acc + val;\n        }, 0);\n\n        var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {\n            return votes - seats[idx];\n        });\n\n        // Has remainding votes.\n        while (currentSum < targetSeats) {\n            // Find next largest remainder.\n            var max = Number.NEGATIVE_INFINITY;\n            var maxId = null;\n            for (var i = 0, len = remainder.length; i < len; ++i) {\n                if (remainder[i] > max) {\n                    max = remainder[i];\n                    maxId = i;\n                }\n            }\n\n            // Add a vote to max remainder.\n            ++seats[maxId];\n            remainder[maxId] = 0;\n            ++currentSum;\n        }\n\n        return seats[idx] / digits;\n    };\n\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n\n    var TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d\\d)(?::(\\d\\d)(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line\n\n    /**\n     * @return {number} in minutes\n     */\n    number.getTimezoneOffset = function () {\n        return (new Date()).getTimezoneOffset();\n    };\n\n    /**\n     * @param {string|Date|number} value These values can be accepted:\n     *   + An instance of Date, represent a time in its own time zone.\n     *   + Or string in a subset of ISO 8601, only including:\n     *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',\n     *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',\n     *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',\n     *     all of which will be treated as local time if time zone is not specified\n     *     (see <https://momentjs.com/>).\n     *   + Or other string format, including (all of which will be treated as loacal time):\n     *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',\n     *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'\n     *   + a timestamp, which represent a time in UTC.\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            // Different browsers parse date in different way, so we parse it manually.\n            // Some other issues:\n            // new Date('1970-01-01') is UTC,\n            // new Date('1970/01/01') and new Date('1970-1-01') is local.\n            // See issue #3623\n            var match = TIME_REG.exec(value);\n\n            if (!match) {\n                // return Invalid Date.\n                return new Date(NaN);\n            }\n\n            var timezoneOffset = number.getTimezoneOffset();\n            var timeOffset = !match[8]\n                ? 0\n                : match[8].toUpperCase() === 'Z'\n                ? timezoneOffset\n                : +match[8].slice(0, 3) * 60 + timezoneOffset;\n\n            // match[n] can only be string or undefined.\n            // But take care of '12' + 1 => '121'.\n            return new Date(\n                +match[1],\n                +(match[2] || 1) - 1,\n                +match[3] || 1,\n                +match[4] || 0,\n                +(match[5] || 0) - timeOffset,\n                +match[6] || 0,\n                +match[7] || 0\n            );\n        }\n        else if (value == null) {\n            return new Date(NaN);\n        }\n\n        return new Date(Math.round(value));\n    };\n\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     *\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, quantityExponent(val));\n    };\n\n    function quantityExponent(val) {\n        return Math.floor(Math.log(val) / Math.LN10);\n    }\n\n    /**\n     * find a nice number approximately equal to x. Round the number if round = true,\n     * take ceiling if round = false. The primary observation is that the nicest\n     * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     *\n     * See \"Nice Numbers for Graph Labels\" of Graphic Gems.\n     *\n     * @param  {number} val Non-negative value.\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exponent = quantityExponent(val);\n        var exp10 = Math.pow(10, exponent);\n        var f = val / exp10; // 1 <= f < 10\n        var nf;\n        if (round) {\n            if (f < 1.5) { nf = 1; }\n            else if (f < 2.5) { nf = 2; }\n            else if (f < 4) { nf = 3; }\n            else if (f < 7) { nf = 5; }\n            else { nf = 10; }\n        }\n        else {\n            if (f < 1) { nf = 1; }\n            else if (f < 2) { nf = 2; }\n            else if (f < 3) { nf = 3; }\n            else if (f < 5) { nf = 5; }\n            else { nf = 10; }\n        }\n        val = nf * exp10;\n\n        // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).\n        // 20 is the uppper bound of toFixed.\n        return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n    };\n\n    /**\n     * Order intervals asc, and split them when overlap.\n     * expect(numberUtil.reformIntervals([\n     *     {interval: [18, 62], close: [1, 1]},\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [1, 1]},\n     *     {interval: [62, 150], close: [1, 1]},\n     *     {interval: [106, 150], close: [1, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ])).toEqual([\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [0, 1]},\n     *     {interval: [18, 62], close: [0, 1]},\n     *     {interval: [62, 150], close: [0, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ]);\n     * @param {Array.<Object>} list, where `close` mean open or close\n     *        of the interval, and Infinity can be used.\n     * @return {Array.<Object>} The origin list, which has been reformed.\n     */\n    number.reformIntervals = function (list) {\n        list.sort(function (a, b) {\n            return littleThan(a, b, 0) ? -1 : 1;\n        });\n\n        var curr = -Infinity;\n        var currClose = 1;\n        for (var i = 0; i < list.length;) {\n            var interval = list[i].interval;\n            var close = list[i].close;\n\n            for (var lg = 0; lg < 2; lg++) {\n                if (interval[lg] <= curr) {\n                    interval[lg] = curr;\n                    close[lg] = !lg ? 1 - currClose : 1;\n                }\n                curr = interval[lg];\n                currClose = close[lg];\n            }\n\n            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n                list.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n\n        return list;\n\n        function littleThan(a, b, lg) {\n            return a.interval[lg] < b.interval[lg]\n                || (\n                    a.interval[lg] === b.interval[lg]\n                    && (\n                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n                        || (!lg && littleThan(a, b, 1))\n                    )\n                );\n        }\n    };\n\n    /**\n     * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n     * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n     * subtraction forces infinities to NaN\n     *\n     * @param {*} v\n     * @return {boolean}\n     */\n    number.isNumeric = function (v) {\n        return v - parseFloat(v) >= 0;\n    };\n\n    module.exports = number;\n\n\n/***/ }),\n/* 194 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var formatUtil = __webpack_require__(197);\n    var nubmerUtil = __webpack_require__(193);\n    var Model = __webpack_require__(199);\n    var zrUtil = __webpack_require__(190);\n    var each = zrUtil.each;\n    var isObject = zrUtil.isObject;\n\n    var modelUtil = {};\n\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array\n            ? value\n            : value == null\n            ? []\n            : [value];\n    };\n\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n     modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n\n            // Default emphasis option from normal\n            each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n\n    modelUtil.LABEL_OPTIONS = ['position', 'offset', 'show', 'textStyle', 'distance', 'formatter'];\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return isObject(dataItem)\n            && !(dataItem instanceof Array);\n            // // markLine data can be array\n            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n\n        if (dimType === 'time'\n            // spead up when using timestamp\n            && typeof value !== 'number'\n            && value != null\n            && value !== '-'\n        ) {\n            value = +nubmerUtil.parseDate(value);\n        }\n\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return (value == null || value === '')\n            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n    };\n\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        /**\n         * Get params for formatter\n         * @param {number} dataIndex\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n            var color = data.getItemVisual(dataIndex, 'color');\n\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: this.seriesIndex,\n                seriesId: this.id,\n                seriesName: this.name,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: color,\n                marker: formatUtil.getTooltipMarker(color),\n\n                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n                $vars: ['seriesName', 'name', 'value']\n            };\n        },\n\n        /**\n         * Format label\n         * @param {number} dataIndex\n         * @param {string} [status='normal'] 'normal' or 'emphasis'\n         * @param {string} [dataType]\n         * @param {number} [dimIndex]\n         * @param {string} [labelProp='label']\n         * @return {string}\n         */\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && (params.value instanceof Array)) {\n                params.value = params.value[dimIndex];\n            }\n\n            var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);\n\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            }\n            else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n\n        /**\n         * Get raw value in option\n         * @param {number} idx\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return (isObject(dataItem) && !(dataItem instanceof Array))\n                    ? dataItem.value : dataItem;\n            }\n        },\n\n        /**\n         * Should be implemented.\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         * @return {string} tooltip string\n         */\n        formatTooltip: zrUtil.noop\n    };\n\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          index of which is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n\n        var result = zrUtil.map(exists || [], function (obj, index) {\n            return {exist: obj};\n        });\n\n        // Mapping by id or name if specified.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option // Consider name: two map to one.\n                    && cptOption.id != null\n                    && result[i].exist.id === cptOption.id + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option // Consider name: two map to one.\n                    // Can not match when both ids exist but different.\n                    && (exist.id == null || cptOption.id == null)\n                    && cptOption.name != null\n                    && !modelUtil.isIdInner(cptOption)\n                    && !modelUtil.isIdInner(exist)\n                    && exist.name === cptOption.name + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n\n        // Otherwise mapping by index.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option\n                    // Existing model that already has id should be able to\n                    // mapped to (because after mapping performed model may\n                    // be assigned with a id, whish should not affect next\n                    // mapping), except those has inner id.\n                    && !modelUtil.isIdInner(exist)\n                    // Caution:\n                    // Do not overwrite id. But name can be overwritten,\n                    // because axis use name as 'show label text'.\n                    // 'exist' always has id and name and we dont\n                    // need to check it.\n                    && cptOption.id == null\n                ) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n\n            if (i >= result.length) {\n                result.push({option: cptOption});\n            }\n        });\n\n        return result;\n    };\n\n    /**\n     * Make id and name for mapping result (result of mappingToExists)\n     * into `keyInfo` field.\n     *\n     * @public\n     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     * @return {Array.<Object>} The input.\n     */\n    modelUtil.makeIdAndName = function (mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n\n        // Ensure that each id is distinct.\n        var idMap = zrUtil.createHashMap();\n\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && idMap.set(existCpt.id, item);\n        });\n\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n\n            zrUtil.assert(\n                !opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item,\n                'id duplicates: ' + (opt && opt.id)\n            );\n\n            opt && opt.id != null && idMap.set(opt.id, item);\n            !item.keyInfo && (item.keyInfo = {});\n        });\n\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n\n            if (!isObject(opt)) {\n                return;\n            }\n\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null\n                ? opt.name + ''\n                : existCpt\n                ? existCpt.name\n                : '\\0-'; // name may be displayed on screen, so use '-'.\n\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            }\n            else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            }\n            else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n                }\n                while (idMap.get(keyInfo.id));\n            }\n\n            idMap.set(keyInfo.id, item);\n        });\n    };\n\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return isObject(cptOption)\n            && cptOption.id\n            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n    };\n\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n\n        return [mapToArray(mapA), mapToArray(mapB)];\n\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    }\n                    else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    }\n                    else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                    }\n                }\n            }\n            return result;\n        }\n    };\n\n    /**\n     * @param {module:echarts/data/List} data\n     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n     *                         each of which can be Array or primary type.\n     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n     */\n    modelUtil.queryDataIndex = function (data, payload) {\n        if (payload.dataIndexInside != null) {\n            return payload.dataIndexInside;\n        }\n        else if (payload.dataIndex != null) {\n            return zrUtil.isArray(payload.dataIndex)\n                ? zrUtil.map(payload.dataIndex, function (value) {\n                    return data.indexOfRawIndex(value);\n                })\n                : data.indexOfRawIndex(payload.dataIndex);\n        }\n        else if (payload.name != null) {\n            return zrUtil.isArray(payload.name)\n                ? zrUtil.map(payload.name, function (value) {\n                    return data.indexOfName(value);\n                })\n                : data.indexOfName(payload.name);\n        }\n    };\n\n    /**\n     * Enable property storage to any host object.\n     * Notice: Serialization is not supported.\n     *\n     * For example:\n     * var get = modelUitl.makeGetter();\n     *\n     * function some(hostObj) {\n     *      get(hostObj)._someProperty = 1212;\n     *      ...\n     * }\n     *\n     * @return {Function}\n     */\n    modelUtil.makeGetter = (function () {\n        var index = 0;\n        return function () {\n            var key = '\\0__ec_prop_getter_' + index++;\n            return function (hostObj) {\n                return hostObj[key] || (hostObj[key] = {});\n            };\n        };\n    })();\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex, seriesId, seriesName,\n     *            geoIndex, geoId, geoName,\n     *            bmapIndex, bmapId, bmapName,\n     *            xAxisIndex, xAxisId, xAxisName,\n     *            yAxisIndex, yAxisId, yAxisName,\n     *            gridIndex, gridId, gridName,\n     *            ... (can be extended)\n     *        }\n     *        Each properties can be number|string|Array.<number>|Array.<string>\n     *        For example, a finder could be\n     *        {\n     *            seriesIndex: 3,\n     *            geoId: ['aa', 'cc'],\n     *            gridName: ['xx', 'rr']\n     *        }\n     *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)\n     *        If nothing or null/undefined specified, return nothing.\n     * @param {Object} [opt]\n     * @param {string} [opt.defaultMainType]\n     * @param {Array.<string>} [opt.includeMainTypes]\n     * @return {Object} result like:\n     *        {\n     *            seriesModels: [seriesModel1, seriesModel2],\n     *            seriesModel: seriesModel1, // The first model\n     *            geoModels: [geoModel1, geoModel2],\n     *            geoModel: geoModel1, // The first model\n     *            ...\n     *        }\n     */\n    modelUtil.parseFinder = function (ecModel, finder, opt) {\n        if (zrUtil.isString(finder)) {\n            var obj = {};\n            obj[finder + 'Index'] = 0;\n            finder = obj;\n        }\n\n        var defaultMainType = opt && opt.defaultMainType;\n        if (defaultMainType\n            && !has(finder, defaultMainType + 'Index')\n            && !has(finder, defaultMainType + 'Id')\n            && !has(finder, defaultMainType + 'Name')\n        ) {\n            finder[defaultMainType + 'Index'] = 0;\n        }\n\n        var result = {};\n\n        each(finder, function (value, key) {\n            var value = finder[key];\n\n            // Exclude 'dataIndex' and other illgal keys.\n            if (key === 'dataIndex' || key === 'dataIndexInside') {\n                result[key] = value;\n                return;\n            }\n\n            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n            var mainType = parsedKey[1];\n            var queryType = (parsedKey[2] || '').toLowerCase();\n\n            if (!mainType\n                || !queryType\n                || value == null\n                || (queryType === 'index' && value === 'none')\n                || (opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0)\n            ) {\n                return;\n            }\n\n            var queryParam = {mainType: mainType};\n            if (queryType !== 'index' || value !== 'all') {\n                queryParam[queryType] = value;\n            }\n\n            var models = ecModel.queryComponents(queryParam);\n            result[mainType + 'Models'] = models;\n            result[mainType + 'Model'] = models[0];\n        });\n\n        return result;\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string|number} dataDim\n     * @return {string}\n     */\n    modelUtil.dataDimToCoordDim = function (data, dataDim) {\n        var dimensions = data.dimensions;\n        dataDim = data.getDimension(dataDim);\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimItem = data.getDimensionInfo(dimensions[i]);\n            if (dimItem.name === dataDim) {\n                return dimItem.coordDim;\n            }\n        }\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string} coordDim\n     * @return {Array.<string>} data dimensions on the coordDim.\n     */\n    modelUtil.coordDimToDataDim = function (data, coordDim) {\n        var dataDim = [];\n        each(data.dimensions, function (dimName) {\n            var dimItem = data.getDimensionInfo(dimName);\n            if (dimItem.coordDim === coordDim) {\n                dataDim[dimItem.coordDimIndex] = dimItem.name;\n            }\n        });\n        return dataDim;\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string} otherDim Can be `otherDims`\n     *                        like 'label' or 'tooltip'.\n     * @return {Array.<string>} data dimensions on the otherDim.\n     */\n    modelUtil.otherDimToDataDim = function (data, otherDim) {\n        var dataDim = [];\n        each(data.dimensions, function (dimName) {\n            var dimItem = data.getDimensionInfo(dimName);\n            var otherDims = dimItem.otherDims;\n            var dimIndex = otherDims[otherDim];\n            if (dimIndex != null && dimIndex !== false) {\n                dataDim[dimIndex] = dimItem.name;\n            }\n        });\n        return dataDim;\n    };\n\n    function has(obj, prop) {\n        return obj && obj.hasOwnProperty(prop);\n    }\n\n    module.exports = modelUtil;\n\n\n\n/***/ }),\n/* 195 */\n/***/ (function(module, exports) {\n\n\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * \n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * \n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} \n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n/***/ }),\n/* 196 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = __webpack_require__(223);\n    var zrUtil = __webpack_require__(190);\n    var PathProxy = __webpack_require__(212);\n    var pathContain = __webpack_require__(293);\n\n    var Pattern = __webpack_require__(245);\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    var pathProxyForDraw = new PathProxy(true);\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = null;\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path || pathProxyForDraw;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect;\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath\n                || (lineDash && !ctxLineDash && hasStroke)\n            ) {\n                path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                if (this.path) {\n                    this.__dirtyPath = false;\n                }\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        createPathProxy: function () {\n            this.path = new PathProxy();\n        },\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (!path) {\n                    // Create path on demand.\n                    path = this.path = new PathProxy();\n                }\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     *  Path element, \n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME  extend position, rotation \n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n/***/ }),\n/* 197 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var numberUtil = __webpack_require__(193);\n    var textContain = __webpack_require__(206);\n\n    var formatUtil = {};\n\n    /**\n     * ,\n     * @param {string|number} x\n     * @return {string}\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n               + (x.length > 1 ? ('.' + x[1]) : '');\n    };\n\n    /**\n     * @param {string} str\n     * @param {boolean} [upperCaseFirst=false]\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str, upperCaseFirst) {\n        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n            return group1.toUpperCase();\n        });\n\n        if (upperCaseFirst && str) {\n            str = str.charAt(0).toUpperCase() + str.slice(1);\n        }\n\n        return str;\n    };\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        else if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    };\n\n    var encodeHTML = formatUtil.encodeHTML = function (source) {\n        return String(source)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    };\n\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    /**\n     * Template formatter\n     * @param {string} tpl\n     * @param {Array.<Object>|Object} paramsList\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList, encode) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            var val = wrapVar(alias, 0);\n            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                var val = paramsList[seriesIdx][$vars[k]];\n                tpl = tpl.replace(\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                    encode ? encodeHTML(val) : val\n                );\n            }\n        }\n\n        return tpl;\n    };\n\n    /**\n     * simple Template formatter\n     *\n     * @param {string} tpl\n     * @param {Object} param\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTplSimple = function (tpl, param, encode) {\n        zrUtil.each(param, function (value, key) {\n            tpl = tpl.replace(\n                '{' + key + '}',\n                encode ? encodeHTML(value) : value\n            );\n        });\n        return tpl;\n    };\n\n    /**\n     * @param {string} color\n     * @param {string} [extraCssText]\n     * @return {string}\n     */\n    formatUtil.getTooltipMarker = function (color, extraCssText) {\n        return color\n            ? '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:'\n                + formatUtil.encodeHTML(color) + ';' + (extraCssText || '') + '\"></span>'\n            : '';\n    };\n\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? ('0' + str) : str;\n    };\n\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @param {boolean} [isUTC=false] Default in local time.\n     *           see `module:echarts/scale/Time`\n     *           and `module:echarts/util/number#parseDate`.\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value, isUTC) {\n        if (tpl === 'week'\n            || tpl === 'month'\n            || tpl === 'quarter'\n            || tpl === 'half-year'\n            || tpl === 'year'\n        ) {\n            tpl = 'MM-dd\\nyyyy';\n        }\n\n        var date = numberUtil.parseDate(value);\n        var utc = isUTC ? 'UTC' : '';\n        var y = date['get' + utc + 'FullYear']();\n        var M = date['get' + utc + 'Month']() + 1;\n        var d = date['get' + utc + 'Date']();\n        var h = date['get' + utc + 'Hours']();\n        var m = date['get' + utc + 'Minutes']();\n        var s = date['get' + utc + 'Seconds']();\n\n        tpl = tpl.replace('MM', s2d(M))\n            .toLowerCase()\n            .replace('yyyy', y)\n            .replace('yy', y % 100)\n            .replace('dd', s2d(d))\n            .replace('d', d)\n            .replace('hh', s2d(h))\n            .replace('h', h)\n            .replace('mm', s2d(m))\n            .replace('m', m)\n            .replace('ss', s2d(s))\n            .replace('s', s);\n\n        return tpl;\n    };\n\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n\n    formatUtil.truncateText = textContain.truncateText;\n\n    module.exports = formatUtil;\n\n\n\n/***/ }),\n/* 198 */\n/***/ (function(module, exports) {\n\n/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // canvas\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n                // events currently. So we dont use that on other browsers unless tested sufficiently.\n                // Although IE 10 supports pointer event, it use old style and is different from the\n                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n                && (browser.edge || (browser.ie && browser.version >= 11))\n        };\n    }\n\n\n/***/ }),\n/* 199 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module echarts/model/Model\n */\n\n\n    var zrUtil = __webpack_require__(190);\n    var clazzUtil = __webpack_require__(201);\n    var env = __webpack_require__(198);\n\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;\n\n        // Simple optimization\n        // if (this.init) {\n        //     if (arguments.length <= 4) {\n        //         this.init(option, parentModel, ecModel, extraOpt);\n        //     }\n        //     else {\n        //         this.init.apply(this, arguments);\n        //     }\n        // }\n    }\n\n    Model.prototype = {\n\n        constructor: Model,\n\n        /**\n         * Model \n         * @param {Object} option\n         */\n        init: null,\n\n        /**\n         *  Option merge\n         */\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        get: function (path, ignoreParent) {\n            if (path == null) {\n                return this.option;\n            }\n\n            return doGet(\n                this.option,\n                this.parsePath(path),\n                !ignoreParent && getParent(this, path)\n            );\n        },\n\n        /**\n         * @param {string} key\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n\n            var val = option == null ? option : option[key];\n            var parentModel = !ignoreParent && getParent(this, key);\n            if (val == null && parentModel) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n\n        /**\n         * @param {string|Array.<string>} [path]\n         * @param {module:echarts/model/Model} [parentModel]\n         * @return {module:echarts/model/Model}\n         */\n        getModel: function (path, parentModel) {\n            var obj = path == null\n                ? this.option\n                : doGet(this.option, path = this.parsePath(path));\n\n            var thisParentModel;\n            parentModel = parentModel || (\n                (thisParentModel = getParent(this, path))\n                    && thisParentModel.getModel(path)\n            );\n\n            return new Model(obj, parentModel, this.ecModel);\n        },\n\n        /**\n         * If model has option\n         */\n        isEmpty: function () {\n            return this.option == null;\n        },\n\n        restoreData: function () {},\n\n        // Pending\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        },\n\n        // If path is null/undefined, return null/undefined.\n        parsePath: function(path) {\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            return path;\n        },\n\n        /**\n         * @param {Function} getParentMethod\n         *        param {Array.<string>|string} path\n         *        return {module:echarts/model/Model}\n         */\n        customizeGetParent: function (getParentMethod) {\n            clazzUtil.set(this, 'getParent', getParentMethod);\n        },\n\n        isAnimationEnabled: function () {\n            if (!env.node) {\n                if (this.option.animation != null) {\n                    return !!this.option.animation;\n                }\n                else if (this.parentModel) {\n                    return this.parentModel.isAnimationEnabled();\n                }\n            }\n        }\n    };\n\n    function doGet(obj, pathArr, parentModel) {\n        for (var i = 0; i < pathArr.length; i++) {\n            // Ignore empty\n            if (!pathArr[i]) {\n                continue;\n            }\n            // obj could be number/string/... (like 0)\n            obj = (obj && typeof obj === 'object') ? obj[pathArr[i]] : null;\n            if (obj == null) {\n                break;\n            }\n        }\n        if (obj == null && parentModel) {\n            obj = parentModel.get(pathArr);\n        }\n        return obj;\n    }\n\n    // `path` can be null/undefined\n    function getParent(model, path) {\n        var getParentMethod = clazzUtil.get(model, 'getParent');\n        return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n    }\n\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n\n    var mixin = zrUtil.mixin;\n    mixin(Model, __webpack_require__(276));\n    mixin(Model, __webpack_require__(273));\n    mixin(Model, __webpack_require__(277));\n    mixin(Model, __webpack_require__(275));\n\n    module.exports = Model;\n\n\n/***/ }),\n/* 200 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = __webpack_require__(195);\n    var matrix = __webpack_require__(204);\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // \n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n\n/***/ }),\n/* 201 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var clazz = {};\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    var MEMBER_PRIFIX = '\\0ec_\\0';\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name] = value;` (can be right-value)\n     * @public\n     */\n    clazz.set = function (host, name, value) {\n        return (host[MEMBER_PRIFIX + name] = value);\n    };\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name];`\n     * @public\n     */\n    clazz.get = function (host, name) {\n        return host[MEMBER_PRIFIX + name];\n    };\n\n    /**\n     * For hidden private class member.\n     * The same behavior as `host.hasOwnProperty(name);`\n     * @public\n     */\n    clazz.hasOwn = function (host, name) {\n        return host.hasOwnProperty(MEMBER_PRIFIX + name);\n    };\n\n    /**\n     * Notice, parseClassType('') should returns {main: '', sub: ''}\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n        var ret = {main: '', sub: ''};\n        if (componentType) {\n            componentType = componentType.split(TYPE_DELIMITER);\n            ret.main = componentType[0] || '';\n            ret.sub = componentType[1] || '';\n        }\n        return ret;\n    };\n\n    /**\n     * @public\n     */\n    function checkClassType(componentType) {\n        zrUtil.assert(\n            /^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType),\n            'componentType \"' + componentType + '\" illegal'\n        );\n    }\n\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n\n            if (__DEV__) {\n                zrUtil.each(mandatoryMethods, function (method) {\n                    if (!proto[method]) {\n                        console.warn(\n                            'Method `' + method + '` should be implemented'\n                            + (proto.type ? ' in ' + proto.type : '') + '.'\n                        );\n                    }\n                });\n            }\n\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                }\n                else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n\n            zrUtil.extend(ExtendedClass.prototype, proto);\n\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n\n            return ExtendedClass;\n        };\n    };\n\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                checkClassType(componentType);\n                componentType = parseClassType(componentType);\n\n                if (!componentType.sub) {\n                    if (__DEV__) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                }\n                else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n\n        entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n            var Clazz = storage[componentMainType];\n\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error(\n                    !subType\n                        ? componentMainType + '.' + 'type should be specified.'\n                        : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.'\n                );\n            }\n\n            return Clazz;\n        };\n\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n\n            var result = [];\n            var obj = storage[componentType.main];\n\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            }\n            else {\n                result.push(obj);\n            }\n\n            return result;\n        };\n\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n\n        entity.parseClassType = parseClassType;\n\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n\n        return entity;\n    };\n\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n        // FIXME It seems broken in IE8 simulation of IE11\n        // if (!zrUtil.isArray(properties)) {\n        //     properties = properties != null ? [properties] : [];\n        // }\n        // zrUtil.each(properties, function (prop) {\n        //     var value = obj[prop];\n\n        //     Object.defineProperty\n        //         && Object.defineProperty(obj, prop, {\n        //             value: value, writable: false\n        //         });\n        //     zrUtil.isArray(obj[prop])\n        //         && Object.freeze\n        //         && Object.freeze(obj[prop]);\n        // });\n    };\n\n    module.exports = clazz;\n\n\n/***/ }),\n/* 202 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\n\n    var Model = __webpack_require__(199);\n    var zrUtil = __webpack_require__(190);\n    var arrayPush = Array.prototype.push;\n    var componentUtil = __webpack_require__(225);\n    var clazzUtil = __webpack_require__(201);\n    var layout = __webpack_require__(203);\n\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n\n        type: 'component',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        id: '',\n\n        /**\n         * @readOnly\n         */\n        name: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        mainType: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        subType: '',\n\n        /**\n         * @readOnly\n         * @type {number}\n         */\n        componentIndex: 0,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        ecModel: null,\n\n        /**\n         * key: componentType\n         * value:  Component model list, can not be null.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @readOnly\n         */\n        dependentModels: [],\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        uid: null,\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        $constructor: function (option, parentModel, ecModel, extraOpt) {\n            Model.call(this, option, parentModel, ecModel, extraOpt);\n\n            this.uid = componentUtil.getUID('componentModel');\n        },\n\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n            this.mergeDefaultAndTheme(option, ecModel);\n        },\n\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            var themeModel = ecModel.getTheme();\n            zrUtil.merge(option, themeModel.get(this.mainType));\n            zrUtil.merge(option, this.getDefaultOption());\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (option, extraOpt) {\n            zrUtil.merge(this.option, option, true);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, option, layoutMode);\n            }\n        },\n\n        // Hooker after init or mergeOption\n        optionUpdated: function (newCptOption, isInit) {},\n\n        getDefaultOption: function () {\n            if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n                var optList = [];\n                var Class = this.constructor;\n                while (Class) {\n                    var opt = Class.prototype.defaultOption;\n                    opt && optList.push(opt);\n                    Class = Class.superClass;\n                }\n\n                var defaultOption = {};\n                for (var i = optList.length - 1; i >= 0; i--) {\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                }\n                clazzUtil.set(this, '__defaultOption', defaultOption);\n            }\n            return clazzUtil.get(this, '__defaultOption');\n        },\n\n        getReferringComponents: function (mainType) {\n            return this.ecModel.queryComponents({\n                mainType: mainType,\n                index: this.get(mainType + 'Index', true),\n                id: this.get(mainType + 'Id', true)\n            });\n        }\n\n    });\n\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n\n    //         this.uid = componentUtil.getUID('componentModel');\n\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(\n        ComponentModel, {registerWhenExtend: true}\n    );\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n\n    zrUtil.mixin(ComponentModel, __webpack_require__(274));\n\n    module.exports = ComponentModel;\n\n\n/***/ }),\n/* 203 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Layout helpers for each component positioning\n\n\n    var zrUtil = __webpack_require__(190);\n    var BoundingRect = __webpack_require__(200);\n    var numberUtil = __webpack_require__(193);\n    var formatUtil = __webpack_require__(197);\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n\n    var layout = {};\n\n    /**\n     * @public\n     */\n    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [\n        'left', 'right', 'top', 'bottom', 'width', 'height'\n    ];\n\n    /**\n     * @public\n     */\n    var HV_NAMES = layout.HV_NAMES = [\n        ['width', 'left', 'right'],\n        ['height', 'top', 'bottom']\n    ];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            }\n            else {\n                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n\n            if (child.newline) {\n                return;\n            }\n\n            position[0] = x;\n            position[1] = y;\n\n            orient === 'horizontal'\n                ? (x = nextX + gap)\n                : (y = nextY + gap);\n        });\n    }\n\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (\n        positionInfo, containerRect, margin\n    ) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            }\n            else {\n                height = containerHeight * 0.8;\n            }\n        }\n\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n            case 'center':\n                left = containerWidth / 2 - width / 2 - margin[3];\n                break;\n            case 'right':\n                left = containerWidth - width - horizontalMargin;\n                break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n            case 'middle':\n            case 'center':\n                top = containerHeight / 2 - height / 2 - margin[0];\n                break;\n            case 'bottom':\n                top = containerHeight - height - verticalMargin;\n                break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n\n\n    /**\n     * Position a zr element in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * Logic:\n     *     1. Scale (against origin point in parent coord)\n     *     2. Rotate (against origin point in parent coord)\n     *     3. Traslate (with el.position by this method)\n     * So this method only fixes the last step 'Traslate', which does not affect\n     * scaling and rotating.\n     *\n     * If be called repeatly with the same input el, the same result will be gotten.\n     *\n     * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @param {Object} [opt]\n     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n     * @param {Array.<number>} [opt.boundingMode='all']\n     *        Specify how to calculate boundingRect when locating.\n     *        'all': Position the boundingRect that is transformed and uioned\n     *               both itself and its descendants.\n     *               This mode simplies confine the elements in the bounding\n     *               of their container (e.g., using 'right: 0').\n     *        'raw': Position the boundingRect that is not transformed and only itself.\n     *               This mode is useful when you want a element can overflow its\n     *               container. (Consider a rotated circle needs to be located in a corner.)\n     *               In this mode positionInfo.width/height can only be number.\n     */\n    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\n        var h = !opt || !opt.hv || opt.hv[0];\n        var v = !opt || !opt.hv || opt.hv[1];\n        var boundingMode = opt && opt.boundingMode || 'all';\n\n        if (!h && !v) {\n            return;\n        }\n\n        var rect;\n        if (boundingMode === 'raw') {\n            rect = el.type === 'group'\n                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n                : el.getBoundingRect();\n        }\n        else {\n            rect = el.getBoundingRect();\n            if (el.needLocalTransform()) {\n                var transform = el.getLocalTransform();\n                // Notice: raw rect may be inner object of el,\n                // which should not be modified.\n                rect = rect.clone();\n                rect.applyTransform(transform);\n            }\n        }\n\n        positionInfo = layout.getLayoutRect(\n            zrUtil.defaults(\n                {width: rect.width, height: rect.height},\n                positionInfo\n            ),\n            containerRect,\n            margin\n        );\n\n        // Because 'tranlate' is the last step in transform\n        // (see zrender/core/Transformable#getLocalTransfrom),\n        // we can just only modify el.position to get final result.\n        var elPos = el.position;\n        var dx = h ? positionInfo.x - rect.x : 0;\n        var dy = v ? positionInfo.y - rect.y : 0;\n\n        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n    };\n\n    /**\n     * @param {Object} option Contains some of the properties in HV_NAMES.\n     * @param {number} hvIdx 0: horizontal; 1: vertical.\n     */\n    layout.sizeCalculable = function (option, hvIdx) {\n        return option[HV_NAMES[hvIdx][0]] != null\n            || (option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null);\n    };\n\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n\n        var ignoreSize = opt.ignoreSize;\n        !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n\n        var hResult = merge(HV_NAMES[0], 0);\n        var vResult = merge(HV_NAMES[1], 1);\n\n        copy(HV_NAMES[0], targetOption, hResult);\n        copy(HV_NAMES[1], targetOption, vResult);\n\n        function merge(names, hvIdx) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = 2;\n\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n\n            if (ignoreSize[hvIdx]) {\n                // Only one of left/right is premitted to exist.\n                if (hasValue(newOption, names[1])) {\n                    merged[names[2]] = null;\n                }\n                else if (hasValue(newOption, names[2])) {\n                    merged[names[1]] = null;\n                }\n                return merged;\n            }\n\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }\n            // Case: newOption: {width: ..., right: ...},\n            // Than we can make sure user only want those two, and ignore\n            // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            }\n            else {\n                // Chose another param from targetOption by priority.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n\n    module.exports = layout;\n\n\n\n/***/ }),\n/* 204 */\n/***/ (function(module, exports) {\n\n\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * \n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n/***/ }),\n/* 205 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var OrdinalScale = __webpack_require__(281);\n    var IntervalScale = __webpack_require__(222);\n    __webpack_require__(282);\n    __webpack_require__(280);\n    var Scale = __webpack_require__(213);\n\n    var numberUtil = __webpack_require__(193);\n    var zrUtil = __webpack_require__(190);\n    var textContain = __webpack_require__(206);\n    var axisHelper = {};\n\n    /**\n     * Get axis scale extent before niced.\n     * Item of returned array can only be number (including Infinity and NaN).\n     */\n    axisHelper.getScaleExtent = function (scale, model) {\n        var scaleType = scale.type;\n\n        var min = model.getMin();\n        var max = model.getMax();\n        var fixMin = min != null;\n        var fixMax = max != null;\n        var originalExtent = scale.getExtent();\n\n        var axisDataLen;\n        var boundaryGap;\n        var span;\n        if (scaleType === 'ordinal') {\n            axisDataLen = (model.get('data') || []).length;\n        }\n        else {\n            boundaryGap = model.get('boundaryGap');\n            if (!zrUtil.isArray(boundaryGap)) {\n                boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n            }\n            if (typeof boundaryGap[0] === 'boolean') {\n                if (__DEV__) {\n                    console.warn('Boolean type for boundaryGap is only '\n                        + 'allowed for ordinal axis. Please use string in '\n                        + 'percentage instead, e.g., \"20%\". Currently, '\n                        + 'boundaryGap is set to be 0.');\n                }\n                boundaryGap = [0, 0];\n            }\n            boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n            span = (originalExtent[1] - originalExtent[0])\n                || Math.abs(originalExtent[0]);\n        }\n\n        // Notice: When min/max is not set (that is, when there are null/undefined,\n        // which is the most common case), these cases should be ensured:\n        // (1) For 'ordinal', show all axis.data.\n        // (2) For others:\n        //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n        //      disabled).\n        //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n        //      be the result that originalExtent enlarged by boundaryGap.\n        // (3) If no data, it should be ensured that `scale.setBlank` is set.\n\n        // FIXME\n        // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n        // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n        // that the results processed by boundaryGap are positive/negative?\n\n        if (min == null) {\n            min = scaleType === 'ordinal'\n                ? (axisDataLen ? 0 : NaN)\n                : originalExtent[0] - boundaryGap[0] * span;\n        }\n        if (max == null) {\n            max = scaleType === 'ordinal'\n                ? (axisDataLen ? axisDataLen - 1 : NaN)\n                : originalExtent[1] + boundaryGap[1] * span;\n        }\n\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n\n        (min == null || !isFinite(min)) && (min = NaN);\n        (max == null || !isFinite(max)) && (max = NaN);\n\n        scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max));\n\n        // Evaluate if axis needs cross zero\n        if (model.getNeedCrossZero()) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n\n        return [min, max];\n    };\n\n    axisHelper.niceScaleExtent = function (scale, model) {\n        var extent = axisHelper.getScaleExtent(scale, model);\n        var fixMin = model.getMin() != null;\n        var fixMax = model.getMax() != null;\n        var splitNumber = model.get('splitNumber');\n\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent({\n            splitNumber: splitNumber,\n            fixMin: fixMin,\n            fixMax: fixMax,\n            minInterval: scale.type === 'interval' ? model.get('minInterval') : null\n        });\n\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function(model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n                // Buildin scale\n                case 'category':\n                    return new OrdinalScale(\n                        model.getCategories(), [Infinity, -Infinity]\n                    );\n                case 'value':\n                    return new IntervalScale();\n                // Extended scale, like time and log\n                default:\n                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n    };\n\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // axislabelhorizontalvertical.\n\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(\n                labels[i], font, 'center', 'top'\n            );\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }\n            // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            }\n            else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = (function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val != null ? val : '');\n                };\n            })(labelFormatter);\n            // Consider empty array\n            return zrUtil.map(labels, labelFormatter);\n        }\n        else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(\n                    axisHelper.getAxisRawValue(axis, tick),\n                    idx\n                );\n            }, this);\n        }\n        else {\n            return labels;\n        }\n    };\n\n    axisHelper.getAxisRawValue = function (axis, value) {\n        // In category axis with data zoom, tick is not the original\n        // index of axis.data. So tick should not be exposed to user\n        // in category axis.\n        return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n    };\n\n    module.exports = axisHelper;\n\n\n/***/ }),\n/* 206 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = __webpack_require__(190);\n    var BoundingRect = __webpack_require__(200);\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText  Canvas \n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME \n        var lineHeight = getTextWidth('', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var lineHeight = textRect.lineHeight;\n        var halfHeight = height / 2 - textHeight / 2 + lineHeight;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight - lineHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance + lineHeight;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance + lineHeight;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance + lineHeight;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance + lineHeight;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'alphabetic'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n\n/***/ }),\n/* 207 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = __webpack_require__(195);\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // \n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} \n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] \n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out \n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n/***/ }),\n/* 208 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module zrender/tool/color\n */\n\n\n    var LRU = __webpack_require__(243);\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    function setRgba(out, r, g, b, a) {\n        out[0] = r; out[1] = g; out[2] = b; out[3] = a;\n        return out;\n    }\n    function copyRgba(out, a) {\n        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n        return out;\n    }\n    var colorCache = new LRU(20);\n    var lastRemovedArr = null;\n    function putToCache(colorStr, rgbaArr) {\n        // Reuse removed array\n        if (lastRemovedArr) {\n            copyRgba(lastRemovedArr, rgbaArr);\n        }\n        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n    }\n    /**\n     * @param {string} colorStr\n     * @param {Array.<number>} out\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr, rgbaArr) {\n        if (!colorStr) {\n            return;\n        }\n        rgbaArr = rgbaArr || [];\n\n        var cached = colorCache.get(colorStr);\n        if (cached) {\n            return copyRgba(rgbaArr, cached);\n        }\n\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            copyRgba(rgbaArr, kCSSColorTable[str]);\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    setRgba(rgbaArr,\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    );\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsla':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsl':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                default:\n                    return;\n            }\n        }\n\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla, rgba) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        rgba = rgba || [];\n        setRgba(rgba,\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),\n            1\n        );\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array.\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>} will be null/undefined if input illegal.\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        out = out || [];\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssFloat(lerp(leftColor[3], rightColor[3], dv));\n\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<number>} arrColor like [12,33,44,0.4]\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color. (If input illegal, return undefined).\n     */\n    function stringify(arrColor, type) {\n        if (!arrColor || !arrColor.length) {\n            return;\n        }\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n/***/ }),\n/* 209 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = __webpack_require__(210);\n    var env = __webpack_require__(198);\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * domtouch.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * preventDefault and stopPropagation.\n     * Notice: do not do that in zrender. Upper application\n     * do that if necessary.\n     *\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // \n        Dispatcher: Eventful\n    };\n\n\n\n/***/ }),\n/* 210 */\n/***/ (function(module, exports) {\n\n/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * \n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * trigger\n         *\n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} [handler] \n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * \n         *\n         * @param {string} type \n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * context, context\n         * @param {string} type \n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    //  onxxxx \n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n/***/ }),\n/* 211 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array;\n\n    var dataCtors = {\n        'float': Float64Array,\n        'int': Int32Array,\n        // Ordinal data type can be string or int\n        'ordinal': Array,\n        'number': Array,\n        'time': Array\n    };\n\n    var Model = __webpack_require__(199);\n    var DataDiffer = __webpack_require__(252);\n\n    var zrUtil = __webpack_require__(190);\n    var modelUtil = __webpack_require__(194);\n    var isObject = zrUtil.isObject;\n\n    var TRANSFERABLE_PROPERTIES = [\n        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n    ];\n\n    function transferProperties(a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n\n        a.__wrappedMethods = b.__wrappedMethods;\n    }\n\n    function DefaultDataProvider(dataArray) {\n        this._array = dataArray || [];\n    }\n\n    DefaultDataProvider.prototype.pure = false;\n\n    DefaultDataProvider.prototype.count = function () {\n        return this._array.length;\n    };\n    DefaultDataProvider.prototype.getItem = function (idx) {\n        return this._array[idx];\n    };\n\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string|Object>} dimensions\n     *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n     *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n\n        dimensions = dimensions || ['x', 'y'];\n\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    coordDim: dimensionName,\n                    coordDimIndex: 0,\n                    stackable: false,\n                    // Type can be 'float', 'int', 'number'\n                    // Default is number, Precision of float may not enough\n                    type: 'number'\n                };\n            }\n            else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n                if (!dimensionInfo.coordDim) {\n                    dimensionInfo.coordDim = dimensionName;\n                    dimensionInfo.coordDimIndex = 0;\n                }\n            }\n            dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n\n    var listProto = List.prototype;\n\n    listProto.type = 'list';\n\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n\n        var isDataArray = zrUtil.isArray(data);\n        if (isDataArray) {\n            data = new DefaultDataProvider(data);\n        }\n        if (__DEV__) {\n            if (!isDataArray && (typeof data.getItem != 'function' || typeof data.count != 'function')) {\n                throw new Error('Inavlid data provider.');\n            }\n        }\n\n        this._rawData = data;\n\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n\n        var dimensions = this.dimensions;\n        var dimensionInfoMap = this._dimensionInfos;\n\n        var size = data.count();\n\n        var idList = [];\n        var nameRepeatCount = {};\n        var nameDimIdx;\n\n        nameList = nameList || [];\n\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(\n                (value instanceof Array)\n                    ? value[dimIndex]\n                    // If value is a single number or something else not array.\n                    : value,\n                dimensionInfoMap[dimName]\n            );\n        };\n\n        for (var i = 0; i < size; i++) {\n            // NOTICE: Try not to write things into dataItem\n            var dataItem = data.getItem(i);\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[i] = dimValueGetter(dataItem, dim, i, k);\n            }\n\n            indices.push(i);\n        }\n\n        // Use the name in option and create id\n        for (var i = 0; i < size; i++) {\n            var dataItem = data.getItem(i);\n            if (!nameList[i] && dataItem) {\n                if (dataItem.name != null) {\n                    nameList[i] = dataItem.name;\n                }\n                else if (nameDimIdx != null) {\n                    nameList[i] = storage[dimensions[nameDimIdx]][i];\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = dataItem && dataItem.id;\n\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n\n        // If value not exists\n        if (dataIndex == null || !storage[dim]) {\n            return NaN;\n        }\n\n        var value = storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n                        || (value <= 0 && stackedValue < 0) // Negative stack\n                    ) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n\n        return values;\n    };\n\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (\n                // Ordinal type can be string or number\n                dimensionInfos[dimensions[i]].type !== 'ordinal'\n                && isNaN(this.get(dimensions[i], idx))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     * @param {Function} filter\n     */\n    listProto.getDataExtent = function (dim, stack, filter) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = (dimInfo && dimInfo.stackable) && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                if (!filter || filter(value, dim, i)) {\n                    value < min && (min = value);\n                    value > max && (max = value);\n                }\n            }\n            return (this._extent[dim + !!stack] = [min, max]);\n        }\n        else {\n            return [Infinity, -Infinity];\n        }\n    };\n\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n\n        // If rawIndex === dataIndex\n        var rawDataIndex = indices[rawIndex];\n        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n            return rawIndex;\n        }\n\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            }\n            else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {Array.<number>} Considere multiple points has the same value.\n     */\n    listProto.indicesOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var nearestIndices = [];\n\n        if (!dimData) {\n            return nearestIndices;\n        }\n\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n\n        var minDist = Number.MAX_VALUE;\n        var minDiff = -1;\n        for (var i = 0, len = this.count(); i < len; i++) {\n            var diff = value - this.get(dim, i, stack);\n            var dist = Math.abs(diff);\n            if (diff <= maxDistance && dist <= minDist) {\n                // For the case of two data are same on xAxis, which has sequence data.\n                // Show the nearest index\n                // https://github.com/ecomfe/echarts/issues/2869\n                if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                    minDist = dist;\n                    minDiff = diff;\n                    nearestIndices.length = 0;\n                }\n                nearestIndices.push(i);\n            }\n        }\n        return nearestIndices;\n    };\n\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData.getItem(this.getRawIndex(idx));\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n    };\n\n\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n                case 0:\n                    cb.call(context, i);\n                    break;\n                case 1:\n                    cb.call(context, this.get(dims[0], i, stack), i);\n                    break;\n                case 2:\n                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                    break;\n                default:\n                    for (var k = 0; k < dimSize; k++) {\n                        value[k] = this.get(dims[k], i, stack);\n                    }\n                    // Index\n                    value[k] = i;\n                    cb.apply(context, value);\n            }\n        }\n    };\n\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (!dimSize) {\n                keep = cb.call(context, i);\n            }\n            else if (dimSize === 1) {\n                keep = cb.call(\n                    context, this.get(dimensions[0], i, stack), i\n                );\n            }\n            else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n\n        this.indices = newIndices;\n\n        // Reset data extent\n        this._extent = {};\n\n        return this;\n    };\n\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(\n            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n            original.hostModel\n        );\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(\n                    originalStorage[dim].length\n                );\n            }\n            else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n\n        var storage = list._storage;\n\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n\n        return list;\n    };\n\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n\n        return list;\n    };\n\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);\n    };\n\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        var val;\n        // Use prefix to avoid index to be the same as otherIdList[idx],\n        // which will cause weird udpate animation.\n        var prefix = 'e\\0\\0';\n\n        return new DataDiffer(\n            otherList ? otherList.indices : [],\n            this.indices,\n            function (idx) {\n                return (val = otherIdList[idx]) != null ? val : prefix + idx;\n            },\n            function (idx) {\n                return (val = idList[idx]) != null ? val : prefix + idx;\n            }\n        );\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge\n            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n            : layout;\n    };\n\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} [ignoreParent=false]\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n\n        this._graphicEls[idx] = el;\n    };\n\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n\n        // FIXME\n        list._storage = this._storage;\n\n        transferProperties(list, this);\n\n\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n\n        return list;\n    };\n\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\n    module.exports = List;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(80)))\n\n/***/ }),\n/* 212 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = __webpack_require__(207);\n    var vec2 = __webpack_require__(195);\n    var bbox = __webpack_require__(257);\n    var BoundingRect = __webpack_require__(200);\n    var dpr = __webpack_require__(214).devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    // var CMD_MEM_SIZE = {\n    //     M: 3,\n    //     L: 3,\n    //     C: 7,\n    //     Q: 5,\n    //     A: 9,\n    //     R: 5,\n    //     Z: 1\n    // };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function (notSaveData) {\n\n        this._saveData = !(notSaveData || false);\n\n        if (this._saveData) {\n            /**\n             * Path data. Stored as flat array\n             * @type {Array.<Object>}\n             */\n            this.data = [];\n        }\n\n        this._ctx = null;\n    };\n\n    /**\n     * Path\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _xi: 0,\n        _yi: 0,\n\n        _x0: 0,\n        _y0: 0,\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        _ux: 0,\n        _uy: 0,\n\n        _len: 0,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            if (this._saveData) {\n                this._len = 0;\n            }\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi  _dashedXXXXTo \n            // xi, yi , x0, y0  closePath \n            //  beginPath  lineTo x0, y0 \n            //  lineTo dashed line  IE10- \n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._yi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context  rebuildPath  fill\n         * stroke \n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         *  Path \n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * \n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         *  Path \n         * \n         */\n        addData: function (cmd) {\n            if (!this._saveData) {\n                return;\n            }\n\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                //  Float32Array\n                // \n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         *  Float32Array \n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo  subpath, \n                        //  closePath \n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc \n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc \n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n/***/ }),\n/* 213 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n\n    var clazzUtil = __webpack_require__(201);\n\n    /**\n     * @param {Object} [setting]\n     */\n    function Scale(setting) {\n        this._setting = setting || {};\n\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [Infinity, -Infinity];\n\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n\n        this.init && this.init.apply(this, arguments);\n    }\n\n    var scaleProto = Scale.prototype;\n\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n\n    scaleProto.getSetting = function (name) {\n        return this._setting[name];\n    };\n\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        // not setExtent because in log axis it may transformed to power\n        // this.setExtent(extent[0], extent[1]);\n    };\n\n    /**\n     * Set extent from data\n     * @param {module:echarts/data/List} data\n     * @param {string} dim\n     */\n    scaleProto.unionExtentFromData = function (data, dim) {\n        this.unionExtent(data.getDataExtent(dim, true));\n    };\n\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.isBlank = function () {\n        return this._isBlank;\n    },\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.setBlank = function (isBlank) {\n        this._isBlank = isBlank;\n    };\n\n\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, {\n        registerWhenExtend: true\n    });\n\n    module.exports = Scale;\n\n\n/***/ }),\n/* 214 */\n/***/ (function(module, exports) {\n\n\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config\n     * @exports zrender/config\n     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debugcatchBrushExceptiontrue\n         * 0 : debug\n         * 1 : \n         * 2 : \n         */\n        debugMode: 0,\n\n        // retina \n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n/***/ }),\n/* 215 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = __webpack_require__(190);\n    var Element = __webpack_require__(239);\n    var BoundingRect = __webpack_require__(200);\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * \n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         *  index \n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * \n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         *  nextSibling \n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToStorage(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromStorage(child);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * \n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromStorage(child);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToStorage(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromStorage(child);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n/***/ }),\n/* 216 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var coordinateSystemCreators = {};\n\n    function CoordinateSystemManager() {\n\n        this._coordinateSystems = [];\n    }\n\n    CoordinateSystemManager.prototype = {\n\n        constructor: CoordinateSystemManager,\n\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n                var list = creater.create(ecModel, api);\n                coordinateSystems = coordinateSystems.concat(list || []);\n            });\n\n            this._coordinateSystems = coordinateSystems;\n        },\n\n        update: function (ecModel, api) {\n            zrUtil.each(this._coordinateSystems, function (coordSys) {\n                // FIXME MUST have\n                coordSys.update && coordSys.update(ecModel, api);\n            });\n        },\n\n        getCoordinateSystems: function () {\n            return this._coordinateSystems.slice();\n        }\n    };\n\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n\n    module.exports = CoordinateSystemManager;\n\n\n/***/ }),\n/* 217 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var formatUtil = __webpack_require__(197);\n    var classUtil = __webpack_require__(201);\n    var modelUtil = __webpack_require__(194);\n    var ComponentModel = __webpack_require__(202);\n    var colorPaletteMixin = __webpack_require__(237);\n    var env = __webpack_require__(198);\n    var layout = __webpack_require__(203);\n\n    var set = classUtil.set;\n    var get = classUtil.get;\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            var data = this.getInitialData(option, ecModel);\n            if (__DEV__) {\n                zrUtil.assert(data, 'getInitialData returned invalid data.');\n            }\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            set(this, 'dataBeforeProcessed', data);\n\n            // If we reverse the order (make data firstly, and then make\n            // dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause data.graph.data !== data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this.restoreData();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `position` and `show`\n            // FIXME Set label in mergeOption\n            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\n            this.fillDataTextStyle(option.data);\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n            }\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                set(this, 'data', data);\n                set(this, 'dataBeforeProcessed', data.cloneShallow());\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `position` and `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            var data = get(this, 'data');\n            return dataType == null ? data : data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            set(this, 'data', data);\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return get(this, 'dataBeforeProcessed');\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return modelUtil.coordDimToDataDim(this.getData(), coordDim);\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return modelUtil.dataDimToCoordDim(this.getData(), dataDim);\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var vertially = zrUtil.reduce(value, function (vertially, val, idx) {\n                    var dimItem = data.getDimensionInfo(idx);\n                    return vertially |= dimItem && dimItem.tooltip !== false && dimItem.tooltipName != null;\n                }, 0);\n\n                var result = [];\n                var tooltipDims = modelUtil.otherDimToDataDim(data, 'tooltip');\n\n                tooltipDims.length\n                    ? zrUtil.each(tooltipDims, function (dimIdx) {\n                        setEachItem(data.get(dimIdx, dataIndex), dimIdx);\n                    })\n                    // By default, all dims is used on tooltip.\n                    : zrUtil.each(value, setEachItem);\n\n                function setEachItem(val, dimIdx) {\n                    var dimInfo = data.getDimensionInfo(dimIdx);\n                    // If `dimInfo.tooltip` is not set, show tooltip.\n                    if (!dimInfo || dimInfo.otherDims.tooltip === false) {\n                        return;\n                    }\n                    var dimType = dimInfo.type;\n                    var valStr = (vertially ? '- ' + (dimInfo.tooltipName || dimInfo.name) + ': ' : '')\n                        + (dimType === 'ordinal'\n                            ? val + ''\n                            : dimType === 'time'\n                            ? (multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val))\n                            : addCommas(val)\n                        );\n                    valStr && result.push(encodeHTML(valStr));\n                }\n\n                return (vertially ? '<br/>' : '') + result.join(vertially ? '<br/>' : ', ');\n            }\n\n            var data = get(this, 'data');\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = zrUtil.isArray(value)\n                ? formatArrayValue(value) : encodeHTML(addCommas(value));\n            var name = data.getName(dataIndex);\n\n            var color = data.getItemVisual(dataIndex, 'color');\n            if (zrUtil.isObject(color) && color.colorStops) {\n                color = (color.colorStops[0] || {}).color;\n            }\n            color = color || 'transparent';\n\n            var colorEl = formatUtil.getTooltipMarker(color);\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            seriesName = seriesName\n                ? encodeHTML(seriesName) + (!multipleSeries ? '<br/>' : ': ')\n                : '';\n            return !multipleSeries\n                ? seriesName + colorEl\n                    + (name\n                        ? encodeHTML(name) + ': ' + formattedValue\n                        : formattedValue\n                    )\n                : colorEl + seriesName + formattedValue;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        isAnimationEnabled: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Object} {dataIndices, nestestValue}.\n         */\n        getAxisTooltipData: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n\n\n/***/ }),\n/* 218 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = __webpack_require__(190);\n    var modelUtil = __webpack_require__(194);\n    var each = zrUtil.each;\n    var isString = zrUtil.isString;\n    var defaults = zrUtil.defaults;\n    var normalizeToArray = modelUtil.normalizeToArray;\n\n    var OTHER_DIMS = {tooltip: 1, label: 1, itemName: 1};\n\n    /**\n     * Complete the dimensions array, by user defined `dimension` and `encode`,\n     * and guessing from the data structure.\n     * If no 'value' dimension specified, the first no-named dimension will be\n     * named as 'value'.\n     *\n     * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which\n     *      provides not only dim template, but also default order.\n     *      `name` of each item provides default coord name.\n     *      [{dimsDef: []}, ...] can be specified to give names.\n     * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].\n     * @param {Object} [opt]\n     * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions\n     *      For example: ['asdf', {name, type}, ...].\n     * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}\n     * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.\n     * @param {string} [opt.extraFromZero] If specified, extra dim names will be:\n     *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...\n     *                      If not specified, extra dim names will be:\n     *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...\n     * @param {number} [opt.dimCount] If not specified, guess by the first data item.\n     * @return {Array.<Object>} [{\n     *      name: string mandatory,\n     *      coordDim: string mandatory,\n     *      coordDimIndex: number mandatory,\n     *      type: string optional,\n     *      tooltipName: string optional,\n     *      otherDims: {\n     *          tooltip: number optional,\n     *          label: number optional\n     *      },\n     *      isExtraCoord: boolean true or undefined.\n     *      other props ...\n     * }]\n     */\n    function completeDimensions(sysDims, data, opt) {\n        data = data || [];\n        opt = opt || {};\n        sysDims = (sysDims || []).slice();\n        var dimsDef = (opt.dimsDef || []).slice();\n        var encodeDef = zrUtil.createHashMap(opt.encodeDef);\n        var dataDimNameMap = zrUtil.createHashMap();\n        var coordDimNameMap = zrUtil.createHashMap();\n        // var valueCandidate;\n        var result = [];\n\n        var dimCount = opt.dimCount;\n        if (dimCount == null) {\n            var value0 = retrieveValue(data[0]);\n            dimCount = Math.max(\n                zrUtil.isArray(value0) && value0.length || 1,\n                sysDims.length,\n                dimsDef.length\n            );\n            each(sysDims, function (sysDimItem) {\n                var sysDimItemDimsDef = sysDimItem.dimsDef;\n                sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));\n            });\n        }\n\n        // Apply user defined dims (`name` and `type`) and init result.\n        for (var i = 0; i < dimCount; i++) {\n            var dimDefItem = isString(dimsDef[i]) ? {name: dimsDef[i]} : (dimsDef[i] || {});\n            var userDimName = dimDefItem.name;\n            var resultItem = result[i] = {otherDims: {}};\n            // Name will be applied later for avoiding duplication.\n            if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n                // Only if `series.dimensions` is defined in option, tooltipName\n                // will be set, and dimension will be diplayed vertically in\n                // tooltip by default.\n                resultItem.name = resultItem.tooltipName = userDimName;\n                dataDimNameMap.set(userDimName, i);\n            }\n            dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n        }\n\n        // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.\n        encodeDef.each(function (dataDims, coordDim) {\n            dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice());\n            each(dataDims, function (resultDimIdx, coordDimIndex) {\n                // The input resultDimIdx can be dim name or index.\n                isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));\n                if (resultDimIdx != null && resultDimIdx < dimCount) {\n                    dataDims[coordDimIndex] = resultDimIdx;\n                    applyDim(result[resultDimIdx], coordDim, coordDimIndex);\n                }\n            });\n        });\n\n        // Apply templetes and default order from `sysDims`.\n        var availDimIdx = 0;\n        each(sysDims, function (sysDimItem, sysDimIndex) {\n            var coordDim;\n            var sysDimItem;\n            var sysDimItemDimsDef;\n            var sysDimItemOtherDims;\n            if (isString(sysDimItem)) {\n                coordDim = sysDimItem;\n                sysDimItem = {};\n            }\n            else {\n                coordDim = sysDimItem.name;\n                sysDimItem = zrUtil.clone(sysDimItem);\n                // `coordDimIndex` should not be set directly.\n                sysDimItemDimsDef = sysDimItem.dimsDef;\n                sysDimItemOtherDims = sysDimItem.otherDims;\n                sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex\n                    = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n            }\n\n            var dataDims = normalizeToArray(encodeDef.get(coordDim));\n            // dimensions provides default dim sequences.\n            if (!dataDims.length) {\n                for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n                    while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n                        availDimIdx++;\n                    }\n                    availDimIdx < result.length && dataDims.push(availDimIdx++);\n                }\n            }\n            // Apply templates.\n            each(dataDims, function (resultDimIdx, coordDimIndex) {\n                var resultItem = result[resultDimIdx];\n                applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n                if (resultItem.name == null && sysDimItemDimsDef) {\n                    resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];\n                }\n                sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n            });\n        });\n\n        // Make sure the first extra dim is 'value'.\n        var extra = opt.extraPrefix || 'value';\n\n        // Set dim `name` and other `coordDim` and other props.\n        for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n            var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};\n            var coordDim = resultItem.coordDim;\n\n            coordDim == null && (\n                resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero),\n                resultItem.coordDimIndex = 0,\n                resultItem.isExtraCoord = true\n            );\n\n            resultItem.name == null && (resultItem.name = genName(\n                resultItem.coordDim,\n                dataDimNameMap\n            ));\n\n            resultItem.type == null && guessOrdinal(data, resultDimIdx)\n                && (resultItem.type = 'ordinal');\n        }\n\n        return result;\n\n        function applyDim(resultItem, coordDim, coordDimIndex) {\n            if (OTHER_DIMS[coordDim]) {\n                resultItem.otherDims[coordDim] = coordDimIndex;\n            }\n            else {\n                resultItem.coordDim = coordDim;\n                resultItem.coordDimIndex = coordDimIndex;\n                coordDimNameMap.set(coordDim, true);\n            }\n        }\n\n        function genName(name, map, fromZero) {\n            if (fromZero || map.get(name) != null) {\n                var i = 0;\n                while (map.get(name + i) != null) {\n                    i++;\n                }\n                name += i;\n            }\n            map.set(name, true);\n            return name;\n        }\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            // Consider usage convenience, '1', '2' will be treated as \"number\".\n            if (value != null && isFinite(value)) {\n                return false;\n            }\n            else if (isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n\n\n/***/ }),\n/* 219 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Symbol factory\n\n\n    var graphic = __webpack_require__(192);\n    var BoundingRect = __webpack_require__(200);\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME  onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            // TODO Support image object, DynamicImage.\n\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n\n\n/***/ }),\n/* 220 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// TODO Parse shadow style\n// TODO Only shallow path support\n\n    var zrUtil = __webpack_require__(190);\n\n    module.exports = function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n               properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes, includes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if ((excludes && zrUtil.indexOf(excludes, propName) >= 0)\n                    || (includes && zrUtil.indexOf(includes, propName) < 0)\n                ) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n\n\n/***/ }),\n/* 221 */,\n/* 222 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\n\n    var numberUtil = __webpack_require__(193);\n    var formatUtil = __webpack_require__(197);\n    var Scale = __webpack_require__(213);\n    var helper = __webpack_require__(238);\n\n    var roundNumber = numberUtil.round;\n\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n\n        type: 'interval',\n\n        _interval: 0,\n\n        _intervalPrecision: 2,\n\n        setExtent: function (start, end) {\n            var thisExtent = this._extent;\n            //start,end may be a Number like '25',so...\n            if (!isNaN(start)) {\n                thisExtent[0] = parseFloat(start);\n            }\n            if (!isNaN(end)) {\n                thisExtent[1] = parseFloat(end);\n            }\n        },\n\n        unionExtent: function (other) {\n            var extent = this._extent;\n            other[0] < extent[0] && (extent[0] = other[0]);\n            other[1] > extent[1] && (extent[1] = other[1]);\n\n            // unionExtent may called by it's sub classes\n            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n        },\n        /**\n         * Get interval\n         */\n        getInterval: function () {\n            return this._interval;\n        },\n\n        /**\n         * Set interval\n         */\n        setInterval: function (interval) {\n            this._interval = interval;\n            // Dropped auto calculated niceExtent and use user setted extent\n            // We assume user wan't to set both interval, min, max to get a better result\n            this._niceExtent = this._extent.slice();\n\n            this._intervalPrecision = helper.getIntervalPrecision(interval);\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            return helper.intervalScaleGetTicks(\n                this._interval, this._extent, this._niceExtent, this._intervalPrecision\n            );\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getTicksLabels: function () {\n            var labels = [];\n            var ticks = this.getTicks();\n            for (var i = 0; i < ticks.length; i++) {\n                labels.push(this.getLabel(ticks[i]));\n            }\n            return labels;\n        },\n\n        /**\n         * @param {number} data\n         * @param {Object} [opt]\n         * @param {number|string} [opt.precision] If 'auto', use nice presision.\n         * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n         * @return {string}\n         */\n        getLabel: function (data, opt) {\n            if (data == null) {\n                return '';\n            }\n\n            var precision = opt && opt.precision;\n\n            if (precision == null) {\n                precision = numberUtil.getPrecisionSafe(data) || 0;\n            }\n            else if (precision === 'auto') {\n                // Should be more precise then tick.\n                precision = this._intervalPrecision;\n            }\n\n            // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n            // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n            data = roundNumber(data, precision, true);\n\n            return formatUtil.addCommas(data);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         *\n         * @param {number} [splitNumber = 5] Desired number of ticks\n         * @param {number} [minInterval]\n         */\n        niceTicks: function (splitNumber, minInterval) {\n            splitNumber = splitNumber || 5;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (!isFinite(span)) {\n                return;\n            }\n            // User may set axis min 0 and data are all negative\n            // FIXME If it needs to reverse ?\n            if (span < 0) {\n                span = -span;\n                extent.reverse();\n            }\n\n            var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval);\n\n            this._intervalPrecision = result.intervalPrecision;\n            this._interval = result.interval;\n            this._niceExtent = result.niceTickExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {Object} opt\n         * @param {number} [opt.splitNumber = 5] Given approx tick number\n         * @param {boolean} [opt.fixMin=false]\n         * @param {boolean} [opt.fixMax=false]\n         * @param {boolean} [opt.minInterval=false]\n         */\n        niceExtent: function (opt) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                if (extent[0] !== 0) {\n                    // Expand extent\n                    var expandSize = extent[0];\n                    // In the fowllowing case\n                    //      Axis has been fixed max 100\n                    //      Plus data are all 100 and axis extent are [100, 100].\n                    // Extend to the both side will cause expanded max is larger than fixed max.\n                    // So only expand to the smaller side.\n                    if (!opt.fixMax) {\n                        extent[1] += expandSize / 2;\n                        extent[0] -= expandSize / 2;\n                    }\n                    else {\n                        extent[0] -= expandSize / 2;\n                    }\n                }\n                else {\n                    extent[1] = 1;\n                }\n            }\n            var span = extent[1] - extent[0];\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (!isFinite(span)) {\n                extent[0] = 0;\n                extent[1] = 1;\n            }\n\n            this.niceTicks(opt.splitNumber, opt.minInterval);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!opt.fixMin) {\n                extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n            }\n            if (!opt.fixMax) {\n                extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n            }\n        }\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n\n    module.exports = IntervalScale;\n\n\n\n/***/ }),\n/* 223 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var Style = __webpack_require__(246);\n\n    var Element = __webpack_require__(239);\n    var RectText = __webpack_require__(264);\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable Painter \n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * true\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * zlevelcanvas\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * \n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * \n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         *  x, y \n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         *  x, y \n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * \n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * \n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO,  bind \n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n/***/ }),\n/* 224 */\n/***/ (function(module, exports) {\n\n\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n\n/***/ }),\n/* 225 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var clazz = __webpack_require__(201);\n\n    var parseClassType = clazz.parseClassType;\n\n    var base = 0;\n\n    var componentUtil = {};\n\n    var DELIMITER = '_';\n\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [(type || ''), base++, Math.random()].join(DELIMITER);\n    };\n\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n\n        var subTypeDefaulters = {};\n\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n\n        return entity;\n    };\n\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(\n                    currVertex.successor,\n                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n                );\n            }\n\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n\n            zrUtil.each(fullNameList, function (name) {\n\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n\n            return {graph: graph, noEntryList: noEntryList};\n        }\n\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {predecessor: [], successor: []};\n            }\n            return graph[name];\n        }\n\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n\n    module.exports = componentUtil;\n\n\n/***/ }),\n/* 226 */\n/***/ (function(module, exports) {\n\n// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n/***/ }),\n/* 227 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var numberUtil = __webpack_require__(193);\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = __webpack_require__(190);\n    var axisHelper = __webpack_require__(205);\n\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n\n    var normalizedExtent = [0, 1];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [0, 0];\n\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._labelInterval;\n    };\n\n    Axis.prototype = {\n\n        constructor: Axis,\n\n        /**\n         * If axis extent contain given coord\n         * @param {number} coord\n         * @return {boolean}\n         */\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n\n        /**\n         * If axis extent contain given data\n         * @param {number} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n\n        /**\n         * Get coord extent.\n         * @return {Array.<number>}\n         */\n        getExtent: function () {\n            return this._extent.slice();\n        },\n\n        /**\n         * Get precision used for formatting\n         * @param {Array.<number>} [dataExtent]\n         * @return {number}\n         */\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(\n                dataExtent || this.scale.getExtent(),\n                this._extent\n            );\n        },\n\n        /**\n         * Set coord extent\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n\n        /**\n         * Convert data to coord. Data is the rank if it has a ordinal scale\n         * @param {number} data\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n\n        /**\n         * Convert coord to data. Data is the rank if it has a ordinal scale\n         * @param {number} coord\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\n            return this.scale.scale(t);\n        },\n\n        /**\n         * Convert pixel point to data in axis\n         * @param {Array.<number>} point\n         * @param  {boolean} clamp\n         * @return {number} data\n         */\n        pointToData: function (point, clamp) {\n            // Should be implemented in derived class if necessary.\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            }\n            else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n\n        /**\n         * Coords of labels are on the ticks or on the middle of bands\n         * @return {Array.<number>}\n         */\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n\n        /**\n         * Get bands.\n         *\n         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n         * |---1---|---2---|---3---|---4---|.\n         *\n         * @return {Array}\n         */\n         // FIXME Situation when labels is on ticks\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n\n        /**\n         * Get width of band\n         * @return {number}\n         */\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n            return Math.abs(size) / len;\n        },\n\n        /**\n         * Get interval of the axis label.\n         * @return {number}\n         */\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                var axisModel = this.model;\n                var labelModel = axisModel.getModel('axisLabel');\n                var interval = labelModel.get('interval');\n                if (!(this.type === 'category' && interval === 'auto')) {\n                    labelInterval = interval === 'auto' ? 0 : interval;\n                }\n                else if (this.isHorizontal){\n                    labelInterval = axisHelper.getAxisLabelInterval(\n                        zrUtil.map(this.scale.getTicks(), this.dataToCoord, this),\n                        axisModel.getFormattedLabels(),\n                        labelModel.getModel('textStyle').getFont(),\n                        this.isHorizontal()\n                    );\n                }\n                this._labelInterval = labelInterval;\n            }\n            return labelInterval;\n        }\n\n    };\n\n    module.exports = Axis;\n\n\n/***/ }),\n/* 228 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var List = __webpack_require__(211);\n    var completeDimensions = __webpack_require__(218);\n    var zrUtil = __webpack_require__(190);\n    var modelUtil = __webpack_require__(194);\n    var CoordinateSystem = __webpack_require__(216);\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null\n            && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        var completeDimOpt = {\n            encodeDef: seriesModel.get('encode'),\n            dimsDef: seriesModel.get('dimensions')\n        };\n\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = (registeredCoordSys && (\n                registeredCoordSys.getDimensionsInfo\n                    ? registeredCoordSys.getDimensionsInfo()\n                    : registeredCoordSys.dimensions.slice()\n            )) || ['x', 'y'];\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n        }\n\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n        var list = new List(dimensions, seriesModel);\n\n        var nameList = createNameList(axesInfo, data);\n\n        var categories = {};\n        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex\n                    ? dataIndex\n                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            }\n            : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName]\n                            || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n\n        return list;\n    }\n\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category'\n            ? 'ordinal'\n            : axisType === 'time'\n            ? 'time'\n            : 'float';\n    }\n\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n\n        cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) {\n\n            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n                return ecModel.queryComponents({\n                    mainType: name,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n            });\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (__DEV__) {\n                if (!xAxisModel) {\n                    throw new Error('xAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('xAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n                if (!yAxisModel) {\n                    throw new Error('yAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('yAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n\n            var xAxisType = xAxisModel.get('type');\n            var yAxisType = yAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'x',\n                    type: getDimTypeByAxis(xAxisType),\n                    stackable: isStackable(xAxisType)\n                },\n                {\n                    name: 'y',\n                    // If two category axes\n                    type: getDimTypeByAxis(yAxisType),\n                    stackable: isStackable(yAxisType)\n                }\n            ];\n\n            var isXAxisCateogry = xAxisType === 'category';\n            var isYAxisCategory = yAxisType === 'category';\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isXAxisCateogry) {\n                categoryAxesModels.x = xAxisModel;\n            }\n            if (isYAxisCategory) {\n                categoryAxesModels.y = yAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        singleAxis: function (data, seriesModel, ecModel, completeDimOpt) {\n\n            var singleAxisModel = ecModel.queryComponents({\n                mainType: 'singleAxis',\n                index: seriesModel.get('singleAxisIndex'),\n                id: seriesModel.get('singleAxisId')\n            })[0];\n\n            if (__DEV__) {\n                if (!singleAxisModel) {\n                    throw new Error('singleAxis should be specified.');\n                }\n            }\n\n            var singleAxisType = singleAxisModel.get('type');\n            var isCategory = singleAxisType === 'category';\n\n            var dimensions = [{\n                name: 'single',\n                type: getDimTypeByAxis(singleAxisType),\n                stackable: isStackable(singleAxisType)\n            }];\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isCategory) {\n                categoryAxesModels.single = singleAxisModel;\n            }\n\n            return {\n                dimensions: dimensions,\n                categoryIndex: isCategory ? 0 : -1,\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        polar: function (data, seriesModel, ecModel, completeDimOpt) {\n            var polarModel = ecModel.queryComponents({\n                mainType: 'polar',\n                index: seriesModel.get('polarIndex'),\n                id: seriesModel.get('polarId')\n            })[0];\n\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n            if (__DEV__) {\n                if (!angleAxisModel) {\n                    throw new Error('angleAxis option not found');\n                }\n                if (!radiusAxisModel) {\n                    throw new Error('radiusAxis option not found');\n                }\n            }\n\n            var radiusAxisType = radiusAxisModel.get('type');\n            var angleAxisType = angleAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'radius',\n                    type: getDimTypeByAxis(radiusAxisType),\n                    stackable: isStackable(radiusAxisType)\n                },\n                {\n                    name: 'angle',\n                    type: getDimTypeByAxis(angleAxisType),\n                    stackable: isStackable(angleAxisType)\n                }\n            ];\n            var isAngleAxisCateogry = angleAxisType === 'category';\n            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isRadiusAxisCateogry) {\n                categoryAxesModels.radius = radiusAxisModel;\n            }\n            if (isAngleAxisCateogry) {\n                categoryAxesModels.angle = angleAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        geo: function (data, seriesModel, ecModel, completeDimOpt) {\n            // TODO Region\n            // \n            return {\n                dimensions: completeDimensions([\n                    {name: 'lng'},\n                    {name: 'lat'}\n                ], data, completeDimOpt)\n            };\n        }\n    };\n\n    function createNameList(result, data) {\n        var nameList = [];\n\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                }\n                else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n\n        return nameList;\n    }\n\n    module.exports = createListFromArray;\n\n\n\n/***/ }),\n/* 229 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var formatUtil = __webpack_require__(197);\n    var graphic = __webpack_require__(192);\n    var Model = __webpack_require__(199);\n    var numberUtil = __webpack_require__(193);\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = __webpack_require__(195);\n    var matrix = __webpack_require__(204);\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n\n    var PI = Math.PI;\n\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = {\n            componentType: axisModel.mainType\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     * @param {number} [opt.nameTruncateMaxWidth]\n     */\n    var AxisBuilder = function (axisModel, opt) {\n\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n\n        // Default value\n        zrUtil.defaults(\n            opt,\n            {\n                labelOffset: 0,\n                nameDirection: 1,\n                tickDirection: 1,\n                labelDirection: 1,\n                silent: true\n            }\n        );\n\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n            position: opt.position.slice(),\n            rotation: opt.rotation\n        });\n\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n\n        this._dumbGroup = dumbGroup;\n    };\n\n    AxisBuilder.prototype = {\n\n        constructor: AxisBuilder,\n\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n\n        add: function (name) {\n            builders[name].call(this);\n        },\n\n        getGroup: function () {\n            return this.group;\n        }\n\n    };\n\n    var builders = {\n\n        /**\n         * @private\n         */\n        axisLine: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisLine.show')) {\n                return;\n            }\n\n            var extent = this.axisModel.axis.getExtent();\n\n            var matrix = this._transform;\n            var pt1 = [extent[0], 0];\n            var pt2 = [extent[1], 0];\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n\n            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                // Id for animation\n                anid: 'line',\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.extend(\n                    {lineCap: 'round'},\n                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n                ),\n                strokeContainThreshold: opt.strokeContainThreshold || 5,\n                silent: true,\n                z2: 1\n            })));\n        },\n\n        /**\n         * @private\n         */\n        axisTick: function () {\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n\n            if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n                return;\n            }\n\n            var tickModel = axisModel.getModel('axisTick');\n            var opt = this.opt;\n\n            var lineStyleModel = tickModel.getModel('lineStyle');\n            var tickLen = tickModel.get('length');\n\n            var tickInterval = getInterval(tickModel, opt.labelInterval);\n            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n            var ticks = axis.scale.getTicks();\n\n            var pt1 = [];\n            var pt2 = [];\n            var matrix = this._transform;\n\n            for (var i = 0; i < ticksCoords.length; i++) {\n                // Only ordinal scale support tick interval\n                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                     continue;\n                }\n\n                var tickCoord = ticksCoords[i];\n\n                pt1[0] = tickCoord;\n                pt1[1] = 0;\n                pt2[0] = tickCoord;\n                pt2[1] = opt.tickDirection * tickLen;\n\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                // Tick line, Not use group transform to have better line draw\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                    // Id for animation\n                    anid: 'tick_' + ticks[i],\n\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.defaults(\n                        lineStyleModel.getLineStyle(),\n                        {\n                            stroke: axisModel.get('axisLine.lineStyle.color')\n                        }\n                    ),\n                    z2: 2,\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @private\n         */\n        axisLabel: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n            if (!show || axis.scale.isBlank()) {\n                return;\n            }\n\n            var labelModel = axisModel.getModel('axisLabel');\n            var textStyleModel = labelModel.getModel('textStyle');\n            var labelMargin = labelModel.get('margin');\n            var ticks = axis.scale.getTicks();\n            var labels = axisModel.getFormattedLabels();\n\n            // Special label rotate.\n            var labelRotation = (\n                retrieve(opt.labelRotate, labelModel.get('rotate')) || 0\n            ) * PI / 180;\n\n            var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n            var categoryData = axisModel.get('data');\n\n            var textEls = [];\n            var silent = isSilent(axisModel);\n            var triggerEvent = axisModel.get('triggerEvent');\n\n            zrUtil.each(ticks, function (tickVal, index) {\n                if (ifIgnoreOnTick(axis, index, opt.labelInterval)) {\n                     return;\n                }\n\n                var itemTextStyleModel = textStyleModel;\n                if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n                    itemTextStyleModel = new Model(\n                        categoryData[tickVal].textStyle, textStyleModel, axisModel.ecModel\n                    );\n                }\n                var textColor = itemTextStyleModel.getTextColor()\n                    || axisModel.get('axisLine.lineStyle.color');\n\n                var tickCoord = axis.dataToCoord(tickVal);\n                var pos = [\n                    tickCoord,\n                    opt.labelOffset + opt.labelDirection * labelMargin\n                ];\n                var labelStr = axis.scale.getLabel(tickVal);\n\n                var textEl = new graphic.Text({\n\n                    // Id for animation\n                    anid: 'label_' + tickVal,\n\n                    style: {\n                        text: labels[index],\n                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.textVerticalAlign,\n                        textFont: itemTextStyleModel.getFont(),\n                        fill: typeof textColor === 'function'\n                            ? textColor(\n                                // (1) In category axis with data zoom, tick is not the original\n                                // index of axis.data. So tick should not be exposed to user\n                                // in category axis.\n                                // (2) Compatible with previous version, which always returns labelStr.\n                                // But in interval scale labelStr is like '223,445', which maked\n                                // user repalce ','. So we modify it to return original val but remain\n                                // it as 'string' to avoid error in replacing.\n                                axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal,\n                                index\n                            )\n                            : textColor\n                    },\n                    position: pos,\n                    rotation: labelLayout.rotation,\n                    silent: silent,\n                    z2: 10\n                });\n\n                // Pack data for mouse event\n                if (triggerEvent) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisLabel';\n                    textEl.eventData.value = labelStr;\n                }\n\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n\n                textEls.push(textEl);\n                this.group.add(textEl);\n\n                textEl.decomposeTransform();\n\n            }, this);\n\n            fixMinMaxLabelShow(axisModel, textEls);\n        },\n\n        /**\n         * @private\n         */\n        axisName: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var name = retrieve(opt.axisName, axisModel.get('name'));\n\n            if (!name) {\n                return;\n            }\n\n            var nameLocation = axisModel.get('nameLocation');\n            var nameDirection = opt.nameDirection;\n            var textStyleModel = axisModel.getModel('nameTextStyle');\n            var gap = axisModel.get('nameGap') || 0;\n\n            var extent = this.axisModel.axis.getExtent();\n            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n            var pos = [\n                nameLocation === 'start'\n                    ? extent[0] - gapSignal * gap\n                    : nameLocation === 'end'\n                    ? extent[1] + gapSignal * gap\n                    : (extent[0] + extent[1]) / 2, // 'middle'\n                // Reuse labelOffset.\n                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n            ];\n\n            var labelLayout;\n\n            var nameRotation = axisModel.get('nameRotate');\n            if (nameRotation != null) {\n                nameRotation = nameRotation * PI / 180; // To radian.\n            }\n\n            var axisNameAvailableWidth;\n\n            if (nameLocation === 'middle') {\n                labelLayout = innerTextLayout(\n                    opt.rotation,\n                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                    nameDirection\n                );\n            }\n            else {\n                labelLayout = endTextLayout(\n                    opt, nameLocation, nameRotation || 0, extent\n                );\n\n                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                if (axisNameAvailableWidth != null) {\n                    axisNameAvailableWidth = Math.abs(\n                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                    );\n                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                }\n            }\n\n            var textFont = textStyleModel.getFont();\n\n            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n            var ellipsis = truncateOpt.ellipsis;\n            var maxWidth = retrieve(\n                opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth\n            );\n            var truncatedText = (ellipsis != null && maxWidth != null)\n                ? formatUtil.truncateText(\n                    name, maxWidth, textFont, ellipsis,\n                    {minChar: 2, placeholder: truncateOpt.placeholder}\n                )\n                : name;\n\n            var tooltipOpt = axisModel.get('tooltip', true);\n\n            var mainType = axisModel.mainType;\n            var formatterParams = {\n                componentType: mainType,\n                name: name,\n                $vars: ['name']\n            };\n            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n            var textEl = new graphic.Text({\n\n                // Id for animation\n                anid: 'name',\n\n                __fullText: name,\n                __truncatedText: truncatedText,\n\n                style: {\n                    text: truncatedText,\n                    textFont: textFont,\n                    fill: textStyleModel.getTextColor()\n                        || axisModel.get('axisLine.lineStyle.color'),\n                    textAlign: labelLayout.textAlign,\n                    textVerticalAlign: labelLayout.textVerticalAlign\n                },\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: isSilent(axisModel),\n                z2: 1,\n                tooltip: (tooltipOpt && tooltipOpt.show)\n                    ? zrUtil.extend({\n                        content: name,\n                        formatter: function () {\n                            return name;\n                        },\n                        formatterParams: formatterParams\n                    }, tooltipOpt)\n                    : null\n            });\n\n            if (axisModel.get('triggerEvent')) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisName';\n                textEl.eventData.name = name;\n            }\n\n            // FIXME\n            this._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            this.group.add(textEl);\n\n            textEl.decomposeTransform();\n        }\n\n    };\n\n    /**\n     * @public\n     * @static\n     * @param {Object} opt\n     * @param {number} axisRotation in radian\n     * @param {number} textRotation in radian\n     * @param {number} direction\n     * @return {Object} {\n     *  rotation, // according to axis\n     *  textAlign,\n     *  textVerticalAlign\n     * }\n     */\n    var innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - axisRotation);\n        var textAlign;\n        var textVerticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            }\n            else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    };\n\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var textVerticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = (textPosition === 'start' && !inverse)\n            || (textPosition !== 'start' && inverse);\n\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            textVerticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            textVerticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            }\n            else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    }\n\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent')\n            // Consider mouse cursor, add these restrictions.\n            || !(\n                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n            );\n    }\n\n    function fixMinMaxLabelShow(axisModel, textEls) {\n        // If min or max are user set, we need to check\n        // If the tick on min(max) are overlap on their neighbour tick\n        // If they are overlapped, we need to hide the min(max) tick label\n        var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n        var firstLabel = textEls[0];\n        var nextLabel = textEls[1];\n        var lastLabel = textEls[textEls.length - 1];\n        var prevLabel = textEls[textEls.length - 2];\n\n        if (showMinLabel === false) {\n            firstLabel.ignore = true;\n        }\n        else if (axisModel.getMin() != null && isTwoLabelOverlapped(firstLabel, nextLabel)) {\n            showMinLabel ? (nextLabel.ignore = true) : (firstLabel.ignore = true);\n        }\n\n        if (showMaxLabel === false) {\n            lastLabel.ignore = true;\n        }\n        else if (axisModel.getMax() != null && isTwoLabelOverlapped(prevLabel, lastLabel)) {\n            showMaxLabel ? (prevLabel.ignore = true) : (lastLabel.ignore = true);\n        }\n    }\n\n    function isTwoLabelOverlapped(current, next, labelLayout) {\n        // current and next has the same rotation.\n        var firstRect = current && current.getBoundingRect().clone();\n        var nextRect = next && next.getBoundingRect().clone();\n\n        if (!firstRect || !nextRect) {\n            return;\n        }\n\n        // When checking intersect of two rotated labels, we use mRotationBack\n        // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n        var mRotationBack = matrix.identity([]);\n        matrix.rotate(mRotationBack, mRotationBack, -current.rotation);\n\n        firstRect.applyTransform(matrix.mul([], mRotationBack, current.getLocalTransform()));\n        nextRect.applyTransform(matrix.mul([], mRotationBack, next.getLocalTransform()));\n\n        return firstRect.intersect(nextRect);\n    }\n\n\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n        var rawTick;\n        var scale = axis.scale;\n        return scale.type === 'ordinal'\n            && (\n                typeof interval === 'function'\n                    ? (\n                        rawTick = scale.getTicks()[i],\n                        !interval(rawTick, scale.getLabel(rawTick))\n                    )\n                    : i % (interval + 1)\n            );\n    };\n\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n        var interval = model.get('interval');\n        if (interval == null || interval == 'auto') {\n            interval = labelInterval;\n        }\n        return interval;\n    };\n\n    module.exports = AxisBuilder;\n\n\n\n/***/ }),\n/* 230 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var axisHelper = __webpack_require__(205);\n\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        }\n        else {\n            return obj + '';\n        }\n    }\n\n    module.exports = {\n\n        /**\n         * Format labels\n         * @return {Array.<string>}\n         */\n        getFormattedLabels: function () {\n            return axisHelper.getFormattedLabels(\n                this.axis,\n                this.get('axisLabel.formatter')\n            );\n        },\n\n        /**\n         * Get categories\n         */\n        getCategories: function () {\n            return this.get('type') === 'category'\n                && zrUtil.map(this.get('data'), getName);\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n         */\n        getMin: function (origin) {\n            var option = this.option;\n            var min = (!origin && option.rangeStart != null)\n                ? option.rangeStart : option.min;\n\n            if (this.axis && min != null && min !== 'dataMin' && !zrUtil.eqNaN(min)) {\n                min = this.axis.scale.parse(min);\n            }\n            return min;\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n         */\n        getMax: function (origin) {\n            var option = this.option;\n            var max = (!origin && option.rangeEnd != null)\n                ? option.rangeEnd : option.max;\n\n            if (this.axis && max != null && max !== 'dataMax' && !zrUtil.eqNaN(max)) {\n                max = this.axis.scale.parse(max);\n            }\n            return max;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        getNeedCrossZero: function () {\n            var option = this.option;\n            return (option.rangeStart != null || option.rangeEnd != null)\n                ? false : !option.scale;\n        },\n\n        /**\n         * Should be implemented by each axis model if necessary.\n         * @return {module:echarts/model/Component} coordinate system model\n         */\n        getCoordSysModel: zrUtil.noop,\n\n        /**\n         * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n         * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n         */\n        setRange: function (rangeStart, rangeEnd) {\n            this.option.rangeStart = rangeStart;\n            this.option.rangeEnd = rangeEnd;\n        },\n\n        /**\n         * Reset range\n         */\n        resetRange: function () {\n            // rangeStart and rangeEnd is readonly.\n            this.option.rangeStart = this.option.rangeEnd = null;\n        }\n    };\n\n\n/***/ }),\n/* 231 */\n/***/ (function(module, exports) {\n\n\n\n    var lib = {};\n\n    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n    var RATE = '\\0__throttleRate';\n    var THROTTLE_TYPE = '\\0__throttleType';\n\n    /**\n     * @public\n     * @param {(Function)} fn\n     * @param {number} [delay=0] Unit: ms.\n     * @param {boolean} [debounce=false]\n     *        true: If call interval less than `delay`, only the last call works.\n     *        false: If call interval less than `delay, call works on fixed rate.\n     * @return {(Function)} throttled fn.\n     */\n    lib.throttle = function (fn, delay, debounce) {\n\n        var currCall;\n        var lastCall = 0;\n        var lastExec = 0;\n        var timer = null;\n        var diff;\n        var scope;\n        var args;\n        var debounceNextCall;\n\n        delay = delay || 0;\n\n        function exec() {\n            lastExec = (new Date()).getTime();\n            timer = null;\n            fn.apply(scope, args || []);\n        }\n\n        var cb = function () {\n            currCall = (new Date()).getTime();\n            scope = this;\n            args = arguments;\n            var thisDelay = debounceNextCall || delay;\n            var thisDebounce = debounceNextCall || debounce;\n            debounceNextCall = null;\n            diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;\n\n            clearTimeout(timer);\n\n            if (thisDebounce) {\n                timer = setTimeout(exec, thisDelay);\n            }\n            else {\n                if (diff >= 0) {\n                    exec();\n                }\n                else {\n                    timer = setTimeout(exec, -diff);\n                }\n            }\n\n            lastCall = currCall;\n        };\n\n        /**\n         * Clear throttle.\n         * @public\n         */\n        cb.clear = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n\n        /**\n         * Enable debounce once.\n         */\n        cb.debounceNextCall = function (debounceDelay) {\n            debounceNextCall = debounceDelay;\n        };\n\n        return cb;\n    };\n\n    /**\n     * Create throttle method or update throttle rate.\n     *\n     * @example\n     * ComponentView.prototype.render = function () {\n     *     ...\n     *     throttle.createOrUpdate(\n     *         this,\n     *         '_dispatchAction',\n     *         this.model.get('throttle'),\n     *         'fixRate'\n     *     );\n     * };\n     * ComponentView.prototype.remove = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     * ComponentView.prototype.dispose = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     * @param {number} [rate]\n     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n     * @return {Function} throttled function.\n     */\n    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n        var fn = obj[fnAttr];\n\n        if (!fn) {\n            return;\n        }\n\n        var originFn = fn[ORIGIN_METHOD] || fn;\n        var lastThrottleType = fn[THROTTLE_TYPE];\n        var lastRate = fn[RATE];\n\n        if (lastRate !== rate || lastThrottleType !== throttleType) {\n            if (rate == null || !throttleType) {\n                return (obj[fnAttr] = originFn);\n            }\n\n            fn = obj[fnAttr] = lib.throttle(\n                originFn, rate, throttleType === 'debounce'\n            );\n            fn[ORIGIN_METHOD] = originFn;\n            fn[THROTTLE_TYPE] = throttleType;\n            fn[RATE] = rate;\n        }\n\n        return fn;\n    };\n\n    /**\n     * Clear throttle. Example see throttle.createOrUpdate.\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     */\n    lib.clear = function (obj, fnAttr) {\n        var fn = obj[fnAttr];\n        if (fn && fn[ORIGIN_METHOD]) {\n            obj[fnAttr] = fn[ORIGIN_METHOD];\n        }\n    };\n\n    module.exports = lib;\n\n\n\n/***/ }),\n/* 232 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var Group = __webpack_require__(215);\n    var componentUtil = __webpack_require__(225);\n    var clazzUtil = __webpack_require__(201);\n    var modelUtil = __webpack_require__(194);\n    var zrUtil = __webpack_require__(190);\n\n    function Chart() {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n\n    Chart.prototype = {\n\n        type: 'chart',\n\n        /**\n         * Init the chart\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        init: function (ecModel, api) {},\n\n        /**\n         * Render the chart\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        render: function (seriesModel, ecModel, api, payload) {},\n\n        /**\n         * Highlight series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n\n        /**\n         * Downplay series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n\n        /**\n         * Remove self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n\n        /**\n         * Dispose self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        dispose: function () {}\n\n        /**\n         * The view contains the given point.\n         * @interface\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        // containPoint: function () {}\n\n    };\n\n    var chartProto = Chart.prototype;\n    chartProto.updateView\n        = chartProto.updateLayout\n        = chartProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            this.render(seriesModel, ecModel, api, payload);\n        };\n\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n        if (dataIndex != null) {\n            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n                elSetState(data.getItemGraphicEl(dataIdx), state);\n            });\n        }\n        else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\n    module.exports = Chart;\n\n\n/***/ }),\n/* 233 */,\n/* 234 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n        var config = __webpack_require__(214);\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n/***/ }),\n/* 235 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = __webpack_require__(223);\n    var BoundingRect = __webpack_require__(200);\n    var zrUtil = __webpack_require__(190);\n\n    var LRU = __webpack_require__(243);\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // \n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // \n                if (!image.width || !image.height) {\n                    return;\n                }\n                var width = style.width;\n                var height = style.height;\n                var aspect = image.width / image.height;\n                if (width == null && height != null) {\n                    // Keep image/height ratio\n                    width = height * aspect;\n                }\n                else if (height == null && width != null) {\n                    height = width / aspect;\n                }\n                else if (width == null && height == null) {\n                    width = image.width;\n                    height = image.height;\n                }\n\n                // transform\n                this.setTransform(ctx);\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n/***/ }),\n/* 236 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = __webpack_require__(204);\n    var vector = __webpack_require__(195);\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * \n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * \n     * , position, rotation, scaletransformtransform\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // \n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // \n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        return Transformable.getLocalTransform(this, m);\n    };\n\n    /**\n     * transformcontext\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    };\n\n    var tmpTransform = [];\n\n    /**\n     * `transform``position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     *  shape \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    /**\n     * @static\n     * @param {Object} target\n     * @param {Array.<number>} target.origin\n     * @param {number} target.rotation\n     * @param {Array.<number>} target.position\n     * @param {Array.<number>} [m]\n     */\n    Transformable.getLocalTransform = function (target, m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = target.origin;\n        var scale = target.scale || [1, 1];\n        var rotation = target.rotation || 0;\n        var position = target.position || [0, 0];\n\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n\n    module.exports = Transformable;\n\n\n\n/***/ }),\n/* 237 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var classUtil = __webpack_require__(201);\n    var set = classUtil.set;\n    var get = classUtil.get;\n\n    module.exports = {\n        clearColorPalette: function () {\n            set(this, 'colorIdx', 0);\n            set(this, 'colorNameMap', {});\n        },\n\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = get(scope, 'colorIdx') || 0;\n            var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {});\n            // Use `hasOwnProperty` to avoid conflict with Object.prototype.\n            if (colorNameMap.hasOwnProperty(name)) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n\n            return color;\n        }\n    };\n\n\n/***/ }),\n/* 238 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * For testable.\n */\n\n\n    var numberUtil = __webpack_require__(193);\n\n    var roundNumber = numberUtil.round;\n\n    var helper = {};\n\n    /**\n     * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n     *                                Should be extent[0] < extent[1].\n     * @param {number} splitNumber splitNumber should be >= 1.\n     * @param {number} [minInterval]\n     * @return {Object} {interval, intervalPrecision, niceTickExtent}\n     */\n    helper.intervalScaleNiceTicks = function (extent, splitNumber, minInterval) {\n        var result = {};\n        var span = extent[1] - extent[0];\n\n        var interval = result.interval = numberUtil.nice(span / splitNumber, true);\n        if (minInterval != null && interval < minInterval) {\n            interval = result.interval = minInterval;\n        }\n        // Tow more digital for tick.\n        var precision = result.intervalPrecision = helper.getIntervalPrecision(interval);\n        // Niced extent inside original extent\n        var niceTickExtent = result.niceTickExtent = [\n            roundNumber(Math.ceil(extent[0] / interval) * interval, precision),\n            roundNumber(Math.floor(extent[1] / interval) * interval, precision)\n        ];\n\n        helper.fixExtent(niceTickExtent, extent);\n\n        return result;\n    };\n\n    /**\n     * @param {number} interval\n     * @return {number} interval precision\n     */\n    helper.getIntervalPrecision = function (interval) {\n        // Tow more digital for tick.\n        return numberUtil.getPrecisionSafe(interval) + 2;\n    };\n\n    function clamp(niceTickExtent, idx, extent) {\n        niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n    }\n\n    // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\n    helper.fixExtent = function (niceTickExtent, extent) {\n        !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n        !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n        clamp(niceTickExtent, 0, extent);\n        clamp(niceTickExtent, 1, extent);\n        if (niceTickExtent[0] > niceTickExtent[1]) {\n            niceTickExtent[0] = niceTickExtent[1];\n        }\n    };\n\n    helper.intervalScaleGetTicks = function (interval, extent, niceTickExtent, intervalPrecision) {\n        var ticks = [];\n\n        // If interval is 0, return [];\n        if (!interval) {\n            return ticks;\n        }\n\n        // Consider this case: using dataZoom toolbox, zoom and zoom.\n        var safeLimit = 10000;\n\n        if (extent[0] < niceTickExtent[0]) {\n            ticks.push(extent[0]);\n        }\n        var tick = niceTickExtent[0];\n\n        while (tick <= niceTickExtent[1]) {\n            ticks.push(tick);\n            // Avoid rounding error\n            tick = roundNumber(tick + interval, intervalPrecision);\n            if (tick === ticks[ticks.length - 1]) {\n                // Consider out of safe float point, e.g.,\n                // -3711126.9907707 + 2e-10 === -3711126.9907707\n                break;\n            }\n            if (ticks.length > safeLimit) {\n                return [];\n            }\n        }\n        // Consider this case: the last item of ticks is smaller\n        // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n        if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {\n            ticks.push(extent[1]);\n        }\n\n        return ticks;\n    };\n\n    module.exports = helper;\n\n\n/***/ }),\n/* 239 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @module zrender/Element\n */\n\n\n    var guid = __webpack_require__(244);\n    var Eventful = __webpack_require__(210);\n    var Transformable = __webpack_require__(236);\n    var Animatable = __webpack_require__(310);\n    var zrUtil = __webpack_require__(190);\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * \n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * \n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender  element  zrender \n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * true\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * (shape) Group \n         * \n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n/***/ }),\n/* 240 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = __webpack_require__(289);\n    var color = __webpack_require__(208);\n    var util = __webpack_require__(190);\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = len && p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function getArrayDim(keyframes) {\n        var lastValue = keyframes[keyframes.length - 1].value;\n        return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * \n         * @param  {number} time ms\n         * @param  {Object} props key-value\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        pause: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].pause();\n            }\n            this._paused = true;\n        },\n\n        resume: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].resume();\n            }\n            this._paused = false;\n        },\n\n        isPaused: function () {\n            return !!this._paused;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * \n         * @param  {string|Function} easing\n         *         {@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * \n         * @param  {number} time ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n/***/ }),\n/* 241 */\n/***/ (function(module, exports) {\n\n\n\n    module.exports = (typeof window !== 'undefined' &&\n                ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window))\n                // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\n                || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))\n                || window.mozRequestAnimationFrame\n                || window.webkitRequestAnimationFrame)\n            )\n            || function (func) {\n                setTimeout(func, 16);\n            };\n\n\n\n/***/ }),\n/* 242 */\n/***/ (function(module, exports) {\n\n\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n/***/ }),\n/* 243 */\n/***/ (function(module, exports) {\n\n// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function () {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function (val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function (entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            entry.next = null;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function (entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function () {\n        return this._len;\n    };\n\n    /**\n     * Clear list\n     */\n    linkedListProto.clear = function () {\n        this.head = this.tail = null;\n        this._len = 0;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function (val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function (maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n\n        this._lastRemovedEntry = null;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     * @return {} Removed value\n     */\n    LRUProto.put = function (key, value) {\n        var list = this._list;\n        var map = this._map;\n        var removed = null;\n        if (map[key] == null) {\n            var len = list.len();\n            // Reuse last removed entry\n            var entry = this._lastRemovedEntry;\n\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n\n                removed = leastUsedEntry.value;\n                this._lastRemovedEntry = leastUsedEntry;\n            }\n\n            if (entry) {\n                entry.value = value;\n            }\n            else {\n                entry = new Entry(value);\n            }\n            entry.key = key;\n            list.insertEntry(entry);\n            map[key] = entry;\n        }\n\n        return removed;\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function (key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function () {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n/***/ }),\n/* 244 */\n/***/ (function(module, exports) {\n\n/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n/***/ }),\n/* 245 */\n/***/ (function(module, exports) {\n\n\n\n    var Pattern = function (image, repeat) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {image: ...}`, where this constructor will not be called.\n\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n        return ctx.createPattern(this.image, this.repeat || 'repeat');\n    };\n\n    module.exports = Pattern;\n\n\n/***/ }),\n/* 246 */\n/***/ (function(module, exports) {\n\n/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        var x = obj.x == null ? 0 : obj.x;\n        var x2 = obj.x2 == null ? 1 : obj.x2;\n        var y = obj.y == null ? 0 : obj.y;\n        var y2 = obj.y2 == null ? 0 : obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x == null ? 0.5 : obj.x;\n        var y = obj.y == null ? 0.5 : obj.y;\n        var r = obj.r == null ? 0.5 : obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * If not specified, use the boundingRect of a `displayable`.\n         * @type {Object}\n         */\n        textPositionRect: null,\n\n        /**\n         * [x, y]\n         * @type {Array.<number>}\n         */\n        textOffset: null,\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n/***/ }),\n/* 247 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var smoothSpline = __webpack_require__(300);\n    var smoothBezier = __webpack_require__(299);\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n/***/ }),\n/* 248 */,\n/* 249 */,\n/* 250 */,\n/* 251 */,\n/* 252 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    function defaultKeyGetter(item) {\n        return item;\n    }\n\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n\n    DataDiffer.prototype = {\n\n        constructor: DataDiffer,\n\n        /**\n         * Callback function when add a data\n         */\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n\n        /**\n         * Callback function when update a data\n         */\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n\n        /**\n         * Callback function when remove a data\n         */\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    }\n                    else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                }\n                else {\n                    this._remove && this._remove(i);\n                }\n            }\n\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    }\n                    else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            // Add prefix to avoid conflict with Object.prototype.\n            var key = '_ec_' + keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            }\n            else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n\n    module.exports = DataDiffer;\n\n\n/***/ }),\n/* 253 */,\n/* 254 */,\n/* 255 */,\n/* 256 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var Group = __webpack_require__(215);\n    var componentUtil = __webpack_require__(225);\n    var clazzUtil = __webpack_require__(201);\n\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n\n    Component.prototype = {\n\n        constructor: Component,\n\n        init: function (ecModel, api) {},\n\n        render: function (componentModel, ecModel, api, payload) {},\n\n        dispose: function () {}\n\n    };\n\n    var componentProto = Component.prototype;\n    componentProto.updateView\n        = componentProto.updateLayout\n        = componentProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            // Do nothing;\n        };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\n    module.exports = Component;\n\n\n/***/ }),\n/* 257 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = __webpack_require__(195);\n    var curve = __webpack_require__(207);\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * `min``max`\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points \n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * (p0, p1, p2, p3)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * (p0, p1, p2)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * `min``max`\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n/***/ }),\n/* 258 */,\n/* 259 */\n/***/ (function(module, exports) {\n\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n/***/ }),\n/* 260 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var curve = __webpack_require__(207);\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n/***/ }),\n/* 261 */\n/***/ (function(module, exports) {\n\n\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n/***/ }),\n/* 262 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var Gradient = __webpack_require__(224);\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'linear', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n/***/ }),\n/* 263 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = __webpack_require__(223);\n    var zrUtil = __webpack_require__(190);\n    var textContain = __webpack_require__(206);\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                // FIXME in text contain default is top\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    // Fill after stroke so the outline will not cover the main part.\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (!this._rect) {\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                if (style.hasStroke()) {\n                    var w = style.lineWidth;\n                    rect.x -= w / 2;\n                    rect.y -= w / 2;\n                    rect.width += w;\n                    rect.height += w;\n                }\n                this._rect = rect;\n            }\n\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n/***/ }),\n/* 264 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = __webpack_require__(206);\n    var BoundingRect = __webpack_require__(200);\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var textOffset = style.textOffset;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n            rect = style.textPositionRect || rect;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            if (textOffset) {\n                x += textOffset[0];\n                y += textOffset[1];\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                // Fill after stroke so the outline will not cover the main part.\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                textFill && ctx.fillText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n/***/ }),\n/* 265 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = __webpack_require__(244);\n    var env = __webpack_require__(198);\n    var zrUtil = __webpack_require__(190);\n\n    var Handler = __webpack_require__(284);\n    var Storage = __webpack_require__(287);\n    var Animation = __webpack_require__(288);\n    var HandlerProxy = __webpack_require__(295);\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: __webpack_require__(286)\n    };\n\n    var instances = {};    // ZRendermap\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.5.2';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        // TODO WebGL\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        //  storage.delFromStorage, \n        // FIXME ugly\n        var oldDelFromStorage = storage.delFromStorage;\n        var oldAddToStorage = storage.addToStorage;\n\n        storage.delFromStorage = function (el) {\n            oldDelFromStorage.call(storage, el);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToStorage = function (el) {\n            oldAddToStorage.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * \n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, dpr) {\n            return this.painter.pathToImage(e, dpr);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Find hovered element\n         * @param {number} x\n         * @param {number} y\n         * @return {Object} {target, topTarget}\n         */\n        findHover: function (x, y) {\n            return this.handler.findHover(x, y);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n/***/ }),\n/* 266 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var echartsAPIList = [\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed',\n        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',\n        'getViewOfComponentModel', 'getViewOfSeriesModel'\n    ];\n    // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js\n\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n\n    module.exports = ExtensionAPI;\n\n\n/***/ }),\n/* 267 */,\n/* 268 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var createListFromArray = __webpack_require__(228);\n    var symbolUtil = __webpack_require__(219);\n    var axisHelper = __webpack_require__(205);\n    var axisModelCommonMixin = __webpack_require__(230);\n    var Model = __webpack_require__(199);\n    var util = __webpack_require__(190);\n\n    module.exports = {\n        /**\n         * Create a muti dimension List structure from seriesModel.\n         * @param  {module:echarts/model/Model} seriesModel\n         * @return {module:echarts/data/List} list\n         */\n        createList: function (seriesModel) {\n            var data = seriesModel.get('data');\n            return createListFromArray(data, seriesModel, seriesModel.ecModel);\n        },\n\n        /**\n         * @see {module:echarts/data/helper/completeDimensions}\n         */\n        completeDimensions: __webpack_require__(218),\n\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @see http://echarts.baidu.com/option.html#series-scatter.symbol\n         * @param {string} symbolDesc\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: symbolUtil.createSymbol,\n\n        /**\n         * Create scale\n         * @param {Array.<number>} dataExtent\n         * @param {Object|module:echarts/Model} option\n         */\n        createScale: function (dataExtent, option) {\n            var axisModel = option;\n            if (!(option instanceof Model)) {\n                axisModel = new Model(option);\n                util.mixin(axisModel, axisModelCommonMixin);\n            }\n\n            var scale = axisHelper.createScaleByModel(axisModel);\n            scale.setExtent(dataExtent[0], dataExtent[1]);\n\n            axisHelper.niceScaleExtent(scale, axisModel);\n            return scale;\n        },\n\n        /**\n         * Mixin common methods to axis model,\n         *\n         * Inlcude methods\n         * `getFormattedLabels() => Array.<string>`\n         * `getCategories() => Array.<string>`\n         * `getMin(origin: boolean) => number`\n         * `getMax(origin: boolean) => number`\n         * `getNeedCrossZero() => boolean`\n         * `setRange(start: number, end: number)`\n         * `resetRange()`\n         */\n        mixinAxisModelCommonMethods: function (Model) {\n            util.mixin(Model, axisModelCommonMixin);\n        }\n    };\n\n\n/***/ }),\n/* 269 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var graphic = __webpack_require__(192);\n    var zrUtil = __webpack_require__(190);\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    module.exports = function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n            style: {\n                fill: opts.maskColor\n            },\n            zlevel: opts.zlevel,\n            z: 10000\n        });\n        var arc = new graphic.Arc({\n            shape: {\n                startAngle: -PI / 2,\n                endAngle: -PI / 2 + 0.1,\n                r: 10\n            },\n            style: {\n                stroke: opts.color,\n                lineCap: 'round',\n                lineWidth: 5\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n        var labelRect = new graphic.Rect({\n            style: {\n                fill: 'none',\n                text: opts.text,\n                textPosition: 'right',\n                textDistance: 10,\n                textFill: opts.textColor\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n\n        arc.animateShape(true)\n            .when(1000, {\n                endAngle: PI * 3 / 2\n            })\n            .start('circularInOut');\n        arc.animateShape(true)\n            .when(1000, {\n                startAngle: PI * 3 / 2\n            })\n            .delay(300)\n            .start('circularInOut');\n\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n\n\n/***/ }),\n/* 270 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n\n    /**\n     * Caution: If the mechanism should be changed some day, these cases\n     * should be considered:\n     *\n     * (1) In `merge option` mode, if using the same option to call `setOption`\n     * many times, the result should be the same (try our best to ensure that).\n     * (2) In `merge option` mode, if a component has no id/name specified, it\n     * will be merged by index, and the result sequence of the components is\n     * consistent to the original sequence.\n     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n     * `mergeOption` in module:echarts/model/OptionManager.\n     */\n\n    var zrUtil = __webpack_require__(190);\n    var modelUtil = __webpack_require__(194);\n    var Model = __webpack_require__(199);\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n\n    var ComponentModel = __webpack_require__(202);\n\n    var globalDefault = __webpack_require__(272);\n\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n\n        constructor: GlobalModel,\n\n        init: function (option, parentModel, theme, optionManager) {\n            theme = theme || {};\n\n            this.option = null; // Mark as not initialized.\n\n            /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n            this._theme = new Model(theme);\n\n            /**\n             * @type {module:echarts/model/OptionManager}\n             */\n            this._optionManager = optionManager;\n        },\n\n        setOption: function (option, optionPreprocessorFuncs) {\n            zrUtil.assert(\n                !(OPTION_INNER_KEY in option),\n                'please use chart.getOption()'\n            );\n\n            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n            this.resetOption(null);\n        },\n\n        /**\n         * @param {string} type null/undefined: reset all.\n         *                      'recreate': force recreate all.\n         *                      'timeline': only reset timeline option\n         *                      'media': only reset media query option\n         * @return {boolean} Whether option changed.\n         */\n        resetOption: function (type) {\n            var optionChanged = false;\n            var optionManager = this._optionManager;\n\n            if (!type || type === 'recreate') {\n                var baseOption = optionManager.mountOption(type === 'recreate');\n\n                if (!this.option || type === 'recreate') {\n                    initBase.call(this, baseOption);\n                }\n                else {\n                    this.restoreData();\n                    this.mergeOption(baseOption);\n                }\n                optionChanged = true;\n            }\n\n            if (type === 'timeline' || type === 'media') {\n                this.restoreData();\n            }\n\n            if (!type || type === 'recreate' || type === 'timeline') {\n                var timelineOption = optionManager.getTimelineOption(this);\n                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n            }\n\n            if (!type || type === 'recreate' || type === 'media') {\n                var mediaOptions = optionManager.getMediaOption(this, this._api);\n                if (mediaOptions.length) {\n                    each(mediaOptions, function (mediaOption) {\n                        this.mergeOption(mediaOption, optionChanged = true);\n                    }, this);\n                }\n            }\n\n            return optionChanged;\n        },\n\n        /**\n         * @protected\n         */\n        mergeOption: function (newOption) {\n            var option = this.option;\n            var componentsMap = this._componentsMap;\n            var newCptTypes = [];\n\n            //  component model  merge\n            each(newOption, function (componentOption, mainType) {\n                if (componentOption == null) {\n                    return;\n                }\n\n                if (!ComponentModel.hasClass(mainType)) {\n                    option[mainType] = option[mainType] == null\n                        ? zrUtil.clone(componentOption)\n                        : zrUtil.merge(option[mainType], componentOption, true);\n                }\n                else {\n                    newCptTypes.push(mainType);\n                }\n            });\n\n            // FIXME OPTION \n            ComponentModel.topologicalTravel(\n                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n            );\n\n            this._seriesIndices = this._seriesIndices || [];\n\n            function visitComponent(mainType, dependencies) {\n                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\n                var mapResult = modelUtil.mappingToExists(\n                    componentsMap.get(mainType), newCptOptionList\n                );\n\n                modelUtil.makeIdAndName(mapResult);\n\n                // Set mainType and complete subType.\n                each(mapResult, function (item, index) {\n                    var opt = item.option;\n                    if (isObject(opt)) {\n                        item.keyInfo.mainType = mainType;\n                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n                    }\n                });\n\n                var dependentModels = getComponentsByTypes(\n                    componentsMap, dependencies\n                );\n\n                option[mainType] = [];\n                componentsMap.set(mainType, []);\n\n                each(mapResult, function (resultItem, index) {\n                    var componentModel = resultItem.exist;\n                    var newCptOption = resultItem.option;\n\n                    zrUtil.assert(\n                        isObject(newCptOption) || componentModel,\n                        'Empty component definition'\n                    );\n\n                    // Consider where is no new option and should be merged using {},\n                    // see removeEdgeAndAdd in topologicalTravel and\n                    // ComponentModel.getAllClassMainTypes.\n                    if (!newCptOption) {\n                        componentModel.mergeOption({}, this);\n                        componentModel.optionUpdated({}, false);\n                    }\n                    else {\n                        var ComponentModelClass = ComponentModel.getClass(\n                            mainType, resultItem.keyInfo.subType, true\n                        );\n\n                        if (componentModel && componentModel instanceof ComponentModelClass) {\n                            componentModel.name = resultItem.keyInfo.name;\n                            componentModel.mergeOption(newCptOption, this);\n                            componentModel.optionUpdated(newCptOption, false);\n                        }\n                        else {\n                            // PENDING Global as parent ?\n                            var extraOpt = zrUtil.extend(\n                                {\n                                    dependentModels: dependentModels,\n                                    componentIndex: index\n                                },\n                                resultItem.keyInfo\n                            );\n                            componentModel = new ComponentModelClass(\n                                newCptOption, this, this, extraOpt\n                            );\n                            zrUtil.extend(componentModel, extraOpt);\n                            componentModel.init(newCptOption, this, this, extraOpt);\n                            // Call optionUpdated after init.\n                            // newCptOption has been used as componentModel.option\n                            // and may be merged with theme and default, so pass null\n                            // to avoid confusion.\n                            componentModel.optionUpdated(null, true);\n                        }\n                    }\n\n                    componentsMap.get(mainType)[index] = componentModel;\n                    option[mainType][index] = componentModel.option;\n                }, this);\n\n                // Backup series for filtering.\n                if (mainType === 'series') {\n                    this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n                }\n            }\n        },\n\n        /**\n         * Get option for output (cloned option and inner info removed)\n         * @public\n         * @return {Object}\n         */\n        getOption: function () {\n            var option = zrUtil.clone(this.option);\n\n            each(option, function (opts, mainType) {\n                if (ComponentModel.hasClass(mainType)) {\n                    var opts = modelUtil.normalizeToArray(opts);\n                    for (var i = opts.length - 1; i >= 0; i--) {\n                        // Remove options with inner id.\n                        if (modelUtil.isIdInner(opts[i])) {\n                            opts.splice(i, 1);\n                        }\n                    }\n                    option[mainType] = opts;\n                }\n            });\n\n            delete option[OPTION_INNER_KEY];\n\n            return option;\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        getTheme: function () {\n            return this._theme;\n        },\n\n        /**\n         * @param {string} mainType\n         * @param {number} [idx=0]\n         * @return {module:echarts/model/Component}\n         */\n        getComponent: function (mainType, idx) {\n            var list = this._componentsMap.get(mainType);\n            if (list) {\n                return list[idx || 0];\n            }\n        },\n\n        /**\n         * If none of index and id and name used, return all components with mainType.\n         * @param {Object} condition\n         * @param {string} condition.mainType\n         * @param {string} [condition.subType] If ignore, only query by mainType\n         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        queryComponents: function (condition) {\n            var mainType = condition.mainType;\n            if (!mainType) {\n                return [];\n            }\n\n            var index = condition.index;\n            var id = condition.id;\n            var name = condition.name;\n\n            var cpts = this._componentsMap.get(mainType);\n\n            if (!cpts || !cpts.length) {\n                return [];\n            }\n\n            var result;\n\n            if (index != null) {\n                if (!isArray(index)) {\n                    index = [index];\n                }\n                result = filter(map(index, function (idx) {\n                    return cpts[idx];\n                }), function (val) {\n                    return !!val;\n                });\n            }\n            else if (id != null) {\n                var isIdArray = isArray(id);\n                result = filter(cpts, function (cpt) {\n                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n                        || (!isIdArray && cpt.id === id);\n                });\n            }\n            else if (name != null) {\n                var isNameArray = isArray(name);\n                result = filter(cpts, function (cpt) {\n                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n                        || (!isNameArray && cpt.name === name);\n                });\n            }\n            else {\n                // Return all components with mainType\n                result = cpts.slice();\n            }\n\n            return filterBySubType(result, condition);\n        },\n\n        /**\n         * The interface is different from queryComponents,\n         * which is convenient for inner usage.\n         *\n         * @usage\n         * var result = findComponents(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series'},\n         *     function (model, index) {...}\n         * );\n         * // result like [component0, componnet1, ...]\n         *\n         * @param {Object} condition\n         * @param {string} condition.mainType Mandatory.\n         * @param {string} [condition.subType] Optional.\n         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n         *        where xxx is mainType.\n         *        If query attribute is null/undefined or has no index/id/name,\n         *        do not filtering by query conditions, which is convenient for\n         *        no-payload situations or when target of action is global.\n         * @param {Function} [condition.filter] parameter: component, return boolean.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        findComponents: function (condition) {\n            var query = condition.query;\n            var mainType = condition.mainType;\n\n            var queryCond = getQueryCond(query);\n            var result = queryCond\n                ? this.queryComponents(queryCond)\n                : this._componentsMap.get(mainType);\n\n            return doFilter(filterBySubType(result, condition));\n\n            function getQueryCond(q) {\n                var indexAttr = mainType + 'Index';\n                var idAttr = mainType + 'Id';\n                var nameAttr = mainType + 'Name';\n                return q && (\n                        q[indexAttr] != null\n                        || q[idAttr] != null\n                        || q[nameAttr] != null\n                    )\n                    ? {\n                        mainType: mainType,\n                        // subType will be filtered finally.\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    }\n                    : null;\n            }\n\n            function doFilter(res) {\n                return condition.filter\n                     ? filter(res, condition.filter)\n                     : res;\n            }\n        },\n\n        /**\n         * @usage\n         * eachComponent('legend', function (legendModel, index) {\n         *     ...\n         * });\n         * eachComponent(function (componentType, model, index) {\n         *     // componentType does not include subType\n         *     // (componentType is 'xxx' but not 'xxx.aa')\n         * });\n         * eachComponent(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n         *     function (model, index) {...}\n         * );\n         * eachComponent(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n         *     function (model, index) {...}\n         * );\n         *\n         * @param {string|Object=} mainType When mainType is object, the definition\n         *                                  is the same as the method 'findComponents'.\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachComponent: function (mainType, cb, context) {\n            var componentsMap = this._componentsMap;\n\n            if (typeof mainType === 'function') {\n                context = cb;\n                cb = mainType;\n                componentsMap.each(function (components, componentType) {\n                    each(components, function (component, index) {\n                        cb.call(context, componentType, component, index);\n                    });\n                });\n            }\n            else if (zrUtil.isString(mainType)) {\n                each(componentsMap.get(mainType), cb, context);\n            }\n            else if (isObject(mainType)) {\n                var queryResult = this.findComponents(mainType);\n                each(queryResult, cb, context);\n            }\n        },\n\n        /**\n         * @param {string} name\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByName: function (name) {\n            var series = this._componentsMap.get('series');\n            return filter(series, function (oneSeries) {\n                return oneSeries.name === name;\n            });\n        },\n\n        /**\n         * @param {number} seriesIndex\n         * @return {module:echarts/model/Series}\n         */\n        getSeriesByIndex: function (seriesIndex) {\n            return this._componentsMap.get('series')[seriesIndex];\n        },\n\n        /**\n         * @param {string} subType\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByType: function (subType) {\n            var series = this._componentsMap.get('series');\n            return filter(series, function (oneSeries) {\n                return oneSeries.subType === subType;\n            });\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeries: function () {\n            return this._componentsMap.get('series').slice();\n        },\n\n        /**\n         * After filtering, series may be different\n         * frome raw series.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.get('series')[rawSeriesIndex];\n                cb.call(context, series, rawSeriesIndex);\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeries: function (cb, context) {\n            each(this._componentsMap.get('series'), cb, context);\n        },\n\n        /**\n         * After filtering, series may be different.\n         * frome raw series.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeriesByType: function (subType, cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.get('series')[rawSeriesIndex];\n                if (series.subType === subType) {\n                    cb.call(context, series, rawSeriesIndex);\n                }\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered of given type.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeriesByType: function (subType, cb, context) {\n            return each(this.getSeriesByType(subType), cb, context);\n        },\n\n        /**\n         * @param {module:echarts/model/Series} seriesModel\n         */\n        isSeriesFiltered: function (seriesModel) {\n            assertSeriesInitialized(this);\n            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getCurrentSeriesIndices: function () {\n            return (this._seriesIndices || []).slice();\n        },\n\n        /**\n         * @param {Function} cb\n         * @param {*} context\n         */\n        filterSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            var filteredSeries = filter(\n                this._componentsMap.get('series'), cb, context\n            );\n            this._seriesIndices = createSeriesIndices(filteredSeries);\n        },\n\n        restoreData: function () {\n            var componentsMap = this._componentsMap;\n\n            this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n\n            var componentTypes = [];\n            componentsMap.each(function (components, componentType) {\n                componentTypes.push(componentType);\n            });\n\n            ComponentModel.topologicalTravel(\n                componentTypes,\n                ComponentModel.getAllClassMainTypes(),\n                function (componentType, dependencies) {\n                    each(componentsMap.get(componentType), function (component) {\n                        component.restoreData();\n                    });\n                }\n            );\n        }\n\n    });\n\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        zrUtil.each(theme, function (themeItem, name) {\n            //  component model  merge  model \n            if (!ComponentModel.hasClass(name)) {\n                if (typeof themeItem === 'object') {\n                    option[name] = !option[name]\n                        ? zrUtil.clone(themeItem)\n                        : zrUtil.merge(option[name], themeItem, false);\n                }\n                else {\n                    if (option[name] == null) {\n                        option[name] = themeItem;\n                    }\n                }\n            }\n        });\n    }\n\n    function initBase(baseOption) {\n        baseOption = baseOption;\n\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n\n        /**\n         * Init with series: [], in case of calling findSeries method\n         * before series initialized.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = zrUtil.createHashMap({series: []});\n\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n\n        mergeTheme(baseOption, this._theme.option);\n\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n\n        this.mergeOption(baseOption);\n    }\n\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap.get(type) || []).slice();\n        });\n\n        return ret;\n    }\n\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type\n            ? newCptOption.type\n            : existComponent\n            ? existComponent.subType\n            // Use determineSubType only when there is no existComponent.\n            : ComponentModel.determineSubType(mainType, newCptOption);\n\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType')\n            ? filter(components, function (cpt) {\n                return cpt.subType === condition.subType;\n            })\n            : components;\n    }\n\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (__DEV__) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Option should contains series.');\n            }\n        }\n    }\n\n    zrUtil.mixin(GlobalModel, __webpack_require__(237));\n\n    module.exports = GlobalModel;\n\n\n/***/ }),\n/* 271 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var modelUtil = __webpack_require__(194);\n    var ComponentModel = __webpack_require__(202);\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n    OptionManager.prototype = {\n\n        constructor: OptionManager,\n\n        /**\n         * @public\n         * @param {Object} rawOption Raw option.\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Array.<Function>} optionPreprocessorFuncs\n         * @return {Object} Init option\n         */\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n\n            // FIXME\n            //  timeline options  media baseOption\n\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(\n                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n            );\n            this._newBaseOption = newParsedOption.baseOption;\n\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            }\n            else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n\n        /**\n         * @param {boolean} isRecreate\n         * @return {Object}\n         */\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n\n            // TODO\n            // resetclone\n\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n\n            return clone(isRecreate\n                // this._optionBackup.baseOption, which is created at the first `setOption`\n                // called, and is merged into every new option by inner method `mergeOption`\n                // each time `setOption` called, can be only used in `isRecreate`, because\n                // its reliability is under suspicion. In other cases option merge is\n                // performed by `model.mergeOption`.\n                ? optionBackup.baseOption : this._newBaseOption\n            );\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object}\n         */\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(\n                        timelineOptions[timelineModel.getCurrentIndex()],\n                        true\n                    );\n                }\n            }\n\n            return option;\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Array.<Object>}\n         */\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n\n            // FIXME\n            // mediaDefault\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(\n                        index === -1 ? mediaDefault.option : mediaList[index].option\n                    );\n                });\n            }\n            // Otherwise return nothing.\n\n            this._currentMediaIndices = indices;\n\n            return result;\n        }\n    };\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    }\n                    else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n\n        // Preprocess.\n        each([baseOption].concat(timelineOptions)\n            .concat(zrUtil.map(mediaList, function (media) {\n                return media.option;\n            })),\n            function (option) {\n                each(optionPreprocessorFuncs, function (preProcess) {\n                    preProcess(option, isNew);\n                });\n            }\n        );\n\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n            width: ecWidth,\n            height: ecHeight,\n            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n        };\n\n        var applicatable = true;\n\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n\n        return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        }\n        else if (operator === 'max') {\n            return real <= expect;\n        }\n        else { // Equals\n            return real === expect;\n        }\n    }\n\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n\n            var oldCptOpt = oldOption[mainType];\n\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            }\n            else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return (item.option && item.exist)\n                        ? merge(item.exist, item.option, true)\n                        : (item.exist || item.option);\n                });\n            }\n        });\n    }\n\n    module.exports = OptionManager;\n\n\n/***/ }),\n/* 272 */\n/***/ (function(module, exports) {\n\n\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    module.exports = {\n        // \n        // backgroundColor: 'rgba(0,0,0,0)',\n\n        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n        // \n        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n        // \n        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n        //  Grid \n        // grid: {},\n        // \n        textStyle: {\n            // color: '#000',\n            // decoration: 'none',\n            // PENDING\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            // fontFamily: 'Arial, Verdana, sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n\n        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n        // Default is source-over\n        blendMode: null,\n\n        animation: 'auto',\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n\n        animationThreshold: 2000,\n        // Configuration for progressive/incremental rendering\n        progressiveThreshold: 3000,\n        progressive: 400,\n\n        // Threshold of if use single hover layer to optimize.\n        // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n        // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n        // which is unexpected.\n        // see example <echarts/test/heatmap-large.html>.\n        hoverLayerThreshold: 3000,\n\n        // See: module:echarts/scale/Time\n        useUTC: false\n    };\n\n\n/***/ }),\n/* 273 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    module.exports = {\n        getAreaStyle: __webpack_require__(220)(\n            [\n                ['fill', 'color'],\n                ['shadowBlur'],\n                ['shadowOffsetX'],\n                ['shadowOffsetY'],\n                ['opacity'],\n                ['shadowColor']\n            ]\n        )\n    };\n\n\n/***/ }),\n/* 274 */\n/***/ (function(module, exports) {\n\n\n\n    module.exports = {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n\n\n/***/ }),\n/* 275 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var getItemStyle = __webpack_require__(220)(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor'],\n            ['textPosition'],\n            ['textAlign']\n        ]\n    );\n    module.exports = {\n        getItemStyle: function (excludes, includes) {\n            var style = getItemStyle.call(this, excludes, includes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n        }\n    };\n\n\n/***/ }),\n/* 276 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var getLineStyle = __webpack_require__(220)(\n        [\n            ['lineWidth', 'width'],\n            ['stroke', 'color'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash(style.lineWidth);\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getLineDash: function (lineWidth) {\n            if (lineWidth == null) {\n                lineWidth = 1;\n            }\n            var lineType = this.get('type');\n            var dotSize = Math.max(lineWidth, 2);\n            var dashSize = lineWidth * 4;\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n        }\n    };\n\n\n/***/ }),\n/* 277 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var textContain = __webpack_require__(206);\n    var graphicUtil = __webpack_require__(192);\n\n    module.exports = {\n        /**\n         * Get color property or get color from option.textStyle.color\n         * @return {string}\n         */\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color')\n                || (ecModel && ecModel.get('textStyle.color'));\n        },\n\n        /**\n         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n         * @return {string}\n         */\n        getFont: function () {\n            return graphicUtil.getFont({\n                fontStyle: this.getShallow('fontStyle'),\n                fontWeight: this.getShallow('fontWeight'),\n                fontSize: this.getShallow('fontSize'),\n                fontFamily: this.getShallow('fontFamily')\n            }, this.ecModel);\n        },\n\n        getTextRect: function (text) {\n            return textContain.getBoundingRect(\n                text,\n                this.getFont(),\n                this.getShallow('align'),\n                this.getShallow('baseline')\n            );\n        },\n\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(\n                text, containerWidth, this.getFont(), ellipsis, options\n            );\n        }\n    };\n\n\n/***/ }),\n/* 278 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Compatitable with 2.0\n\n\n    var zrUtil = __webpack_require__(190);\n    var compatStyle = __webpack_require__(279);\n\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n\n    var LAYOUT_PROPERTIES = [\n        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n    ];\n\n    var COMPATITABLE_COMPONENTS = [\n        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n    ];\n\n    var COMPATITABLE_SERIES = [\n        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n    ];\n\n    var each = zrUtil.each;\n\n    module.exports = function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n\n            var seriesType = seriesOpt.type;\n\n            compatStyle(seriesOpt);\n\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null\n                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n\n\n/***/ }),\n/* 279 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var POSSIBLE_STYLES = [\n        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n        'chordStyle', 'label', 'labelLine'\n    ];\n\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n\n    module.exports = function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    }\n                    else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n\n\n/***/ }),\n/* 280 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n\n    var zrUtil = __webpack_require__(190);\n    var Scale = __webpack_require__(213);\n    var numberUtil = __webpack_require__(193);\n\n    // Use some method of IntervalScale\n    var IntervalScale = __webpack_require__(222);\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n\n    var mathLog = Math.log;\n\n    var LogScale = Scale.extend({\n\n        type: 'log',\n\n        base: 10,\n\n        $constructor: function () {\n            Scale.apply(this, arguments);\n            this._originalScale = new IntervalScale();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            var originalScale = this._originalScale;\n            var extent = this._extent;\n            var originalExtent = originalScale.getExtent();\n\n            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                var powVal = numberUtil.round(mathPow(this.base, val));\n\n                // Fix #4158\n                powVal = (val === extent[0] && originalScale.__fixMin)\n                    ? fixRoundingError(powVal, originalExtent[0])\n                    : powVal;\n                powVal = (val === extent[1] && originalScale.__fixMax)\n                    ? fixRoundingError(powVal, originalExtent[1])\n                    : powVal;\n\n                return powVal;\n            }, this);\n        },\n\n        /**\n         * @param {number} val\n         * @return {string}\n         */\n        getLabel: intervalScaleProto.getLabel,\n\n        /**\n         * @param  {number} val\n         * @return {number}\n         */\n        scale: function (val) {\n            val = scaleProto.scale.call(this, val);\n            return mathPow(this.base, val);\n        },\n\n        /**\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var base = this.base;\n            start = mathLog(start) / mathLog(base);\n            end = mathLog(end) / mathLog(base);\n            intervalScaleProto.setExtent.call(this, start, end);\n        },\n\n        /**\n         * @return {number} end\n         */\n        getExtent: function () {\n            var base = this.base;\n            var extent = scaleProto.getExtent.call(this);\n            extent[0] = mathPow(base, extent[0]);\n            extent[1] = mathPow(base, extent[1]);\n\n            // Fix #4158\n            var originalScale = this._originalScale;\n            var originalExtent = originalScale.getExtent();\n            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n            return extent;\n        },\n\n        /**\n         * @param  {Array.<number>} extent\n         */\n        unionExtent: function (extent) {\n            this._originalScale.unionExtent(extent);\n\n            var base = this.base;\n            extent[0] = mathLog(extent[0]) / mathLog(base);\n            extent[1] = mathLog(extent[1]) / mathLog(base);\n            scaleProto.unionExtent.call(this, extent);\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, true, function (val) {\n                return val > 0;\n            }));\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         * @param  {number} [approxTickNum = 10] Given approx tick number\n         */\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (span === Infinity || span <= 0) {\n                return;\n            }\n\n            var interval = numberUtil.quantity(span);\n            var err = approxTickNum / span * interval;\n\n            // Filter ticks to get closer to the desired count.\n            if (err <= 0.5) {\n                interval *= 10;\n            }\n\n            // Interval should be integer\n            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                interval *= 10;\n            }\n\n            var niceExtent = [\n                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n            ];\n\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @override\n         */\n        niceExtent: function (opt) {\n            intervalScaleProto.niceExtent.call(this, opt);\n\n            var originalScale = this._originalScale;\n            originalScale.__fixMin = opt.fixMin;\n            originalScale.__fixMax = opt.fixMax;\n        }\n\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n\n    LogScale.create = function () {\n        return new LogScale();\n    };\n\n    function fixRoundingError(val, originalVal) {\n        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n    }\n\n    module.exports = LogScale;\n\n\n/***/ }),\n/* 281 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\n\n    var zrUtil = __webpack_require__(190);\n    var Scale = __webpack_require__(213);\n\n    var scaleProto = Scale.prototype;\n\n    var OrdinalScale = Scale.extend({\n\n        type: 'ordinal',\n\n        init: function (data, extent) {\n            this._data = data;\n            this._extent = extent || [0, data.length - 1];\n        },\n\n        parse: function (val) {\n            return typeof val === 'string'\n                ? zrUtil.indexOf(this._data, val)\n                // val might be float.\n                : Math.round(val);\n        },\n\n        contain: function (rank) {\n            rank = this.parse(rank);\n            return scaleProto.contain.call(this, rank)\n                && this._data[rank] != null;\n        },\n\n        /**\n         * Normalize given rank or name to linear [0, 1]\n         * @param {number|string} [val]\n         * @return {number}\n         */\n        normalize: function (val) {\n            return scaleProto.normalize.call(this, this.parse(val));\n        },\n\n        scale: function (val) {\n            return Math.round(scaleProto.scale.call(this, val));\n        },\n\n        /**\n         * @return {Array}\n         */\n        getTicks: function () {\n            var ticks = [];\n            var extent = this._extent;\n            var rank = extent[0];\n\n            while (rank <= extent[1]) {\n                ticks.push(rank);\n                rank++;\n            }\n\n            return ticks;\n        },\n\n        /**\n         * Get item on rank n\n         * @param {number} n\n         * @return {string}\n         */\n        getLabel: function (n) {\n            return this._data[n];\n        },\n\n        /**\n         * @return {number}\n         */\n        count: function () {\n            return this._extent[1] - this._extent[0] + 1;\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, false));\n        },\n\n        niceTicks: zrUtil.noop,\n        niceExtent: zrUtil.noop\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n\n    module.exports = OrdinalScale;\n\n\n/***/ }),\n/* 282 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Interval scale\n * @module echarts/coord/scale/Time\n */\n\n\n\n    // [About UTC and local time zone]:\n    // In most cases, `number.parseDate` will treat input data string as local time\n    // (except time zone is specified in time string). And `format.formateTime` returns\n    // local time by default. option.useUTC is false by default. This design have\n    // concidered these common case:\n    // (1) Time that is persistent in server is in UTC, but it is needed to be diplayed\n    // in local time by default.\n    // (2) By default, the input data string (e.g., '2011-01-02') should be displayed\n    // as its original time, without any time difference.\n\n    var zrUtil = __webpack_require__(190);\n    var numberUtil = __webpack_require__(193);\n    var formatUtil = __webpack_require__(197);\n    var scaleHelper = __webpack_require__(238);\n\n    var IntervalScale = __webpack_require__(222);\n\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n\n    // FIXME \n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            }\n            else {\n                hi  = mid;\n            }\n        }\n        return lo;\n    };\n\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n        type: 'time',\n\n        /**\n         * @override\n         */\n        getLabel: function (val) {\n            var stepLvl = this._stepLvl;\n\n            var date = new Date(val);\n\n            return formatUtil.formatTime(stepLvl[0], date, this.getSetting('useUTC'));\n        },\n\n        /**\n         * @override\n         */\n        niceExtent: function (opt) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                // Expand extent\n                extent[0] -= ONE_DAY;\n                extent[1] += ONE_DAY;\n            }\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (extent[1] === -Infinity && extent[0] === Infinity) {\n                var d = new Date();\n                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                extent[0] = extent[1] - ONE_DAY;\n            }\n\n            this.niceTicks(opt.splitNumber);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!opt.fixMin) {\n                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!opt.fixMax) {\n                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n            }\n        },\n\n        /**\n         * @override\n         */\n        niceTicks: function (approxTickNum) {\n            var timezoneOffset = this.getSetting('useUTC')\n                ? 0 : numberUtil.getTimezoneOffset() * 60 * 1000;\n            approxTickNum = approxTickNum || 10;\n\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            var approxInterval = span / approxTickNum;\n            var scaleLevelsLen = scaleLevels.length;\n            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n            var interval = level[2];\n            // Same with interval scale if span is much larger than 1 year\n            if (level[0] === 'year') {\n                var yearSpan = span / interval;\n\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\n                interval *= yearStep;\n            }\n\n            var niceExtent = [\n                Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset),\n                Math.round(mathFloor((extent[1] - timezoneOffset)/ interval) * interval + timezoneOffset)\n            ];\n\n            scaleHelper.fixExtent(niceExtent, extent);\n\n            this._stepLvl = level;\n            // Interval will be used in getTicks\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        parse: function (val) {\n            // val might be float.\n            return +numberUtil.parseDate(val);\n        }\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n\n    // Steps from d3\n    var scaleLevels = [\n        // Format       step    interval\n        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n        ['week',        7,      ONE_DAY * 7],        // 7d\n        ['month',       1,      ONE_DAY * 31],       // 1M\n        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n        ['year',        1,      ONE_DAY * 380]       // 1Y\n    ];\n\n    /**\n     * @param {module:echarts/model/Model}\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function (model) {\n        return new TimeScale({useUTC: model.ecModel.get('useUTC')});\n    };\n\n    module.exports = TimeScale;\n\n\n/***/ }),\n/* 283 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var Gradient = __webpack_require__(224);\n    module.exports = function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(\n                            idx, 'color', color(seriesModel.getDataParams(idx))\n                        );\n                    });\n                }\n\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n\n\n/***/ }),\n/* 284 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = __webpack_require__(190);\n    var Draggable = __webpack_require__(311);\n\n    var Eventful = __webpack_require__(210);\n\n    var SILENT = 'silent';\n\n    function makeEventPacket(eveType, targetInfo, event) {\n        return {\n            type: eveType,\n            event: event,\n            // target can only be an element that is not silent.\n            target: targetInfo.target,\n            // topTarget can be a silent element.\n            topTarget: targetInfo.topTarget,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * {target, topTarget}\n         * @private\n         * @type {Object}\n         */\n        this._hovered = {};\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var lastHovered = this._hovered;\n            var hovered = this._hovered = this.findHover(x, y);\n            var hoveredTarget = hovered.target;\n            var lastHoveredTarget = lastHovered.target;\n\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget && lastHoveredTarget.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = {};\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * cursor style\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * \n         *\n         * @private\n         * @param {Object} targetInfo {target, topTarget} \n         * @param {string} eventName \n         * @param {Object} event \n         */\n        dispatchToElement: function (targetInfo, eventName, event) {\n            targetInfo = targetInfo || {};\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n            var el = targetInfo.target;\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                //  zrender \n                this.trigger(eventName, eventPacket);\n                // \n                //  click  dispose painter \n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @return {model:zrender/Element}\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            var out = {};\n\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                var hoverCheckResult;\n                if (list[i] !== exclude\n                    // getDisplayList may include ignored item in VML mode\n                    && !list[i].ignore\n                    && (hoverCheckResult = isHover(list[i], x, y))\n                ) {\n                    !out.topTarget && (out.topTarget = list[i]);\n                    if (hoverCheckResult !== SILENT) {\n                        out.target = list[i];\n                        break;\n                    }\n                }\n            }\n\n            return out;\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY);\n            var hoveredTarget = hovered.target;\n\n            if (name === 'mousedown') {\n                this._downel = hoveredTarget;\n                // In case click triggered before mouseup\n                this._upel = hoveredTarget;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hoveredTarget;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            var isSilent;\n            while (el) {\n                // If clipped by ancestor.\n                // FIXME: If clipPath has neither stroke nor fill,\n                // el.clipPath.contain(x, y) will always return false.\n                if (el.clipPath && !el.clipPath.contain(x, y))  {\n                    return false;\n                }\n                if (el.silent) {\n                    isSilent = true;\n                }\n                el = el.parent;\n            }\n            return isSilent ? SILENT : true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n/***/ }),\n/* 285 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = __webpack_require__(190);\n    var config = __webpack_require__(214);\n    var Style = __webpack_require__(246);\n    var Pattern = __webpack_require__(245);\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * dom\n     *\n     * @inner\n     * @param {string} id dom id \n     * @param {string} type dom typesuch as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // append~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // \n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * \n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * \n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * alpha\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n/***/ }),\n/* 286 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = __webpack_require__(214);\n    var util = __webpack_require__(190);\n    var log = __webpack_require__(234);\n    var BoundingRect = __webpack_require__(200);\n    var timsort = __webpack_require__(226);\n\n    var Layer = __webpack_require__(285);\n\n    var requestAnimationFrame = __webpack_require__(241);\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.__builtin__) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n\n            clipPath.setTransform(ctx);\n            ctx.beginPath();\n            clipPath.buildPath(ctx, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // \n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root \n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * \n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            if (opts.width != null) {\n                root.width = opts.width;\n            }\n            if (opts.height != null) {\n                root.height = opts.height;\n            }\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n\n            this._domRoot = root;\n        }\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._domRoot;\n        },\n\n        /**\n         * \n         * @param {boolean} [paintAll=false] displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.__builtin__ && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuiltinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuiltinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.__builtin__) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         *  zlevel \n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.__builtin__ = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            layersMap[zlevel] = layer;\n\n            // Vitual layer will not directly show on the screen.\n            // (It can be a WebGL layer and assigned to a ZImage element)\n            // But it still under management of zrender.\n            if (!layer.virtual) {\n                if (prevLayer) {\n                    var prevDom = prevLayer.dom;\n                    if (prevDom.nextSibling) {\n                        domRoot.insertBefore(\n                            layer.dom,\n                            prevDom.nextSibling\n                        );\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n                else {\n                    if (domRoot.firstChild) {\n                        domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n            }\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuiltinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (!layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuiltinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // \n            this.eachBuiltinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * hover\n         */\n        clear: function () {\n            this.eachBuiltinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * zlevel\n         *\n         * @param {string} zlevel\n         * @param {Object} config \n         * @param {string} [config.clearColor=0] \n         * @param {string} [config.motionBlur=false] \n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 alpha\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {number} zlevel zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * \n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * \n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            var zlevel;\n\n            var self = this;\n            function findAndDrawOtherLayer(smaller, larger) {\n                var zlevelList = self._zlevelList;\n                if (smaller == null) {\n                    smaller = -Infinity;\n                }\n                var intermediateLayer;\n                for (var i = 0; i < zlevelList.length; i++) {\n                    var z = zlevelList[i];\n                    var layer = self._layers[z];\n                    if (!layer.__builtin__ && z > smaller && z < larger) {\n                        intermediateLayer = layer;\n                        break;\n                    }\n                }\n                if (intermediateLayer && intermediateLayer.renderToCanvas) {\n                    imageLayer.ctx.save();\n                    intermediateLayer.renderToCanvas(imageLayer.ctx);\n                    imageLayer.ctx.restore();\n                }\n            }\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n\n                if (el.zlevel !== zlevel) {\n                    findAndDrawOtherLayer(zlevel, el.zlevel);\n                    zlevel = el.zlevel;\n                }\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            findAndDrawOtherLayer(zlevel, Infinity);\n\n            return imageLayer.dom;\n        },\n        /**\n         * \n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * \n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        pathToImage: function (path, dpr) {\n            dpr = dpr || this.dpr;\n\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            var rect = path.getBoundingRect();\n            var style = path.style;\n            var shadowBlurSize = style.shadowBlur;\n            var shadowOffsetX = style.shadowOffsetX;\n            var shadowOffsetY = style.shadowOffsetY;\n            var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\n            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n            var width = rect.width + leftMargin + rightMargin;\n            var height = rect.height + topMargin + bottomMargin;\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.scale(dpr, dpr);\n            ctx.clearRect(0, 0, width, height);\n            ctx.dpr = dpr;\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [leftMargin - rect.x, topMargin - rect.y];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            path.updateTransform();\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = __webpack_require__(235);\n            var imgShape = new ImageShape({\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n/***/ }),\n/* 287 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = __webpack_require__(190);\n    var env = __webpack_require__(198);\n\n    var Group = __webpack_require__(215);\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = __webpack_require__(226);\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     *  (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} [update=false] \n         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n         *\n         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * \n         * GroupShapeShape\n         * zlevel > z > \n         * @param {boolean} [includeIgnore=false]  ignore \n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var userSetClipPath = el.clipPath;\n            if (userSetClipPath) {\n\n                // FIXME \n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                // Recursively add clip path\n                while (currentClipPath) {\n                    // clipPath  clipPath \n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n\n                    clipPaths.push(currentClipPath);\n\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.clipPath;\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            if (el.__storage === this) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToStorage(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {string|Array.<string>} [el] Storage\n         */\n        delRoot: function (el) {\n            if (el == null) {\n                // el\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (el instanceof Array) {\n                for (var i = 0, l = el.length; i < l; i++) {\n                    this.delRoot(el[i]);\n                }\n                return;\n            }\n\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromStorage(el);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToStorage: function (el) {\n            el.__storage = this;\n            el.dirty(false);\n\n            return this;\n        },\n\n        delFromStorage: function (el) {\n            if (el) {\n                el.__storage = null;\n            }\n\n            return this;\n        },\n\n        /**\n         * Storage\n         */\n        dispose: function () {\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n/***/ }),\n/* 288 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = __webpack_require__(190);\n    var Dispatcher = __webpack_require__(209).Dispatcher;\n\n    var requestAnimationFrame = __webpack_require__(241);\n\n    var Animator = __webpack_require__(240);\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         *  clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         *  animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * \n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * \n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time, delta);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * \n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * \n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * \n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * animator\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] \n         * @param  {Function} [options.getter=null]\n         *         gettergetter\n         * @param  {Function} [options.setter=null]\n         *         settersetter\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            this.addAnimator(animator);\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n/***/ }),\n/* 289 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = __webpack_require__(290);\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // \n        this._life = options.life || 1000;\n        // \n        this._delay = options.delay || 0;\n        // \n        // this._startTime = new Date().getTime() + this._delay;// \n        this._initialized = false;\n\n        // \n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n\n        this._pausedTime = 0;\n        this._paused = false;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime, deltaTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            if (this._paused) {\n                this._pausedTime += deltaTime;\n                return;\n            }\n\n            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n\n            // \n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // \n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // \n                    //  stage.update \n                    return 'restart';\n                }\n\n                // \n                // Animation.update\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._pausedTime = 0;\n\n            this._needsRemove = false;\n        },\n\n        fire: function (eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        },\n\n        pause: function () {\n            this._paused = true;\n        },\n\n        resume: function () {\n            this._paused = false;\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n/***/ }),\n/* 290 */\n/***/ (function(module, exports) {\n\n/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // t^3\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // t^4\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // t^5\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // sin(t)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 2^t\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // sqrt(1-t^2)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n/***/ }),\n/* 291 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var normalizeRadian = __webpack_require__(242).normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n/***/ }),\n/* 292 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var curve = __webpack_require__(207);\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n/***/ }),\n/* 293 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var CMD = __webpack_require__(212).CMD;\n    var line = __webpack_require__(259);\n    var cubic = __webpack_require__(292);\n    var quadratic = __webpack_require__(260);\n    var arc = __webpack_require__(291);\n    var normalizeRadian = __webpack_require__(242).normalizeRadian;\n    var curve = __webpack_require__(207);\n\n    var windingLine = __webpack_require__(261);\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // \n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc \n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                //  subpath \n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE  L, C, Q  NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    //  arc \n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // \n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr scale, x\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        //  subpath \n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n/***/ }),\n/* 294 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = __webpack_require__(209);\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n/***/ }),\n/* 295 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var eventTool = __webpack_require__(209);\n    var zrUtil = __webpack_require__(190);\n    var Eventful = __webpack_require__(210);\n    var env = __webpack_require__(198);\n    var GestureMgr = __webpack_require__(294);\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerEventNames = {\n        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n    };\n\n    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n        var nm = name.replace('mouse', 'pointer');\n        return pointerEventNames[nm] ? nm : name;\n    });\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null).target,\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        // Do not do any preventDefault here. Upper application do that if necessary.\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement({target: gestureInfo.target}, type, gestureInfo.event);\n        }\n    }\n\n    // function onMSGestureChange(proxy, event) {\n    //     if (event.translationX || event.translationY) {\n    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n    //     }\n    //     if (event.scale !== 1) {\n    //         event.pinchX = event.offsetX;\n    //         event.pinchY = event.offsetY;\n    //         event.pinchScale = event.scale;\n    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n    //     }\n    // }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // rootdommouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered, and must before `mousedown` triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        },\n\n        pointerdown: function (event) {\n            domHandlers.mousedown.call(this, event);\n\n            // if (useMSGuesture(this, event)) {\n            //     this._msGesture.addPointer(event.pointerId);\n            // }\n        },\n\n        pointermove: function (event) {\n            // FIXME\n            // pointermove is so sensitive that it always triggered when\n            // tap(click) on touch screen, which affect some judgement in\n            // upper application. So, we dont support mousemove on MS touch\n            // device yet.\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mousemove.call(this, event);\n            }\n        },\n\n        pointerup: function (event) {\n            domHandlers.mouseup.call(this, event);\n        },\n\n        pointerout: function (event) {\n            // pointerout will be triggered when tap on touch screen\n            // (IE11+/Edge on MS Surface) after click event triggered,\n            // which is inconsistent with the mousout behavior we defined\n            // in touchend. So we unify them.\n            // (check domHandlers.touchend for detailed explanation)\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n\n    // function useMSGuesture(handlerProxy, event) {\n    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n    // }\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * dom \n     *\n     * @inner\n     * @param {module:zrender/Handler} instance \n     */\n    function initDomHandler(instance) {\n        zrUtil.each(touchHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(pointerHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(mouseHandlerNames, function (name) {\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        });\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (env.pointerEventsSupported) { // Only IE11+/Edge\n            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n            // at the same time.\n            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n            // screen, which do not occurs in pointer event.\n            // So we use pointer event to both detect touch gesture and mouse behavior.\n            mountHandlers(pointerHandlerNames, this);\n\n            // FIXME\n            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n            // which does not prevent defuault behavior occasionally (which may cause view port\n            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n            // touch screen. And we only support click behavior on MS touch screen now.\n\n            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n            // We dont support touch on IE on win7.\n            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n            // if (typeof MSGesture === 'function') {\n            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n            // }\n        }\n        else {\n            if (env.touchEventsSupported) {\n                mountHandlers(touchHandlerNames, this);\n                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n            }\n\n            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n            // mouse event can not be handle in those devices.\n            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n            // mouseevent after touch event triggered, see `setTouchTimer`.\n            mountHandlers(mouseHandlerNames, this);\n        }\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n/***/ }),\n/* 296 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// CompoundPath to improve performance\n\n\n    var Path = __webpack_require__(196);\n\n    module.exports = Path.extend({\n\n        type: 'compound',\n\n        shape: {\n\n            paths: null\n        },\n\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                if (!paths[i].path) {\n                    paths[i].createPathProxy();\n                }\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n\n\n/***/ }),\n/* 297 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var Gradient = __webpack_require__(224);\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'radial', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n/***/ }),\n/* 298 */\n/***/ (function(module, exports) {\n\n\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n/***/ }),\n/* 299 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = __webpack_require__(195);\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * \n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points \n     * @param {number} smooth , 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint \n     *                            [[0, 0], [100, 100]], \n     *                           \n     * @param {Array} \n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // \n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n/***/ }),\n/* 300 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = __webpack_require__(195);\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points \n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n/***/ }),\n/* 301 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = __webpack_require__(196).extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n/***/ }),\n/* 302 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = __webpack_require__(207);\n    var vec2 = __webpack_require__(195);\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = __webpack_require__(196).extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n/***/ }),\n/* 303 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = __webpack_require__(196).extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // else {\n            //     if (ctx.allocate && !ctx.data.length) {\n            //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n            //     }\n            // }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n/***/ }),\n/* 304 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = __webpack_require__(196).extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n/***/ }),\n/* 305 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = __webpack_require__(247);\n\n    module.exports = __webpack_require__(196).extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n/***/ }),\n/* 306 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = __webpack_require__(247);\n\n    module.exports = __webpack_require__(196).extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n/***/ }),\n/* 307 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = __webpack_require__(298);\n\n    module.exports = __webpack_require__(196).extend({\n\n        type: 'rect',\n\n        shape: {\n            // r1r2r3r4\n            // r1          [1, 1, 1, 1]\n            // r[1]        [1, 1, 1, 1]\n            // r[1, 2]     [1, 2, 1, 2]\n            // r[1, 2, 3]  [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n/***/ }),\n/* 308 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = __webpack_require__(196).extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n/***/ }),\n/* 309 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    var env = __webpack_require__(198);\n    var Path = __webpack_require__(196);\n\n    var shadowTemp = [\n        ['shadowBlur', 0],\n        ['shadowColor', '#000'],\n        ['shadowOffsetX', 0],\n        ['shadowOffsetY', 0]\n    ];\n\n    module.exports = Path.extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\n            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\n            // where exception \"unexpected call to method or property access\"\n            // might be thrown when calling ctx.fill after a path whose area size\n            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\n            // (e.g.,\n            //  ctx.moveTo(10, 10);\n            //  ctx.lineTo(20, 10);\n            //  ctx.closePath();\n            //  ctx.clip();\n            //  ctx.shadowBlur = 10;\n            //  ...\n            //  ctx.fill();\n            // )\n            ? function () {\n                var clipPaths = this.__clipPaths;\n                var style = this.style;\n                var modified;\n\n                if (clipPaths) {\n                    for (var i = 0; i < clipPaths.length; i++) {\n                        var shape = clipPaths[i] && clipPaths[i].shape;\n                        if (shape && shape.startAngle === shape.endAngle) {\n                            for (var j = 0; j < shadowTemp.length; j++) {\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n                            }\n                            modified = true;\n                            break;\n                        }\n                    }\n                }\n\n                Path.prototype.brush.apply(this, arguments);\n\n                if (modified) {\n                    for (var j = 0; j < shadowTemp.length; j++) {\n                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n                    }\n                }\n            }\n            : Path.prototype.brush,\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n/***/ }),\n/* 310 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = __webpack_require__(240);\n    var util = __webpack_require__(190);\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = __webpack_require__(234);\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * \n         *\n         * @param {string} path a.b.c\n         * @param {boolean} [loop] \n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n/***/ }),\n/* 311 */\n/***/ (function(module, exports) {\n\n// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget).target;\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    function param(target, e) {\n        return {target: target, topTarget: e && e.topTarget};\n    }\n\n    module.exports = Draggable;\n\n\n/***/ }),\n/* 312 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var Path = __webpack_require__(196);\n    var PathProxy = __webpack_require__(212);\n    var transformPath = __webpack_require__(313);\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            if (path.setData) {\n                path.setData(pathProxy.data);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            }\n            else {\n                var ctx = path;\n                pathProxy.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            transformPath(pathProxy, m);\n\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (!pathEl.path) {\n                    pathEl.createPathProxy();\n                }\n                if (pathEl.__dirtyPath) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            // Need path proxy.\n            pathBundle.createPathProxy();\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n/***/ }),\n/* 313 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var CMD = __webpack_require__(212).CMD;\n    var vec2 = __webpack_require__(195);\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i] *= sx;\n                    data[i++] += x;\n                    // cy\n                    data[i] *= sy;\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n/***/ }),\n/* 314 */,\n/* 315 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var defaultOption = {\n        show: true,\n        zlevel: 0,                  // \n        z: 0,                       // \n        // \n        inverse: false,\n\n        // \n        name: '',\n        // 'start' | 'middle' | 'end'\n        nameLocation: 'end',\n        // degree\n        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n        nameTruncate: {\n            maxWidth: null,\n            ellipsis: '...',\n            placeholder: '.'\n        },\n        // \n        nameTextStyle: {},\n        // \n        nameGap: 15,\n\n        silent: false, // Default false to support tooltip.\n        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\n        tooltip: {\n            show: false\n        },\n\n        axisPointer: {},\n\n        // \n        axisLine: {\n            // show\n            show: true,\n            onZero: true,\n            // lineStyle\n            lineStyle: {\n                color: '#333',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        axisTick: {\n            // show\n            show: true,\n            // grid\n            inside: false,\n            // length\n            length: 5,\n            // lineStyle\n            lineStyle: {\n                width: 1\n            }\n        },\n        // axis.axisLabel\n        axisLabel: {\n            show: true,\n            // grid\n            inside: false,\n            rotate: 0,\n            showMinLabel: null, // true | false | null (auto)\n            showMaxLabel: null, // true | false | null (auto)\n            margin: 8,\n            // formatter: null,\n            // TEXTSTYLE\n            textStyle: {\n                fontSize: 12\n            }\n        },\n        // \n        splitLine: {\n            // show\n            show: true,\n            // lineStylelineStyle\n            lineStyle: {\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        splitArea: {\n            // show\n            show: false,\n            // areaStyleareaStyle\n            areaStyle: {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    };\n\n    var categoryAxis = zrUtil.merge({\n        // \n        boundaryGap: true,\n        // splitArea: {\n            // show: false\n        // },\n        splitLine: {\n            show: false\n        },\n        // \n        axisTick: {\n            // If tick is align with label when boundaryGap is true\n            alignWithLabel: false,\n            interval: 'auto'\n        },\n        // axis.axisLabel\n        axisLabel: {\n            interval: 'auto'\n        }\n    }, defaultOption);\n\n    var valueAxis = zrUtil.merge({\n        // \n        boundaryGap: [0, 0],\n        // ,  'dataMin' \n        // min: null,\n        //  'dataMax' \n        // max: null,\n        // Readonly prop, specifies start value of the range when using data zoom.\n        // rangeStart: null\n        // Readonly prop, specifies end value of the range when using data zoom.\n        // rangeEnd: null\n        // 0_min_max\n        // scale: false,\n        // 5\n        splitNumber: 5\n        // Minimum interval\n        // minInterval: null\n    }, defaultOption);\n\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n        scale: true,\n        min: 'dataMin',\n        max: 'dataMax'\n    }, valueAxis);\n\n    var logAxis = zrUtil.defaults({\n        scale: true,\n        logBase: 10\n    }, valueAxis);\n\n    module.exports = {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n\n\n/***/ }),\n/* 316 */,\n/* 317 */,\n/* 318 */\n/***/ (function(module, exports) {\n\n\n\n    module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n\n        // Encoding visual for all series include which is filtered for legend drawing\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n\n            var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n            var symbolSize = seriesModel.get('symbolSize');\n\n            data.setVisual({\n                legendSymbol: legendSymbol || symbolType,\n                symbol: symbolType,\n                symbolSize: symbolSize\n            });\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof symbolSize === 'function') {\n                    data.each(function (idx) {\n                        var rawValue = seriesModel.getRawValue(idx);\n                        // FIXME\n                        var params = seriesModel.getDataParams(idx);\n                        data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n                    });\n                }\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var itemSymbolType = itemModel.getShallow('symbol', true);\n                    var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n                    // If has item symbol\n                    if (itemSymbolType != null) {\n                        data.setItemVisual(idx, 'symbol', itemSymbolType);\n                    }\n                    if (itemSymbolSize != null) {\n                        // PENDING Transform symbolSize ?\n                        data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n                    }\n                });\n            }\n        });\n    };\n\n\n/***/ }),\n/* 319 */,\n/* 320 */,\n/* 321 */,\n/* 322 */,\n/* 323 */,\n/* 324 */,\n/* 325 */,\n/* 326 */,\n/* 327 */,\n/* 328 */,\n/* 329 */,\n/* 330 */,\n/* 331 */,\n/* 332 */,\n/* 333 */,\n/* 334 */,\n/* 335 */,\n/* 336 */,\n/* 337 */\n/***/ (function(module, exports) {\n\n\n    module.exports = function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n\n\n/***/ }),\n/* 338 */,\n/* 339 */,\n/* 340 */,\n/* 341 */,\n/* 342 */,\n/* 343 */,\n/* 344 */,\n/* 345 */\n/***/ (function(module, exports) {\n\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\n\n\n    module.exports = function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    var filteredIdx = idxMap[rawIdx];\n\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null\n                        && data.getItemVisual(filteredIdx, 'color', true);\n\n                    if (!singleDataColor) {\n                        // FIXME Performance\n                        var itemModel = dataAll.getItemModel(rawIdx);\n                        var color = itemModel.get('itemStyle.normal.color')\n                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    }\n                    else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n\n\n/***/ }),\n/* 346 */,\n/* 347 */,\n/* 348 */,\n/* 349 */,\n/* 350 */,\n/* 351 */,\n/* 352 */,\n/* 353 */,\n/* 354 */,\n/* 355 */,\n/* 356 */,\n/* 357 */,\n/* 358 */,\n/* 359 */,\n/* 360 */,\n/* 361 */,\n/* 362 */,\n/* 363 */,\n/* 364 */,\n/* 365 */,\n/* 366 */,\n/* 367 */,\n/* 368 */,\n/* 369 */,\n/* 370 */,\n/* 371 */,\n/* 372 */,\n/* 373 */,\n/* 374 */,\n/* 375 */,\n/* 376 */,\n/* 377 */,\n/* 378 */,\n/* 379 */,\n/* 380 */,\n/* 381 */,\n/* 382 */,\n/* 383 */,\n/* 384 */,\n/* 385 */,\n/* 386 */,\n/* 387 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var echarts = __webpack_require__(191);\n\n    // Must use radar component\n    __webpack_require__(401);\n\n    __webpack_require__(388);\n    __webpack_require__(389);\n\n    echarts.registerVisual(zrUtil.curry(__webpack_require__(345), 'radar'));\n    echarts.registerVisual(zrUtil.curry(\n        __webpack_require__(318), 'radar', 'circle', null\n    ));\n    echarts.registerLayout(__webpack_require__(391));\n\n    echarts.registerProcessor(\n        zrUtil.curry(__webpack_require__(337), 'radar')\n    );\n\n    echarts.registerPreprocessor(__webpack_require__(390));\n\n\n/***/ }),\n/* 388 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var SeriesModel = __webpack_require__(217);\n    var List = __webpack_require__(211);\n    var completeDimensions = __webpack_require__(218);\n    var zrUtil = __webpack_require__(190);\n    var encodeHTML = __webpack_require__(197).encodeHTML;\n\n    var RadarSeries = SeriesModel.extend({\n\n        type: 'series.radar',\n\n        dependencies: ['radar'],\n\n\n        // Overwrite\n        init: function (option) {\n            RadarSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n        },\n\n        getInitialData: function (option, ecModel) {\n            var data = option.data || [];\n            var dimensions = completeDimensions(\n                [], data, {extraPrefix: 'indicator_', extraFromZero: true}\n            );\n            var list = new List(dimensions, this);\n            list.initData(data);\n            return list;\n        },\n\n        formatTooltip: function (dataIndex) {\n            var value = this.getRawValue(dataIndex);\n            var coordSys = this.coordinateSystem;\n            var indicatorAxes = coordSys.getIndicatorAxes();\n            var name = this.getData().getName(dataIndex);\n            return encodeHTML(name === '' ? this.name : name) + '<br/>'\n                + zrUtil.map(indicatorAxes, function (axis, idx) {\n                    return encodeHTML(axis.name + ' : ' + value[idx]);\n                }).join('<br />');\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            coordinateSystem: 'radar',\n            legendHoverLink: true,\n            radarIndex: 0,\n            lineStyle: {\n                normal: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            label: {\n                normal: {\n                    position: 'top'\n                }\n            },\n            // areaStyle: {\n            // },\n            // itemStyle: {}\n            symbol: 'emptyCircle',\n            symbolSize: 4\n            // symbolRotate: null\n        }\n    });\n\n    module.exports = RadarSeries;\n\n\n/***/ }),\n/* 389 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var graphic = __webpack_require__(192);\n    var zrUtil = __webpack_require__(190);\n    var symbolUtil = __webpack_require__(219);\n\n    function normalizeSymbolSize(symbolSize) {\n        if (!zrUtil.isArray(symbolSize)) {\n            symbolSize = [+symbolSize, +symbolSize];\n        }\n        return symbolSize;\n    }\n    module.exports = __webpack_require__(191).extendChartView({\n        type: 'radar',\n\n        render: function (seriesModel, ecModel, api) {\n            var polar = seriesModel.coordinateSystem;\n            var group = this.group;\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            function createSymbol(data, idx) {\n                var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n                var color = data.getItemVisual(idx, 'color');\n                if (symbolType === 'none') {\n                    return;\n                }\n                var symbolPath = symbolUtil.createSymbol(\n                    symbolType, -0.5, -0.5, 1, 1, color\n                );\n                symbolPath.attr({\n                    style: {\n                        strokeNoScale: true\n                    },\n                    z2: 100,\n                    scale: normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'))\n                });\n                return symbolPath;\n            }\n\n            function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {\n                // Simply rerender all\n                symbolGroup.removeAll();\n                for (var i = 0; i < newPoints.length - 1; i++) {\n                    var symbolPath = createSymbol(data, idx);\n                    if (symbolPath) {\n                        symbolPath.__dimIdx = i;\n                        if (oldPoints[i]) {\n                            symbolPath.attr('position', oldPoints[i]);\n                            graphic[isInit ? 'initProps' : 'updateProps'](\n                                symbolPath, {\n                                    position: newPoints[i]\n                                }, seriesModel, idx\n                            );\n                        }\n                        else {\n                            symbolPath.attr('position', newPoints[i]);\n                        }\n                        symbolGroup.add(symbolPath);\n                    }\n                }\n            }\n\n            function getInitialPoints(points) {\n                return zrUtil.map(points, function (pt) {\n                    return [polar.cx, polar.cy];\n                });\n            }\n            data.diff(oldData)\n                .add(function (idx) {\n                    var points = data.getItemLayout(idx);\n                    if (!points) {\n                        return;\n                    }\n                    var polygon = new graphic.Polygon();\n                    var polyline = new graphic.Polyline();\n                    var target = {\n                        shape: {\n                            points: points\n                        }\n                    };\n                    polygon.shape.points = getInitialPoints(points);\n                    polyline.shape.points = getInitialPoints(points);\n                    graphic.initProps(polygon, target, seriesModel, idx);\n                    graphic.initProps(polyline, target, seriesModel, idx);\n\n                    var itemGroup = new graphic.Group();\n                    var symbolGroup = new graphic.Group();\n                    itemGroup.add(polyline);\n                    itemGroup.add(polygon);\n                    itemGroup.add(symbolGroup);\n\n                    updateSymbols(\n                        polyline.shape.points, points, symbolGroup, data, idx, true\n                    );\n\n                    data.setItemGraphicEl(idx, itemGroup);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var itemGroup = oldData.getItemGraphicEl(oldIdx);\n                    var polyline = itemGroup.childAt(0);\n                    var polygon = itemGroup.childAt(1);\n                    var symbolGroup = itemGroup.childAt(2);\n                    var target = {\n                        shape: {\n                            points: data.getItemLayout(newIdx)\n                        }\n                    };\n                    if (!target.shape.points) {\n                        return;\n                    }\n                    updateSymbols(\n                        polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false\n                    );\n\n                    graphic.updateProps(polyline, target, seriesModel);\n                    graphic.updateProps(polygon, target, seriesModel);\n\n                    data.setItemGraphicEl(newIdx, itemGroup);\n                })\n                .remove(function (idx) {\n                    group.remove(oldData.getItemGraphicEl(idx));\n                })\n                .execute();\n\n            data.eachItemGraphicEl(function (itemGroup, idx) {\n                var itemModel = data.getItemModel(idx);\n                var polyline = itemGroup.childAt(0);\n                var polygon = itemGroup.childAt(1);\n                var symbolGroup = itemGroup.childAt(2);\n                var color = data.getItemVisual(idx, 'color');\n\n                group.add(itemGroup);\n\n                polyline.useStyle(\n                    zrUtil.defaults(\n                        itemModel.getModel('lineStyle.normal').getLineStyle(),\n                        {\n                            fill: 'none',\n                            stroke: color\n                        }\n                    )\n                );\n                polyline.hoverStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();\n\n                var areaStyleModel = itemModel.getModel('areaStyle.normal');\n                var hoverAreaStyleModel = itemModel.getModel('areaStyle.emphasis');\n                var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();\n                var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();\n\n                hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;\n                polygon.ignore = polygonIgnore;\n\n                polygon.useStyle(\n                    zrUtil.defaults(\n                        areaStyleModel.getAreaStyle(),\n                        {\n                            fill: color,\n                            opacity: 0.7\n                        }\n                    )\n                );\n                polygon.hoverStyle = hoverAreaStyleModel.getAreaStyle();\n\n                var itemStyle = itemModel.getModel('itemStyle.normal').getItemStyle(['color']);\n                var itemHoverStyle = itemModel.getModel('itemStyle.emphasis').getItemStyle();\n                var labelModel = itemModel.getModel('label.normal');\n                var labelHoverModel = itemModel.getModel('label.emphasis');\n                symbolGroup.eachChild(function (symbolPath) {\n                    symbolPath.setStyle(itemStyle);\n                    symbolPath.hoverStyle = zrUtil.clone(itemHoverStyle);\n\n                    var defaultText = data.get(data.dimensions[symbolPath.__dimIdx], idx);\n                    graphic.setText(symbolPath.style, labelModel, color);\n                    symbolPath.setStyle({\n                        text: labelModel.get('show') ? zrUtil.retrieve(\n                            seriesModel.getFormattedLabel(\n                                idx, 'normal', null, symbolPath.__dimIdx\n                            ),\n                            defaultText\n                        ) : ''\n                    });\n\n                    graphic.setText(symbolPath.hoverStyle, labelHoverModel, color);\n                    symbolPath.hoverStyle.text = labelHoverModel.get('show') ? zrUtil.retrieve(\n                        seriesModel.getFormattedLabel(\n                            idx, 'emphasis', null, symbolPath.__dimIdx\n                        ),\n                        defaultText\n                    ) : '';\n                });\n\n                function onEmphasis() {\n                    polygon.attr('ignore', hoverPolygonIgnore);\n                }\n\n                function onNormal() {\n                    polygon.attr('ignore', polygonIgnore);\n                }\n\n                itemGroup.off('mouseover').off('mouseout').off('normal').off('emphasis');\n                itemGroup.on('emphasis', onEmphasis)\n                    .on('mouseover', onEmphasis)\n                    .on('normal', onNormal)\n                    .on('mouseout', onNormal);\n\n                graphic.setHoverStyle(itemGroup);\n            });\n\n            this._data = data;\n        },\n\n        remove: function () {\n            this.group.removeAll();\n            this._data = null;\n        },\n\n        dispose: function () {}\n    });\n\n\n/***/ }),\n/* 390 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Backward compat for radar chart in 2\n\n\n    var zrUtil = __webpack_require__(190);\n\n    module.exports = function (option) {\n        var polarOptArr = option.polar;\n        if (polarOptArr) {\n            if (!zrUtil.isArray(polarOptArr)) {\n                polarOptArr = [polarOptArr];\n            }\n            var polarNotRadar = [];\n            zrUtil.each(polarOptArr, function (polarOpt, idx) {\n                if (polarOpt.indicator) {\n                    if (polarOpt.type && !polarOpt.shape) {\n                        polarOpt.shape = polarOpt.type;\n                    }\n                    option.radar = option.radar || [];\n                    if (!zrUtil.isArray(option.radar)) {\n                        option.radar = [option.radar];\n                    }\n                    option.radar.push(polarOpt);\n                }\n                else {\n                    polarNotRadar.push(polarOpt);\n                }\n            });\n            option.polar = polarNotRadar;\n        }\n        zrUtil.each(option.series, function (seriesOpt) {\n            if (seriesOpt.type === 'radar' && seriesOpt.polarIndex) {\n                seriesOpt.radarIndex = seriesOpt.polarIndex;\n            }\n        });\n    };\n\n\n/***/ }),\n/* 391 */\n/***/ (function(module, exports) {\n\n\n\n    module.exports = function (ecModel) {\n        ecModel.eachSeriesByType('radar', function (seriesModel) {\n            var data = seriesModel.getData();\n            var points = [];\n            var coordSys = seriesModel.coordinateSystem;\n            if (!coordSys) {\n                return;\n            }\n\n            function pointsConverter(val, idx) {\n                points[idx] = points[idx] || [];\n                points[idx][i] = coordSys.dataToPoint(val, i);\n            }\n            for (var i = 0; i < coordSys.getIndicatorAxes().length; i++) {\n                var dim = data.dimensions[i];\n                data.each(dim, pointsConverter);\n            }\n\n            data.each(function (idx) {\n                // Close polygon\n                points[idx][0] && points[idx].push(points[idx][0].slice());\n                data.setItemLayout(idx, points[idx]);\n            });\n        });\n    };\n\n\n/***/ }),\n/* 392 */,\n/* 393 */,\n/* 394 */,\n/* 395 */,\n/* 396 */,\n/* 397 */,\n/* 398 */,\n/* 399 */,\n/* 400 */,\n/* 401 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    __webpack_require__(406);\n    __webpack_require__(407);\n\n    __webpack_require__(402);\n\n\n/***/ }),\n/* 402 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var AxisBuilder = __webpack_require__(229);\n    var zrUtil = __webpack_require__(190);\n    var graphic = __webpack_require__(192);\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n\n    module.exports = __webpack_require__(191).extendComponentView({\n\n        type: 'radar',\n\n        render: function (radarModel, ecModel, api) {\n            var group = this.group;\n            group.removeAll();\n\n            this._buildAxes(radarModel);\n            this._buildSplitLineAndArea(radarModel);\n        },\n\n        _buildAxes: function (radarModel) {\n            var radar = radarModel.coordinateSystem;\n            var indicatorAxes = radar.getIndicatorAxes();\n            var axisBuilders = zrUtil.map(indicatorAxes, function (indicatorAxis) {\n                var axisBuilder = new AxisBuilder(indicatorAxis.model, {\n                    position: [radar.cx, radar.cy],\n                    rotation: indicatorAxis.angle,\n                    labelDirection: -1,\n                    tickDirection: -1,\n                    nameDirection: 1\n                });\n                return axisBuilder;\n            });\n\n            zrUtil.each(axisBuilders, function (axisBuilder) {\n                zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n                this.group.add(axisBuilder.getGroup());\n            }, this);\n        },\n\n        _buildSplitLineAndArea: function (radarModel) {\n            var radar = radarModel.coordinateSystem;\n            var indicatorAxes = radar.getIndicatorAxes();\n            if (!indicatorAxes.length) {\n                return;\n            }\n            var shape = radarModel.get('shape');\n            var splitLineModel = radarModel.getModel('splitLine');\n            var splitAreaModel = radarModel.getModel('splitArea');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n\n            var showSplitLine = splitLineModel.get('show');\n            var showSplitArea = splitAreaModel.get('show');\n            var splitLineColors = lineStyleModel.get('color');\n            var splitAreaColors = areaStyleModel.get('color');\n\n            splitLineColors = zrUtil.isArray(splitLineColors) ? splitLineColors : [splitLineColors];\n            splitAreaColors = zrUtil.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];\n\n            var splitLines = [];\n            var splitAreas = [];\n\n            function getColorIndex(areaOrLine, areaOrLineColorList, idx) {\n                var colorIndex = idx % areaOrLineColorList.length;\n                areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];\n                return colorIndex;\n            }\n\n            if (shape === 'circle') {\n                var ticksRadius = indicatorAxes[0].getTicksCoords();\n                var cx = radar.cx;\n                var cy = radar.cy;\n                for (var i = 0; i < ticksRadius.length; i++) {\n                    if (showSplitLine) {\n                        var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n                        splitLines[colorIndex].push(new graphic.Circle({\n                            shape: {\n                                cx: cx,\n                                cy: cy,\n                                r: ticksRadius[i]\n                            }\n                        }));\n                    }\n                    if (showSplitArea && i < ticksRadius.length - 1) {\n                        var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);\n                        splitAreas[colorIndex].push(new graphic.Ring({\n                            shape: {\n                                cx: cx,\n                                cy: cy,\n                                r0: ticksRadius[i],\n                                r: ticksRadius[i + 1]\n                            }\n                        }));\n                    }\n                }\n            }\n            // Polyyon\n            else {\n                var realSplitNumber;\n                var axesTicksPoints = zrUtil.map(indicatorAxes, function (indicatorAxis, idx) {\n                    var ticksCoords = indicatorAxis.getTicksCoords();\n                    realSplitNumber = realSplitNumber == null\n                        ? ticksCoords.length - 1\n                        : Math.min(ticksCoords.length - 1, realSplitNumber);\n                    return zrUtil.map(ticksCoords, function (tickCoord) {\n                        return radar.coordToPoint(tickCoord, idx);\n                    });\n                });\n\n                var prevPoints = [];\n                for (var i = 0; i <= realSplitNumber; i++) {\n                    var points = [];\n                    for (var j = 0; j < indicatorAxes.length; j++) {\n                        points.push(axesTicksPoints[j][i]);\n                    }\n                    // Close\n                    if (points[0]) {\n                        points.push(points[0].slice());\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.error('Can\\'t draw value axis ' + i);\n                        }\n                    }\n\n                    if (showSplitLine) {\n                        var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n                        splitLines[colorIndex].push(new graphic.Polyline({\n                            shape: {\n                                points: points\n                            }\n                        }));\n                    }\n                    if (showSplitArea && prevPoints) {\n                        var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);\n                        splitAreas[colorIndex].push(new graphic.Polygon({\n                            shape: {\n                                points: points.concat(prevPoints)\n                            }\n                        }));\n                    }\n                    prevPoints = points.slice().reverse();\n                }\n            }\n\n            var lineStyle = lineStyleModel.getLineStyle();\n            var areaStyle = areaStyleModel.getAreaStyle();\n            // Add splitArea before splitLine\n            zrUtil.each(splitAreas, function (splitAreas, idx) {\n                this.group.add(graphic.mergePath(\n                    splitAreas, {\n                        style: zrUtil.defaults({\n                            stroke: 'none',\n                            fill: splitAreaColors[idx % splitAreaColors.length]\n                        }, areaStyle),\n                        silent: true\n                    }\n                ));\n            }, this);\n\n            zrUtil.each(splitLines, function (splitLines, idx) {\n                this.group.add(graphic.mergePath(\n                    splitLines, {\n                        style: zrUtil.defaults({\n                            fill: 'none',\n                            stroke: splitLineColors[idx % splitLineColors.length]\n                        }, lineStyle),\n                        silent: true\n                    }\n                ));\n            }, this);\n\n        }\n    });\n\n\n/***/ }),\n/* 403 */,\n/* 404 */,\n/* 405 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var Axis = __webpack_require__(227);\n\n    function IndicatorAxis(dim, scale, radiusExtent) {\n        Axis.call(this, dim, scale, radiusExtent);\n\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = 'value';\n\n        this.angle = 0;\n\n        /**\n         * Indicator name\n         * @type {string}\n         */\n        this.name = '';\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.model;\n    }\n\n    zrUtil.inherits(IndicatorAxis, Axis);\n\n    module.exports = IndicatorAxis;\n\n\n/***/ }),\n/* 406 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// TODO clockwise\n\n\n    var zrUtil = __webpack_require__(190);\n    var IndicatorAxis = __webpack_require__(405);\n    var IntervalScale = __webpack_require__(222);\n    var numberUtil = __webpack_require__(193);\n    var axisHelper = __webpack_require__(205);\n\n    function Radar(radarModel, ecModel, api) {\n\n        this._model = radarModel;\n        /**\n         * Radar dimensions\n         * @type {Array.<string>}\n         */\n        this.dimensions = [];\n\n        this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {\n            var dim = 'indicator_' + idx;\n            var indicatorAxis = new IndicatorAxis(dim, new IntervalScale());\n            indicatorAxis.name = indicatorModel.get('name');\n            // Inject model and axis\n            indicatorAxis.model = indicatorModel;\n            indicatorModel.axis = indicatorAxis;\n            this.dimensions.push(dim);\n            return indicatorAxis;\n        }, this);\n\n        this.resize(radarModel, api);\n\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.cx;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.cy;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.r;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.startAngle;\n    }\n\n    Radar.prototype.getIndicatorAxes = function () {\n        return this._indicatorAxes;\n    };\n\n    Radar.prototype.dataToPoint = function (value, indicatorIndex) {\n        var indicatorAxis = this._indicatorAxes[indicatorIndex];\n\n        return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);\n    };\n\n    Radar.prototype.coordToPoint = function (coord, indicatorIndex) {\n        var indicatorAxis = this._indicatorAxes[indicatorIndex];\n        var angle = indicatorAxis.angle;\n        var x = this.cx + coord * Math.cos(angle);\n        var y = this.cy - coord * Math.sin(angle);\n        return [x, y];\n    };\n\n    Radar.prototype.pointToData = function (pt) {\n        var dx = pt[0] - this.cx;\n        var dy = pt[1] - this.cy;\n        var radius = Math.sqrt(dx * dx + dy * dy);\n        dx /= radius;\n        dy /= radius;\n\n        var radian = Math.atan2(-dy, dx);\n\n        // Find the closest angle\n        // FIXME index can calculated directly\n        var minRadianDiff = Infinity;\n        var closestAxis;\n        var closestAxisIdx = -1;\n        for (var i = 0; i < this._indicatorAxes.length; i++) {\n            var indicatorAxis = this._indicatorAxes[i];\n            var diff = Math.abs(radian - indicatorAxis.angle);\n            if (diff < minRadianDiff) {\n                closestAxis = indicatorAxis;\n                closestAxisIdx = i;\n                minRadianDiff = diff;\n            }\n        }\n\n        return [closestAxisIdx, +(closestAxis && closestAxis.coodToData(radius))];\n    };\n\n    Radar.prototype.resize = function (radarModel, api) {\n        var center = radarModel.get('center');\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n        var viewSize = Math.min(viewWidth, viewHeight) / 2;\n        this.cx = numberUtil.parsePercent(center[0], viewWidth);\n        this.cy = numberUtil.parsePercent(center[1], viewHeight);\n\n        this.startAngle = radarModel.get('startAngle') * Math.PI / 180;\n\n        this.r = numberUtil.parsePercent(radarModel.get('radius'), viewSize);\n\n        zrUtil.each(this._indicatorAxes, function (indicatorAxis, idx) {\n            indicatorAxis.setExtent(0, this.r);\n            var angle = (this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length);\n            // Normalize to [-PI, PI]\n            angle = Math.atan2(Math.sin(angle), Math.cos(angle));\n            indicatorAxis.angle = angle;\n        }, this);\n    };\n\n    Radar.prototype.update = function (ecModel, api) {\n        var indicatorAxes = this._indicatorAxes;\n        var radarModel = this._model;\n        zrUtil.each(indicatorAxes, function (indicatorAxis) {\n            indicatorAxis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeriesByType('radar', function (radarSeries, idx) {\n            if (radarSeries.get('coordinateSystem') !== 'radar'\n                || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel\n            ) {\n                return;\n            }\n            var data = radarSeries.getData();\n            zrUtil.each(indicatorAxes, function (indicatorAxis) {\n                indicatorAxis.scale.unionExtentFromData(data, indicatorAxis.dim);\n            });\n        }, this);\n\n        var splitNumber = radarModel.get('splitNumber');\n\n        function increaseInterval(interval) {\n            var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10));\n            // Increase interval\n            var f = interval / exp10;\n            if (f === 2) {\n                f = 5;\n            }\n            else { // f is 2 or 5\n                f *= 2;\n            }\n            return f * exp10;\n        }\n        // Force all the axis fixing the maxSplitNumber.\n        zrUtil.each(indicatorAxes, function (indicatorAxis, idx) {\n            var rawExtent = axisHelper.getScaleExtent(indicatorAxis.scale, indicatorAxis.model);\n            axisHelper.niceScaleExtent(indicatorAxis.scale, indicatorAxis.model);\n\n            var axisModel = indicatorAxis.model;\n            var scale = indicatorAxis.scale;\n            var fixedMin = axisModel.getMin();\n            var fixedMax = axisModel.getMax();\n            var interval = scale.getInterval();\n\n            if (fixedMin != null && fixedMax != null) {\n                // User set min, max, divide to get new interval\n                scale.setExtent(+fixedMin, +fixedMax);\n                scale.setInterval(\n                    (fixedMax - fixedMin) / splitNumber\n                );\n            }\n            else if (fixedMin != null) {\n                var max;\n                // User set min, expand extent on the other side\n                do {\n                    max = fixedMin + interval * splitNumber;\n                    scale.setExtent(+fixedMin, max);\n                    // Interval must been set after extent\n                    // FIXME\n                    scale.setInterval(interval);\n\n                    interval = increaseInterval(interval);\n                } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));\n            }\n            else if (fixedMax != null) {\n                var min;\n                // User set min, expand extent on the other side\n                do {\n                    min = fixedMax - interval * splitNumber;\n                    scale.setExtent(min, +fixedMax);\n                    scale.setInterval(interval);\n                    interval = increaseInterval(interval);\n                } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));\n            }\n            else {\n                var nicedSplitNumber = scale.getTicks().length - 1;\n                if (nicedSplitNumber > splitNumber) {\n                    interval = increaseInterval(interval);\n                }\n                // PENDING\n                var center = Math.round((rawExtent[0] + rawExtent[1]) / 2 / interval) * interval;\n                var halfSplitNumber = Math.round(splitNumber / 2);\n                scale.setExtent(\n                    numberUtil.round(center - halfSplitNumber * interval),\n                    numberUtil.round(center + (splitNumber - halfSplitNumber) * interval)\n                );\n                scale.setInterval(interval);\n            }\n        });\n    };\n\n    /**\n     * Radar dimensions is based on the data\n     * @type {Array}\n     */\n    Radar.dimensions = [];\n\n    Radar.create = function (ecModel, api) {\n        var radarList = [];\n        ecModel.eachComponent('radar', function (radarModel) {\n            var radar = new Radar(radarModel, ecModel, api);\n            radarList.push(radar);\n            radarModel.coordinateSystem = radar;\n        });\n        ecModel.eachSeriesByType('radar', function (radarSeries) {\n            if (radarSeries.get('coordinateSystem') === 'radar') {\n                // Inject coordinate system\n                radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];\n            }\n        });\n        return radarList;\n    };\n\n    __webpack_require__(216).register('radar', Radar);\n    module.exports = Radar;\n\n\n/***/ }),\n/* 407 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n\n    var axisDefault = __webpack_require__(315);\n    var valueAxisDefault = axisDefault.valueAxis;\n    var Model = __webpack_require__(199);\n    var zrUtil = __webpack_require__(190);\n\n    var axisModelCommonMixin = __webpack_require__(230);\n\n    function defaultsShow(opt, show) {\n        return zrUtil.defaults({\n            show: show\n        }, opt);\n    }\n\n    var RadarModel = __webpack_require__(191).extendComponentModel({\n\n        type: 'radar',\n\n        optionUpdated: function () {\n            var boundaryGap = this.get('boundaryGap');\n            var splitNumber = this.get('splitNumber');\n            var scale = this.get('scale');\n            var axisLine = this.get('axisLine');\n            var axisTick = this.get('axisTick');\n            var axisLabel = this.get('axisLabel');\n            var nameTextStyle = this.get('name.textStyle');\n            var showName = this.get('name.show');\n            var nameFormatter = this.get('name.formatter');\n            var nameGap = this.get('nameGap');\n            var triggerEvent = this.get('triggerEvent');\n\n            var indicatorModels = zrUtil.map(this.get('indicator') || [], function (indicatorOpt) {\n                // PENDING\n                if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {\n                    indicatorOpt.min = 0;\n                }\n                else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {\n                    indicatorOpt.max = 0;\n                }\n                // Use same configuration\n                indicatorOpt = zrUtil.merge(zrUtil.clone(indicatorOpt), {\n                    boundaryGap: boundaryGap,\n                    splitNumber: splitNumber,\n                    scale: scale,\n                    axisLine: axisLine,\n                    axisTick: axisTick,\n                    axisLabel: axisLabel,\n                    // Competitable with 2 and use text\n                    name: indicatorOpt.text,\n                    nameLocation: 'end',\n                    nameGap: nameGap,\n                    // min: 0,\n                    nameTextStyle: nameTextStyle,\n                    triggerEvent: triggerEvent\n                }, false);\n                if (!showName) {\n                    indicatorOpt.name = '';\n                }\n                if (typeof nameFormatter === 'string') {\n                    var indName = indicatorOpt.name;\n                    indicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : '');\n                }\n                else if (typeof nameFormatter === 'function') {\n                    indicatorOpt.name = nameFormatter(\n                        indicatorOpt.name, indicatorOpt\n                    );\n                }\n                var model = zrUtil.extend(\n                    new Model(indicatorOpt, null, this.ecModel),\n                    axisModelCommonMixin\n                );\n\n                // For triggerEvent.\n                model.mainType = 'radar';\n                model.componentIndex = this.componentIndex;\n\n                return model;\n            }, this);\n\n            this.getIndicatorModels = function () {\n                return indicatorModels;\n            };\n        },\n\n        defaultOption: {\n\n            zlevel: 0,\n\n            z: 0,\n\n            center: ['50%', '50%'],\n\n            radius: '75%',\n\n            startAngle: 90,\n\n            name: {\n                show: true\n                // formatter: null\n                // textStyle: {}\n            },\n\n            boundaryGap: [0, 0],\n\n            splitNumber: 5,\n\n            nameGap: 15,\n\n            scale: false,\n\n            // Polygon or circle\n            shape: 'polygon',\n\n            axisLine: zrUtil.merge(\n                {\n                    lineStyle: {\n                        color: '#bbb'\n                    }\n                },\n                valueAxisDefault.axisLine\n            ),\n            axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),\n            axisTick: defaultsShow(valueAxisDefault.axisTick, false),\n            splitLine: defaultsShow(valueAxisDefault.splitLine, true),\n            splitArea: defaultsShow(valueAxisDefault.splitArea, true),\n\n            // {text, min, max}\n            indicator: []\n        }\n    });\n\n    module.exports = RadarModel;\n\n\n/***/ })\n]));\n\n\n// WEBPACK FOOTER //\n// static/js/RadarReact.7a0aebeb.chunk.js","/**\n * Created by yongyuehuang on 2017/8/5.\n */\nimport React from 'react'\nimport echarts from 'echarts/lib/echarts' //\nimport 'echarts/lib/chart/radar' //\n\nexport default class RadarReact extends React.Component {\n  \n  constructor(props) {\n    super(props)\n    this.initPie = this.initPie.bind(this)\n  }\n  \n  initPie() {\n    const { option={} } = this.props //data\n    let myChart = echarts.init(this.ID) //echarts\n    \n    //options\n    myChart.setOption(option)\n    window.onresize = function() {\n      myChart.resize()\n    }\n  }\n  \n  componentDidMount() {\n    this.initPie()\n  }\n  \n  componentDidUpdate() {\n    this.initPie()\n  }\n  \n  render() {\n    const { width=\"100%\", height=\"400px\" } = this.props\n    return <div ref={ID => this.ID = ID} style={{width, height}}></div>\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/EchartsDemo/RadarReact.js","/**\n * @module zrender/core/util\n */\n\n\n    // mergeDate\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuiltInObject(sourceProp)\n                    && !isBuiltInObject(targetProp)\n                    && !isPrimitive(sourceProp)\n                    && !isPrimitive(targetProp)\n                ) {\n                    // merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // overwritetrue\n                    // NOTE target[key] \n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * \n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz \n     * @param {Function} baseClazz \n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * Consider typed array.\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuiltInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * Whether is exactly NaN. Notice isNaN('a') returns true.\n     * @param {*} value\n     * @return {boolean}\n     */\n    function eqNaN(value) {\n        return value !== value;\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var primitiveKey = '__ec_primitive__';\n    /**\n     * Set an object as primitive to be ignored traversing children in clone or merge\n     */\n    function setAsPrimitive(obj) {\n        obj[primitiveKey] = true;\n    }\n\n    function isPrimitive(obj) {\n        return obj[primitiveKey];\n    }\n\n    /**\n     * @constructor\n     * @param {Object} obj Only apply `ownProperty`.\n     */\n    function HashMap(obj) {\n        obj && each(obj, function (value, key) {\n            this.set(key, value);\n        }, this);\n    }\n\n    // Add prefix to avoid conflict with Object.prototype.\n    var HASH_MAP_PREFIX = '_ec_';\n    var HASH_MAP_PREFIX_LENGTH = 4;\n\n    HashMap.prototype = {\n        constructor: HashMap,\n        // Do not provide `has` method to avoid defining what is `has`.\n        // (We usually treat `null` and `undefined` as the same, different\n        // from ES6 Map).\n        get: function (key) {\n            return this[HASH_MAP_PREFIX + key];\n        },\n        set: function (key, value) {\n            this[HASH_MAP_PREFIX + key] = value;\n            // Comparing with invocation chaining, `return value` is more commonly\n            // used in this case: `var someVal = map.set('a', genVal());`\n            return value;\n        },\n        // Although util.each can be performed on this hashMap directly, user\n        // should not use the exposed keys, who are prefixed.\n        each: function (cb, context) {\n            context !== void 0 && (cb = bind(cb, context));\n            for (var prefixedKey in this) {\n                this.hasOwnProperty(prefixedKey)\n                    && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n            }\n        },\n        // Do not use this method if performance sensitive.\n        removeKey: function (key) {\n            delete this[key];\n        }\n    };\n\n    function createHashMap(obj) {\n        return new HashMap(obj);\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuiltInObject: isBuiltInObject,\n        isDom: isDom,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        assert: assert,\n        setAsPrimitive: setAsPrimitive,\n        createHashMap: createHashMap,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/util.js\n// module id = 190\n// module chunks = 0 1 2 3 4 5 6","// Enable DEV mode when using source code without build. which has no __DEV__ variable\n// In build process 'typeof __DEV__' will be replace with 'boolean'\n// So this code will be removed or disabled anyway after built.\nif (typeof __DEV__ === 'undefined') {\n    // In browser\n    if (typeof window !== 'undefined') {\n        window.__DEV__ = true;\n    }\n    // In node\n    else if (typeof global !== 'undefined') {\n        global.__DEV__ = true;\n    }\n}\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\n/**\n * @module echarts\n */\n\n\n    var env = require('zrender/lib/core/env');\n\n    var GlobalModel = require('./model/Global');\n    var ExtensionAPI = require('./ExtensionAPI');\n    var CoordinateSystemManager = require('./CoordinateSystem');\n    var OptionManager = require('./model/OptionManager');\n\n    var ComponentModel = require('./model/Component');\n    var SeriesModel = require('./model/Series');\n\n    var ComponentView = require('./view/Component');\n    var ChartView = require('./view/Chart');\n    var graphic = require('./util/graphic');\n    var modelUtil = require('./util/model');\n    var throttle = require('./util/throttle');\n\n    var zrender = require('zrender');\n    var zrUtil = require('zrender/lib/core/util');\n    var colorTool = require('zrender/lib/tool/color');\n    var Eventful = require('zrender/lib/mixin/Eventful');\n    var timsort = require('zrender/lib/core/timsort');\n\n    var each = zrUtil.each;\n    var parseClassType = ComponentModel.parseClassType;\n\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\n\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    // FIXME\n    // necessary?\n    var PRIORITY_VISUAL_BRUSH = 5000;\n\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flagInMainProcess';\n    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\n    var OPTION_UPDATED = '__optionUpdated';\n    var ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts(dom, theme, opts) {\n        opts = opts || {};\n\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        var zr = this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height\n        });\n\n        /**\n         * Expect 60 pfs.\n         * @type {Function}\n         * @private\n         */\n        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = createExtensionAPI(this);\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n\n        // Init mouse events\n        this._initEvents();\n\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n\n        zr.animation.on('frame', this._onframe, this);\n\n        // ECharts instance can be used as value.\n        zrUtil.setAsPrimitive(this);\n    }\n\n    var echartsProto = ECharts.prototype;\n\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            var silent = this[OPTION_UPDATED].silent;\n\n            this[IN_MAIN_PROCESS] = true;\n\n            updateMethods.prepareAndUpdate.call(this);\n\n            this[IN_MAIN_PROCESS] = false;\n\n            this[OPTION_UPDATED] = false;\n\n            flushPendingActions.call(this, silent);\n\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n\n    /**\n     * Usage:\n     * chart.setOption(option, notMerge, lazyUpdate);\n     * chart.setOption(option, {\n     *     notMerge: ...,\n     *     lazyUpdate: ...,\n     *     silent: ...\n     * });\n     *\n     * @param {Object} option\n     * @param {Object|boolean} [opts] opts or notMerge.\n     * @param {boolean} [opts.notMerge=false]\n     * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n\n        var silent;\n        if (zrUtil.isObject(notMerge)) {\n            lazyUpdate = notMerge.lazyUpdate;\n            silent = notMerge.silent;\n            notMerge = notMerge.notMerge;\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n\n        this._model.setOption(option, optionPreprocessorFuncs);\n\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = {silent: silent};\n            this[IN_MAIN_PROCESS] = false;\n        }\n        else {\n            updateMethods.prepareAndUpdate.call(this);\n            // Ensure zr refresh sychronously, and then pixel in canvas can be\n            // fetched after `setOption`.\n            this._zr.flush();\n\n            this[OPTION_UPDATED] = false;\n            this[IN_MAIN_PROCESS] = false;\n\n            flushPendingActions.call(this, silent);\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getDevicePixelRatio = function () {\n        return this._zr.painter.dpr || window.devicePixelRatio || 1;\n    };\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     * @param {string} [opts.excludeComponents]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({\n                mainType: componentType\n            }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n\n        var url = this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n\n\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = (opts && opts.pixelRatio) || 1;\n\n            zrUtil.each(instances, function (chart, id) {\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(\n                        zrUtil.clone(opts)\n                    );\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            });\n\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                    style: {\n                        x: item.left * dpr - left,\n                        y: item.top * dpr - top,\n                        image: item.dom\n                    }\n                });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        }\n        else {\n            return this.getDataURL(opts);\n        }\n    };\n\n    /**\n     * Convert from logical coordinate system to pixel coordinate system.\n     * See CoordinateSystem#convertToPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId, geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\n    /**\n     * Convert from pixel coordinate system to logical coordinate system.\n     * See CoordinateSystem#convertFromPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\n    function doConvertPixel(methodName, finder, value) {\n        var ecModel = this._model;\n        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n            if (coordSys[methodName]\n                && (result = coordSys[methodName](ecModel, finder, value)) != null\n            ) {\n                return result;\n            }\n        }\n\n        if (__DEV__) {\n            console.warn(\n                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n            );\n        }\n    }\n\n    /**\n     * Is the specified coordinate systems or components contain the given pixel point.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {boolean} result\n     */\n    echartsProto.containPixel = function (finder, value) {\n        var ecModel = this._model;\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        zrUtil.each(finder, function (models, key) {\n            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n                var coordSys = model.coordinateSystem;\n                if (coordSys && coordSys.containPoint) {\n                    result |= !!coordSys.containPoint(value);\n                }\n                else if (key === 'seriesModels') {\n                    var view = this._chartsMap[model.__viewId];\n                    if (view && view.containPoint) {\n                        result |= view.containPoint(value, model);\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.warn(key + ': ' + (view\n                                ? 'The found component do not support containPoint.'\n                                : 'No view mapping to the found component.'\n                            ));\n                        }\n                    }\n                }\n                else {\n                    if (__DEV__) {\n                        console.warn(key + ': containPoint is not supported');\n                    }\n                }\n            }, this);\n        }, this);\n\n        return !!result;\n    };\n\n    /**\n     * Get visual from series or data.\n     * @param {string|Object} finder\n     *        If string, e.g., 'series', means {seriesIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            dataIndex / dataIndexInside\n     *        }\n     *        If dataIndex is not specified, series visual will be fetched,\n     *        but not data item visual.\n     *        If all of seriesIndex, seriesId, seriesName are not specified,\n     *        visual will be fetched from first series.\n     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n     */\n    echartsProto.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n\n        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n        var seriesModel = finder.seriesModel;\n\n        if (__DEV__) {\n            if (!seriesModel) {\n                console.warn('There is no specified seires model');\n            }\n        }\n\n        var data = seriesModel.getData();\n\n        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n            ? finder.dataIndexInside\n            : finder.hasOwnProperty('dataIndex')\n            ? data.indexOfRawIndex(finder.dataIndex)\n            : null;\n\n        return dataIndexInside != null\n            ? data.getItemVisual(dataIndexInside, visualType)\n            : data.getVisual(visualType);\n    };\n\n    /**\n     * Get view of corresponding component model\n     * @param  {module:echarts/model/Component} componentModel\n     * @return {module:echarts/view/Component}\n     */\n    echartsProto.getViewOfComponentModel = function (componentModel) {\n        return this._componentsMap[componentModel.__viewId];\n    };\n\n    /**\n     * Get view of corresponding series model\n     * @param  {module:echarts/model/Series} seriesModel\n     * @return {module:echarts/view/Chart}\n     */\n    echartsProto.getViewOfSeriesModel = function (seriesModel) {\n        return this._chartsMap[seriesModel.__viewId];\n    };\n\n\n    var updateMethods = {\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        update: function (payload) {\n            // console.profile && console.profile('update');\n\n            var ecModel = this._model;\n            var api = this._api;\n            var coordSysMgr = this._coordSysMgr;\n            var zr = this._zr;\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            // Fixme First time update ?\n            ecModel.restoreData();\n\n            // TODO\n            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n            // Create new coordinate system each update\n            // In LineView may save the old coordinate system and use it to get the orignal point\n            coordSysMgr.create(this._model, this._api);\n\n            processData.call(this, ecModel, api);\n\n            stackSeriesData.call(this, ecModel);\n\n            coordSysMgr.update(ecModel, api);\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            doRender.call(this, ecModel, payload);\n\n            // Set background\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n            var painter = zr.painter;\n            // TODO all use clearColor ?\n            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n            }\n            else {\n                // In IE8\n                if (!env.canvasSupported) {\n                    var colorArr = colorTool.parse(backgroundColor);\n                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                    if (colorArr[3] === 0) {\n                        backgroundColor = 'transparent';\n                    }\n                }\n                if (backgroundColor.colorStops || backgroundColor.image) {\n                    // Gradient background\n                    // FIXME Fixed layer\n                    zr.configLayer(0, {\n                        clearColor: backgroundColor\n                    });\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                    this._dom.style.background = 'transparent';\n                }\n                else {\n                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                        zr.configLayer(0, {\n                            clearColor: null\n                        });\n                    }\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                    this._dom.style.background = backgroundColor;\n                }\n            }\n\n            each(postUpdateFuncs, function (func) {\n                func(ecModel, api);\n            });\n\n            // console.profile && console.profileEnd('update');\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateView: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateVisual: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload, true);\n\n            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateLayout: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            doLayout.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        prepareAndUpdate: function (payload) {\n            var ecModel = this._model;\n\n            prepareView.call(this, 'component', ecModel);\n\n            prepareView.call(this, 'chart', ecModel);\n\n            updateMethods.update.call(this, payload);\n        }\n    };\n\n    /**\n     * @private\n     */\n    function updateDirectly(ecIns, method, payload, mainType, subType) {\n        var ecModel = ecIns._model;\n\n        // broadcast\n        if (!mainType) {\n            each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);\n            return;\n        }\n\n        var query = {};\n        query[mainType + 'Id'] = payload[mainType + 'Id'];\n        query[mainType + 'Index'] = payload[mainType + 'Index'];\n        query[mainType + 'Name'] = payload[mainType + 'Name'];\n\n        var condition = {mainType: mainType, query: query};\n        subType && (condition.subType = subType); // subType may be '' by parseClassType;\n\n        // If dispatchAction before setOption, do nothing.\n        ecModel && ecModel.eachComponent(condition, function (model, index) {\n            callView(ecIns[\n                mainType === 'series' ? '_chartsMap' : '_componentsMap'\n            ][model.__viewId]);\n        }, ecIns);\n\n        function callView(view) {\n            view && view.__alive && view[method] && view[method](\n                view.__model, ecModel, ecIns._api, payload\n            );\n        }\n    }\n\n    /**\n     * Resize the chart\n     * @param {Object} opts\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @param {boolean} [opts.silent=false]\n     */\n    echartsProto.resize = function (opts) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        this._zr.resize(opts);\n\n        var optionChanged = this._model && this._model.resetOption('media');\n        var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n\n        updateMethods[updateMethod].call(this);\n\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n\n        this[IN_MAIN_PROCESS] = false;\n\n        var silent = opts && opts.silent;\n\n        flushPendingActions.call(this, silent);\n\n        triggerUpdatedEvent.call(this, silent);\n    };\n\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (__DEV__) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n\n        zr.add(el);\n    };\n\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n     * @param {boolean} [opt.silent=false] Whether trigger events.\n     * @param {boolean} [opt.flush=undefined]\n     *                  true: Flush immediately, and then pixel in canvas can be fetched\n     *                      immediately. Caution: it might affect performance.\n     *                  false: Not not flush.\n     *                  undefined: Auto decide whether perform flush.\n     */\n    echartsProto.dispatchAction = function (payload, opt) {\n        if (!zrUtil.isObject(opt)) {\n            opt = {silent: !!opt};\n        }\n\n        if (!actions[payload.type]) {\n            return;\n        }\n\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n\n        doDispatchAction.call(this, payload, opt.silent);\n\n        if (opt.flush) {\n            this._zr.flush(true);\n        }\n        else if (opt.flush !== false && env.browser.weChat) {\n            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n            // hang when sliding page (on touch event), which cause that zr does not\n            // refresh util user interaction finished, which is not expected.\n            // But `dispatchAction` may be called too frequently when pan on touch\n            // screen, which impacts performance if do not throttle them.\n            this._throttledZrFlush();\n        }\n\n        flushPendingActions.call(this, opt.silent);\n\n        triggerUpdatedEvent.call(this, opt.silent);\n    };\n\n    function doDispatchAction(payload, silent) {\n        var payloadType = payload.type;\n        var escapeConnect = payload.escapeConnect;\n        var actionWrap = actions[payloadType];\n        var actionInfo = actionWrap.actionInfo;\n\n        var cptType = (actionInfo.update || 'update').split(':');\n        var updateMethod = cptType.pop();\n        cptType = cptType[0] != null && parseClassType(cptType[0]);\n\n        this[IN_MAIN_PROCESS] = true;\n\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n\n        each(payloads, function (batchItem) {\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model, this._api);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            // light update does not perform data process, layout and visual.\n            if (isHighDown) {\n                // method, payload, mainType, subType\n                updateDirectly(this, updateMethod, batchItem, 'series');\n            }\n            else if (cptType) {\n                updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n            }\n        }, this);\n\n        if (updateMethod !== 'none' && !isHighDown && !cptType) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            }\n            else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payloadType,\n                escapeConnect: escapeConnect,\n                batch: eventObjBatch\n            };\n        }\n        else {\n            eventObj = eventObjBatch[0];\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n    }\n\n    function flushPendingActions(silent) {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            doDispatchAction.call(this, payload, silent);\n        }\n    }\n\n    function triggerUpdatedEvent(silent) {\n        !silent && this.trigger('updated');\n    }\n\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, component);\n        }, this);\n\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n\n            updateZ(seriesModel, chart);\n\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Post render\n        each(postUpdateFuncs, function (func) {\n            func(ecModel, api);\n        });\n    }\n\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            }\n            else {\n                model = componentType;\n            }\n\n            // Consider: id same and type changed.\n            var viewId = '_ec_' + model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = parseClassType(model.type);\n                var Clazz = isComponent\n                    ? ComponentView.getClass(classType.main, classType.sub)\n                    : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                }\n                else {\n                    // Error\n                    return;\n                }\n            }\n\n            model.__viewId = view.__id = viewId;\n            view.__alive = true;\n            view.__model = model;\n            view.group.__ecComponentInfo = {\n                mainType: model.mainType,\n                index: model.componentIndex\n            };\n        }, this);\n\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n                view.__id = view.group.__ecComponentInfo = null;\n            }\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                // Avoid conflict with Object.prototype\n                if (stackedDataMap.hasOwnProperty(stack) && previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @param {object} layout\n     * @param {boolean} [excludesLayout]\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload, excludesLayout) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            (!excludesLayout || !visual.isLayout)\n                && visual.func(ecModel, api, payload);\n        });\n    }\n\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, componentView);\n        }, this);\n\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n\n            chartView.group.silent = !!seriesModel.get('silent');\n\n            updateZ(seriesModel, chartView);\n\n            updateProgressiveAndBlend(seriesModel, chartView);\n\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n\n    var MOUSE_EVENT_NAMES = [\n        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n    ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                var params;\n\n                // no e.target when 'globalout'.\n                if (eveName === 'globalout') {\n                    params = {};\n                }\n                else if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                }\n                // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    params = zrUtil.extend({}, el.eventData);\n                }\n\n                if (params) {\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }\n\n            }, this);\n        }, this);\n\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (__DEV__) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n\n        var api = this._api;\n        var ecModel = this._model;\n\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n\n        // Dispose after all views disposed\n        this._zr.dispose();\n\n        delete instances[this.id];\n    };\n\n    zrUtil.mixin(ECharts, Eventful);\n\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ?\n                        Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (__DEV__) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n\n    function createExtensionAPI(ecInstance) {\n        var coordSysMgr = ecInstance._coordSysMgr;\n        return zrUtil.extend(new ExtensionAPI(ecInstance), {\n            // Inject methods\n            getCoordinateSystems: zrUtil.bind(\n                coordSysMgr.getCoordinateSystems, coordSysMgr\n            ),\n            getComponentByElement: function (el) {\n                while (el) {\n                    var modelInfo = el.__ecComponentInfo;\n                    if (modelInfo != null) {\n                        return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);\n                    }\n                    el = el.parent;\n                }\n            }\n        });\n    }\n\n    /**\n     * @type {Object} key: actionType.\n     * @inner\n     */\n    var actions = {};\n\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var postUpdateFuncs = [];\n\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n\n\n    var instances = {};\n    var connectedGroups = {};\n\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n        /**\n         * @type {number}\n         */\n        version: '3.6.2',\n        dependencies: {\n            zrender: '3.5.2'\n        }\n    };\n\n    function enableConnect(chart) {\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    if (event && event.escapeConnect) {\n                        return;\n                    }\n\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n\n                    zrUtil.each(instances, function (otherChart) {\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    });\n\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n    }\n\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n     *                              Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n     *                               Can be 'auto' (the same as null/undefined)\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (__DEV__) {\n            // Check version\n            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n                throw new Error(\n                    'ZRender ' + zrender.version\n                    + ' is too old for ECharts ' + echarts.version\n                    + '. Current version need ZRender '\n                    + echarts.dependencies.zrender + '+'\n                );\n            }\n\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n        }\n\n        var existInstance = echarts.getInstanceByDom(dom);\n        if (existInstance) {\n            if (__DEV__) {\n                console.warn('There is a chart instance already initialized on the dom.');\n            }\n            return existInstance;\n        }\n\n        if (__DEV__) {\n            if (zrUtil.isDom(dom)\n                && dom.nodeName.toUpperCase() !== 'CANVAS'\n                && (\n                    (!dom.clientWidth && (!opts || opts.width == null))\n                    || (!dom.clientHeight && (!opts || opts.height == null))\n                )\n            ) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n\n        if (dom.setAttribute) {\n            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n        }\n        else {\n            dom[DOM_ATTRIBUTE_KEY] = chart.id;\n        }\n\n        enableConnect(chart);\n\n        return chart;\n    };\n\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || ('g_' + groupIdBase++);\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n\n    /**\n     * @DEPRECATED\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n\n    /**\n     * @return {string} groupId\n     */\n    echarts.disconnect = echarts.disConnect;\n\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        else if (!(chart instanceof ECharts)){\n            // Try to treat as dom\n            chart = echarts.getInstanceByDom(chart);\n        }\n        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key;\n        if (dom.getAttribute) {\n            key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        }\n        else {\n            key = dom[DOM_ATTRIBUTE_KEY];\n        }\n        return instances[key];\n    };\n\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n\n    /**\n     * Register postUpdater\n     * @param {Function} postUpdateFunc\n     */\n    echarts.registerPostUpdate = function (postUpdateFunc) {\n        postUpdateFuncs.push(postUpdateFunc);\n    };\n\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo)\n            ? actionInfo.type\n            : ([actionInfo, actionInfo = {\n                event: eventName\n            }][0]);\n\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n\n        // Validate action type and event name.\n        zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n        if (!actions[actionType]) {\n            actions[actionType] = {action: action, actionInfo: actionInfo};\n        }\n        eventActionMap[eventName] = actionType;\n    };\n\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n\n    /**\n     * Get dimensions of specified coordinate system.\n     * @param {string} type\n     * @return {Array.<string|Object>}\n     */\n    echarts.getCoordinateSystemDimensions = function (type) {\n        var coordSysCreator = CoordinateSystemManager.get(type);\n        if (coordSysCreator) {\n            return coordSysCreator.getDimensionsInfo\n                    ? coordSysCreator.getDimensionsInfo()\n                    : coordSysCreator.dimensions.slice();\n        }\n    };\n\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts/*, superClass*/) {\n        // var Clazz = ComponentModel;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts/*, superClass*/) {\n        // var Clazz = ComponentView;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentView.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts/*, superClass*/) {\n        // var Clazz = SeriesModel;\n        // if (superClass) {\n        //     superClass = 'series.' + superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return SeriesModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts/*, superClass*/) {\n        // var Clazz = ChartView;\n        // if (superClass) {\n        //     superClass = superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ChartView.getClass(classType.main, true);\n        // }\n        return ChartView.extend(opts);\n    };\n\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n    echarts.registerPreprocessor(require('./preprocessor/backwardCompat'));\n    echarts.registerLoading('default', require('./loading/default'));\n\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n\n\n    // --------\n    // Exports\n    // --------\n    echarts.zrender = zrender;\n\n    echarts.List = require('./data/List');\n    echarts.Model = require('./model/Model');\n\n    echarts.Axis = require('./coord/Axis');\n\n    echarts.graphic = require('./util/graphic');\n    echarts.number = require('./util/number');\n    echarts.format = require('./util/format');\n    echarts.throttle = throttle.throttle;\n    echarts.matrix = require('zrender/lib/core/matrix');\n    echarts.vector = require('zrender/lib/core/vector');\n    echarts.color = require('zrender/lib/tool/color');\n\n    echarts.util = {};\n    each([\n            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n            'extend', 'defaults', 'clone', 'merge'\n        ],\n        function (name) {\n            echarts.util[name] = zrUtil[name];\n        }\n    );\n\n    echarts.helper = require('./helper');\n\n\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n\n    module.exports = echarts;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/echarts.js\n// module id = 191\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var pathTool = require('zrender/lib/tool/path');\n    var Path = require('zrender/lib/graphic/Path');\n    var colorTool = require('zrender/lib/tool/color');\n    var matrix = require('zrender/lib/core/matrix');\n    var vector = require('zrender/lib/core/vector');\n    var Transformable = require('zrender/lib/mixin/Transformable');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    var round = Math.round;\n    var mathMax = Math.max;\n    var mathMin = Math.min;\n\n    var graphic = {};\n\n    graphic.Group = require('zrender/lib/container/Group');\n\n    graphic.Image = require('zrender/lib/graphic/Image');\n\n    graphic.Text = require('zrender/lib/graphic/Text');\n\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\n\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\n\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\n\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\n\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\n\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\n\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\n\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\n\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\n\n    graphic.CompoundPath = require('zrender/lib/graphic/CompoundPath');\n\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\n\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\n\n    graphic.BoundingRect = BoundingRect;\n\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                }\n                else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n\n            graphic.resizePath(path, rect);\n        }\n        return path;\n    };\n\n    graphic.mergePath = pathTool.mergePath,\n\n    /**\n     * Resize a path to fit the rect\n     * @param {module:zrender/graphic/Path} path\n     * @param {Object} rect\n     */\n    graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n\n        var pathRect = path.getBoundingRect();\n\n        var m = pathRect.calculateTransform(rect);\n\n        path.applyTransform(m);\n    };\n\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n            originWidth === 0 ? 0 : 1\n        );\n        shape.height = Math.max(\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n            originHeight === 0 ? 0 : 1\n        );\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill\n                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke\n                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n\n            el.__normalStl = normalStyle;\n\n            el.__hoverStlDirty = false;\n        }\n    }\n\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n\n        cacheElementStl(el);\n\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        }\n        else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n\n        el.__isHover = true;\n    }\n\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        }\n        else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n\n        el.__isHover = false;\n    }\n\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleEnterHover(child);\n                }\n            })\n            : doSingleEnterHover(el);\n    }\n\n    function doLeaveHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleLeaveHover(child);\n                }\n            })\n            : doSingleLeaveHover(el);\n    }\n\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOver(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOut(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n\n    /**\n     * Set hover style of element.\n     * This method can be called repeatly without side-effects.\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     * @param {Object} [opt]\n     * @param {boolean} [opt.hoverSilentOnTouch=false]\n     *        In touch device, mouseover event will be trigger on touchstart event\n     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n     *        conviniently use hoverStyle when tap on touch screen without additional\n     *        code for compatibility.\n     *        But if the chart/component has select feature, which usually also use\n     *        hoverStyle, there might be conflict between 'select-highlight' and\n     *        'hover-highlight' especially when roam is enabled (see geo for example).\n     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n     *        on touch device.\n     */\n    graphic.setHoverStyle = function (el, hoverStyle, opt) {\n        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    setElementHoverStl(child, hoverStyle);\n                }\n            })\n            : setElementHoverStl(el, hoverStyle);\n\n        // Duplicated function will be auto-ignored, see Eventful.js.\n        el.on('mouseover', onElementMouseOver)\n          .on('mouseout', onElementMouseOut);\n\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis)\n          .on('normal', leaveEmphasis);\n    };\n\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelOffset = labelModel.getShallow('offset');\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textOffset: labelOffset,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n\n    graphic.getFont = function (opt, ecModel) {\n        var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n        return [\n            // FIXME in node-canvas fontWeight is before fontStyle\n            opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '',\n            opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '',\n            (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px',\n            opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'\n        ].join(' ');\n    };\n\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        // Do not check 'animation' property directly here. Consider this case:\n        // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n        // but its parent model (`seriesModel`) does.\n        var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(\n                    dataIndex,\n                    animatableModel.getAnimationDelayParams\n                        ? animatableModel.getAnimationDelayParams(el, dataIndex)\n                        : null\n                );\n            }\n            if (typeof duration === 'function') {\n                duration = duration(dataIndex);\n            }\n\n            duration > 0\n                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n                : (el.stopAnimation(), el.attr(props), cb && cb());\n        }\n        else {\n            el.stopAnimation();\n            el.attr(props);\n            cb && cb();\n        }\n    }\n\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n\n        return mat;\n    };\n\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} target [x, y]\n     * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:\n     *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n     *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (target, transform, invert) {\n        if (transform && !zrUtil.isArrayLike(transform)) {\n            transform = Transformable.getLocalTransform(transform);\n        }\n\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], target, transform);\n    };\n\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n        var vertex = [\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n        ];\n\n        vertex = graphic.applyTransform(vertex, transform, invert);\n\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n            ? (vertex[0] > 0 ? 'right' : 'left')\n            : (vertex[1] > 0 ? 'bottom' : 'top');\n    };\n\n    /**\n     * Apply group transition animation from g1 to g2.\n     * If no animatableModel, no animation.\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                position: vector.clone(el.position),\n                rotation: el.rotation\n            };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }\n                // else {\n                //     if (el.previousProps) {\n                //         graphic.updateProps\n                //     }\n                // }\n            }\n        });\n    };\n\n    /**\n     * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]\n     * @param {Object} rect {x, y, width, height}\n     * @return {Array.<Array.<number>>} A new clipped points.\n     */\n    graphic.clipPointsByRect = function (points, rect) {\n        return zrUtil.map(points, function (point) {\n            var x = point[0];\n            x = mathMax(x, rect.x);\n            x = mathMin(x, rect.x + rect.width);\n            var y = point[1];\n            y = mathMax(y, rect.y);\n            y = mathMin(y, rect.y + rect.height);\n            return [x, y];\n        });\n    };\n\n    /**\n     * @param {Object} targetRect {x, y, width, height}\n     * @param {Object} rect {x, y, width, height}\n     * @return {Object} A new clipped rect. If rect size are negative, return undefined.\n     */\n    graphic.clipRectByRect = function (targetRect, rect) {\n        var x = mathMax(targetRect.x, rect.x);\n        var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n        var y = mathMax(targetRect.y, rect.y);\n        var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);\n\n        if (x2 >= x && y2 >= y) {\n            return {\n                x: x,\n                y: y,\n                width: x2 - x,\n                height: y2 - y\n            };\n        }\n    };\n\n    module.exports = graphic;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/graphic.js\n// module id = 192\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module echarts/util/number\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var number = {};\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n\n        if (subDomain === 0) {\n            return subRange === 0\n                ? range[0]\n                : (range[0] + range[1]) / 2;\n        }\n\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                }\n                else if (val >= domain[1]) {\n                    return range[1];\n                }\n            }\n            else {\n                if (val >= domain[0]) {\n                    return range[0];\n                }\n                else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        }\n        else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function(percent, all) {\n        switch (percent) {\n            case 'center':\n            case 'middle':\n                percent = '50%';\n                break;\n            case 'left':\n            case 'top':\n                percent = '0%';\n                break;\n            case 'right':\n            case 'bottom':\n                percent = '100%';\n                break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n\n            return parseFloat(percent);\n        }\n\n        return percent == null ? NaN : +percent;\n    };\n\n    /**\n     * (1) Fix rounding error of float numbers.\n     * (2) Support return string to avoid scientific notation like '3.5e-7'.\n     *\n     * @param {number} x\n     * @param {number} [precision]\n     * @param {boolean} [returnStr]\n     * @return {number|string}\n     */\n    number.round = function (x, precision, returnStr) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // Avoid range error\n        precision = Math.min(Math.max(0, precision), 20);\n        x = (+x).toFixed(precision);\n        return returnStr ? x : +x;\n    };\n\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n\n    /**\n     * @param {string|number} val\n     * @return {number}\n     */\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n\n        // Consider scientific notation: '3.4e-12' '3.4e+12'\n        var eIndex = str.indexOf('e');\n        if (eIndex > 0) {\n            var precision = +str.slice(eIndex + 1);\n            return precision < 0 ? -precision : 0;\n        }\n        else {\n            var dotIndex = str.indexOf('.');\n            return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n        }\n    };\n\n    /**\n     * Minimal dicernible data precisioin according to a single pixel.\n     *\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number} precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        // toFixed() digits argument must be between 0 and 20.\n        var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n        return !isFinite(precision) ? 20 : precision;\n    };\n\n    /**\n     * Get a data of given precision, assuring the sum of percentages\n     * in valueList is 1.\n     * The largest remainer method is used.\n     * https://en.wikipedia.org/wiki/Largest_remainder_method\n     *\n     * @param {Array.<number>} valueList a list of all data\n     * @param {number} idx index of the data to be processed in valueList\n     * @param {number} precision integer number showing digits of precision\n     * @return {number} percent ranging from 0 to 100\n     */\n    number.getPercentWithPrecision = function (valueList, idx, precision) {\n        if (!valueList[idx]) {\n            return 0;\n        }\n\n        var sum = zrUtil.reduce(valueList, function (acc, val) {\n            return acc + (isNaN(val) ? 0 : val);\n        }, 0);\n        if (sum === 0) {\n            return 0;\n        }\n\n        var digits = Math.pow(10, precision);\n        var votesPerQuota = zrUtil.map(valueList, function (val) {\n            return (isNaN(val) ? 0 : val) / sum * digits * 100;\n        });\n        var targetSeats = digits * 100;\n\n        var seats = zrUtil.map(votesPerQuota, function (votes) {\n            // Assign automatic seats.\n            return Math.floor(votes);\n        });\n        var currentSum = zrUtil.reduce(seats, function (acc, val) {\n            return acc + val;\n        }, 0);\n\n        var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {\n            return votes - seats[idx];\n        });\n\n        // Has remainding votes.\n        while (currentSum < targetSeats) {\n            // Find next largest remainder.\n            var max = Number.NEGATIVE_INFINITY;\n            var maxId = null;\n            for (var i = 0, len = remainder.length; i < len; ++i) {\n                if (remainder[i] > max) {\n                    max = remainder[i];\n                    maxId = i;\n                }\n            }\n\n            // Add a vote to max remainder.\n            ++seats[maxId];\n            remainder[maxId] = 0;\n            ++currentSum;\n        }\n\n        return seats[idx] / digits;\n    };\n\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n\n    var TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d\\d)(?::(\\d\\d)(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line\n\n    /**\n     * @return {number} in minutes\n     */\n    number.getTimezoneOffset = function () {\n        return (new Date()).getTimezoneOffset();\n    };\n\n    /**\n     * @param {string|Date|number} value These values can be accepted:\n     *   + An instance of Date, represent a time in its own time zone.\n     *   + Or string in a subset of ISO 8601, only including:\n     *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',\n     *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',\n     *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',\n     *     all of which will be treated as local time if time zone is not specified\n     *     (see <https://momentjs.com/>).\n     *   + Or other string format, including (all of which will be treated as loacal time):\n     *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',\n     *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'\n     *   + a timestamp, which represent a time in UTC.\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            // Different browsers parse date in different way, so we parse it manually.\n            // Some other issues:\n            // new Date('1970-01-01') is UTC,\n            // new Date('1970/01/01') and new Date('1970-1-01') is local.\n            // See issue #3623\n            var match = TIME_REG.exec(value);\n\n            if (!match) {\n                // return Invalid Date.\n                return new Date(NaN);\n            }\n\n            var timezoneOffset = number.getTimezoneOffset();\n            var timeOffset = !match[8]\n                ? 0\n                : match[8].toUpperCase() === 'Z'\n                ? timezoneOffset\n                : +match[8].slice(0, 3) * 60 + timezoneOffset;\n\n            // match[n] can only be string or undefined.\n            // But take care of '12' + 1 => '121'.\n            return new Date(\n                +match[1],\n                +(match[2] || 1) - 1,\n                +match[3] || 1,\n                +match[4] || 0,\n                +(match[5] || 0) - timeOffset,\n                +match[6] || 0,\n                +match[7] || 0\n            );\n        }\n        else if (value == null) {\n            return new Date(NaN);\n        }\n\n        return new Date(Math.round(value));\n    };\n\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     *\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, quantityExponent(val));\n    };\n\n    function quantityExponent(val) {\n        return Math.floor(Math.log(val) / Math.LN10);\n    }\n\n    /**\n     * find a nice number approximately equal to x. Round the number if round = true,\n     * take ceiling if round = false. The primary observation is that the nicest\n     * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     *\n     * See \"Nice Numbers for Graph Labels\" of Graphic Gems.\n     *\n     * @param  {number} val Non-negative value.\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exponent = quantityExponent(val);\n        var exp10 = Math.pow(10, exponent);\n        var f = val / exp10; // 1 <= f < 10\n        var nf;\n        if (round) {\n            if (f < 1.5) { nf = 1; }\n            else if (f < 2.5) { nf = 2; }\n            else if (f < 4) { nf = 3; }\n            else if (f < 7) { nf = 5; }\n            else { nf = 10; }\n        }\n        else {\n            if (f < 1) { nf = 1; }\n            else if (f < 2) { nf = 2; }\n            else if (f < 3) { nf = 3; }\n            else if (f < 5) { nf = 5; }\n            else { nf = 10; }\n        }\n        val = nf * exp10;\n\n        // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).\n        // 20 is the uppper bound of toFixed.\n        return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n    };\n\n    /**\n     * Order intervals asc, and split them when overlap.\n     * expect(numberUtil.reformIntervals([\n     *     {interval: [18, 62], close: [1, 1]},\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [1, 1]},\n     *     {interval: [62, 150], close: [1, 1]},\n     *     {interval: [106, 150], close: [1, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ])).toEqual([\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [0, 1]},\n     *     {interval: [18, 62], close: [0, 1]},\n     *     {interval: [62, 150], close: [0, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ]);\n     * @param {Array.<Object>} list, where `close` mean open or close\n     *        of the interval, and Infinity can be used.\n     * @return {Array.<Object>} The origin list, which has been reformed.\n     */\n    number.reformIntervals = function (list) {\n        list.sort(function (a, b) {\n            return littleThan(a, b, 0) ? -1 : 1;\n        });\n\n        var curr = -Infinity;\n        var currClose = 1;\n        for (var i = 0; i < list.length;) {\n            var interval = list[i].interval;\n            var close = list[i].close;\n\n            for (var lg = 0; lg < 2; lg++) {\n                if (interval[lg] <= curr) {\n                    interval[lg] = curr;\n                    close[lg] = !lg ? 1 - currClose : 1;\n                }\n                curr = interval[lg];\n                currClose = close[lg];\n            }\n\n            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n                list.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n\n        return list;\n\n        function littleThan(a, b, lg) {\n            return a.interval[lg] < b.interval[lg]\n                || (\n                    a.interval[lg] === b.interval[lg]\n                    && (\n                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n                        || (!lg && littleThan(a, b, 1))\n                    )\n                );\n        }\n    };\n\n    /**\n     * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n     * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n     * subtraction forces infinities to NaN\n     *\n     * @param {*} v\n     * @return {boolean}\n     */\n    number.isNumeric = function (v) {\n        return v - parseFloat(v) >= 0;\n    };\n\n    module.exports = number;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/number.js\n// module id = 193\n// module chunks = 0 1 2 3 4 5 6","\n\n    var formatUtil = require('./format');\n    var nubmerUtil = require('./number');\n    var Model = require('../model/Model');\n    var zrUtil = require('zrender/lib/core/util');\n    var each = zrUtil.each;\n    var isObject = zrUtil.isObject;\n\n    var modelUtil = {};\n\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array\n            ? value\n            : value == null\n            ? []\n            : [value];\n    };\n\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n     modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n\n            // Default emphasis option from normal\n            each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n\n    modelUtil.LABEL_OPTIONS = ['position', 'offset', 'show', 'textStyle', 'distance', 'formatter'];\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return isObject(dataItem)\n            && !(dataItem instanceof Array);\n            // // markLine data can be array\n            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n\n        if (dimType === 'time'\n            // spead up when using timestamp\n            && typeof value !== 'number'\n            && value != null\n            && value !== '-'\n        ) {\n            value = +nubmerUtil.parseDate(value);\n        }\n\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return (value == null || value === '')\n            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n    };\n\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        /**\n         * Get params for formatter\n         * @param {number} dataIndex\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n            var color = data.getItemVisual(dataIndex, 'color');\n\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: this.seriesIndex,\n                seriesId: this.id,\n                seriesName: this.name,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: color,\n                marker: formatUtil.getTooltipMarker(color),\n\n                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n                $vars: ['seriesName', 'name', 'value']\n            };\n        },\n\n        /**\n         * Format label\n         * @param {number} dataIndex\n         * @param {string} [status='normal'] 'normal' or 'emphasis'\n         * @param {string} [dataType]\n         * @param {number} [dimIndex]\n         * @param {string} [labelProp='label']\n         * @return {string}\n         */\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && (params.value instanceof Array)) {\n                params.value = params.value[dimIndex];\n            }\n\n            var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);\n\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            }\n            else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n\n        /**\n         * Get raw value in option\n         * @param {number} idx\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return (isObject(dataItem) && !(dataItem instanceof Array))\n                    ? dataItem.value : dataItem;\n            }\n        },\n\n        /**\n         * Should be implemented.\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         * @return {string} tooltip string\n         */\n        formatTooltip: zrUtil.noop\n    };\n\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          index of which is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n\n        var result = zrUtil.map(exists || [], function (obj, index) {\n            return {exist: obj};\n        });\n\n        // Mapping by id or name if specified.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option // Consider name: two map to one.\n                    && cptOption.id != null\n                    && result[i].exist.id === cptOption.id + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option // Consider name: two map to one.\n                    // Can not match when both ids exist but different.\n                    && (exist.id == null || cptOption.id == null)\n                    && cptOption.name != null\n                    && !modelUtil.isIdInner(cptOption)\n                    && !modelUtil.isIdInner(exist)\n                    && exist.name === cptOption.name + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n\n        // Otherwise mapping by index.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option\n                    // Existing model that already has id should be able to\n                    // mapped to (because after mapping performed model may\n                    // be assigned with a id, whish should not affect next\n                    // mapping), except those has inner id.\n                    && !modelUtil.isIdInner(exist)\n                    // Caution:\n                    // Do not overwrite id. But name can be overwritten,\n                    // because axis use name as 'show label text'.\n                    // 'exist' always has id and name and we dont\n                    // need to check it.\n                    && cptOption.id == null\n                ) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n\n            if (i >= result.length) {\n                result.push({option: cptOption});\n            }\n        });\n\n        return result;\n    };\n\n    /**\n     * Make id and name for mapping result (result of mappingToExists)\n     * into `keyInfo` field.\n     *\n     * @public\n     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     * @return {Array.<Object>} The input.\n     */\n    modelUtil.makeIdAndName = function (mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n\n        // Ensure that each id is distinct.\n        var idMap = zrUtil.createHashMap();\n\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && idMap.set(existCpt.id, item);\n        });\n\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n\n            zrUtil.assert(\n                !opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item,\n                'id duplicates: ' + (opt && opt.id)\n            );\n\n            opt && opt.id != null && idMap.set(opt.id, item);\n            !item.keyInfo && (item.keyInfo = {});\n        });\n\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n\n            if (!isObject(opt)) {\n                return;\n            }\n\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null\n                ? opt.name + ''\n                : existCpt\n                ? existCpt.name\n                : '\\0-'; // name may be displayed on screen, so use '-'.\n\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            }\n            else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            }\n            else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n                }\n                while (idMap.get(keyInfo.id));\n            }\n\n            idMap.set(keyInfo.id, item);\n        });\n    };\n\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return isObject(cptOption)\n            && cptOption.id\n            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n    };\n\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n\n        return [mapToArray(mapA), mapToArray(mapB)];\n\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    }\n                    else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    }\n                    else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                    }\n                }\n            }\n            return result;\n        }\n    };\n\n    /**\n     * @param {module:echarts/data/List} data\n     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n     *                         each of which can be Array or primary type.\n     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n     */\n    modelUtil.queryDataIndex = function (data, payload) {\n        if (payload.dataIndexInside != null) {\n            return payload.dataIndexInside;\n        }\n        else if (payload.dataIndex != null) {\n            return zrUtil.isArray(payload.dataIndex)\n                ? zrUtil.map(payload.dataIndex, function (value) {\n                    return data.indexOfRawIndex(value);\n                })\n                : data.indexOfRawIndex(payload.dataIndex);\n        }\n        else if (payload.name != null) {\n            return zrUtil.isArray(payload.name)\n                ? zrUtil.map(payload.name, function (value) {\n                    return data.indexOfName(value);\n                })\n                : data.indexOfName(payload.name);\n        }\n    };\n\n    /**\n     * Enable property storage to any host object.\n     * Notice: Serialization is not supported.\n     *\n     * For example:\n     * var get = modelUitl.makeGetter();\n     *\n     * function some(hostObj) {\n     *      get(hostObj)._someProperty = 1212;\n     *      ...\n     * }\n     *\n     * @return {Function}\n     */\n    modelUtil.makeGetter = (function () {\n        var index = 0;\n        return function () {\n            var key = '\\0__ec_prop_getter_' + index++;\n            return function (hostObj) {\n                return hostObj[key] || (hostObj[key] = {});\n            };\n        };\n    })();\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex, seriesId, seriesName,\n     *            geoIndex, geoId, geoName,\n     *            bmapIndex, bmapId, bmapName,\n     *            xAxisIndex, xAxisId, xAxisName,\n     *            yAxisIndex, yAxisId, yAxisName,\n     *            gridIndex, gridId, gridName,\n     *            ... (can be extended)\n     *        }\n     *        Each properties can be number|string|Array.<number>|Array.<string>\n     *        For example, a finder could be\n     *        {\n     *            seriesIndex: 3,\n     *            geoId: ['aa', 'cc'],\n     *            gridName: ['xx', 'rr']\n     *        }\n     *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)\n     *        If nothing or null/undefined specified, return nothing.\n     * @param {Object} [opt]\n     * @param {string} [opt.defaultMainType]\n     * @param {Array.<string>} [opt.includeMainTypes]\n     * @return {Object} result like:\n     *        {\n     *            seriesModels: [seriesModel1, seriesModel2],\n     *            seriesModel: seriesModel1, // The first model\n     *            geoModels: [geoModel1, geoModel2],\n     *            geoModel: geoModel1, // The first model\n     *            ...\n     *        }\n     */\n    modelUtil.parseFinder = function (ecModel, finder, opt) {\n        if (zrUtil.isString(finder)) {\n            var obj = {};\n            obj[finder + 'Index'] = 0;\n            finder = obj;\n        }\n\n        var defaultMainType = opt && opt.defaultMainType;\n        if (defaultMainType\n            && !has(finder, defaultMainType + 'Index')\n            && !has(finder, defaultMainType + 'Id')\n            && !has(finder, defaultMainType + 'Name')\n        ) {\n            finder[defaultMainType + 'Index'] = 0;\n        }\n\n        var result = {};\n\n        each(finder, function (value, key) {\n            var value = finder[key];\n\n            // Exclude 'dataIndex' and other illgal keys.\n            if (key === 'dataIndex' || key === 'dataIndexInside') {\n                result[key] = value;\n                return;\n            }\n\n            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n            var mainType = parsedKey[1];\n            var queryType = (parsedKey[2] || '').toLowerCase();\n\n            if (!mainType\n                || !queryType\n                || value == null\n                || (queryType === 'index' && value === 'none')\n                || (opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0)\n            ) {\n                return;\n            }\n\n            var queryParam = {mainType: mainType};\n            if (queryType !== 'index' || value !== 'all') {\n                queryParam[queryType] = value;\n            }\n\n            var models = ecModel.queryComponents(queryParam);\n            result[mainType + 'Models'] = models;\n            result[mainType + 'Model'] = models[0];\n        });\n\n        return result;\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string|number} dataDim\n     * @return {string}\n     */\n    modelUtil.dataDimToCoordDim = function (data, dataDim) {\n        var dimensions = data.dimensions;\n        dataDim = data.getDimension(dataDim);\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimItem = data.getDimensionInfo(dimensions[i]);\n            if (dimItem.name === dataDim) {\n                return dimItem.coordDim;\n            }\n        }\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string} coordDim\n     * @return {Array.<string>} data dimensions on the coordDim.\n     */\n    modelUtil.coordDimToDataDim = function (data, coordDim) {\n        var dataDim = [];\n        each(data.dimensions, function (dimName) {\n            var dimItem = data.getDimensionInfo(dimName);\n            if (dimItem.coordDim === coordDim) {\n                dataDim[dimItem.coordDimIndex] = dimItem.name;\n            }\n        });\n        return dataDim;\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string} otherDim Can be `otherDims`\n     *                        like 'label' or 'tooltip'.\n     * @return {Array.<string>} data dimensions on the otherDim.\n     */\n    modelUtil.otherDimToDataDim = function (data, otherDim) {\n        var dataDim = [];\n        each(data.dimensions, function (dimName) {\n            var dimItem = data.getDimensionInfo(dimName);\n            var otherDims = dimItem.otherDims;\n            var dimIndex = otherDims[otherDim];\n            if (dimIndex != null && dimIndex !== false) {\n                dataDim[dimIndex] = dimItem.name;\n            }\n        });\n        return dataDim;\n    };\n\n    function has(obj, prop) {\n        return obj && obj.hasOwnProperty(prop);\n    }\n\n    module.exports = modelUtil;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/model.js\n// module id = 194\n// module chunks = 0 1 2 3 4 5 6","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * \n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * \n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} \n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/vector.js\n// module id = 195\n// module chunks = 0 1 2 3 4 5 6","/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    var pathProxyForDraw = new PathProxy(true);\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = null;\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path || pathProxyForDraw;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect;\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath\n                || (lineDash && !ctxLineDash && hasStroke)\n            ) {\n                path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                if (this.path) {\n                    this.__dirtyPath = false;\n                }\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        createPathProxy: function () {\n            this.path = new PathProxy();\n        },\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (!path) {\n                    // Create path on demand.\n                    path = this.path = new PathProxy();\n                }\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     *  Path element, \n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME  extend position, rotation \n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Path.js\n// module id = 196\n// module chunks = 0 1 2 3 4 5 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('./number');\n    var textContain = require('zrender/lib/contain/text');\n\n    var formatUtil = {};\n\n    /**\n     * ,\n     * @param {string|number} x\n     * @return {string}\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n               + (x.length > 1 ? ('.' + x[1]) : '');\n    };\n\n    /**\n     * @param {string} str\n     * @param {boolean} [upperCaseFirst=false]\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str, upperCaseFirst) {\n        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n            return group1.toUpperCase();\n        });\n\n        if (upperCaseFirst && str) {\n            str = str.charAt(0).toUpperCase() + str.slice(1);\n        }\n\n        return str;\n    };\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        else if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    };\n\n    var encodeHTML = formatUtil.encodeHTML = function (source) {\n        return String(source)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    };\n\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    /**\n     * Template formatter\n     * @param {string} tpl\n     * @param {Array.<Object>|Object} paramsList\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList, encode) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            var val = wrapVar(alias, 0);\n            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                var val = paramsList[seriesIdx][$vars[k]];\n                tpl = tpl.replace(\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                    encode ? encodeHTML(val) : val\n                );\n            }\n        }\n\n        return tpl;\n    };\n\n    /**\n     * simple Template formatter\n     *\n     * @param {string} tpl\n     * @param {Object} param\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTplSimple = function (tpl, param, encode) {\n        zrUtil.each(param, function (value, key) {\n            tpl = tpl.replace(\n                '{' + key + '}',\n                encode ? encodeHTML(value) : value\n            );\n        });\n        return tpl;\n    };\n\n    /**\n     * @param {string} color\n     * @param {string} [extraCssText]\n     * @return {string}\n     */\n    formatUtil.getTooltipMarker = function (color, extraCssText) {\n        return color\n            ? '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:'\n                + formatUtil.encodeHTML(color) + ';' + (extraCssText || '') + '\"></span>'\n            : '';\n    };\n\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? ('0' + str) : str;\n    };\n\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @param {boolean} [isUTC=false] Default in local time.\n     *           see `module:echarts/scale/Time`\n     *           and `module:echarts/util/number#parseDate`.\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value, isUTC) {\n        if (tpl === 'week'\n            || tpl === 'month'\n            || tpl === 'quarter'\n            || tpl === 'half-year'\n            || tpl === 'year'\n        ) {\n            tpl = 'MM-dd\\nyyyy';\n        }\n\n        var date = numberUtil.parseDate(value);\n        var utc = isUTC ? 'UTC' : '';\n        var y = date['get' + utc + 'FullYear']();\n        var M = date['get' + utc + 'Month']() + 1;\n        var d = date['get' + utc + 'Date']();\n        var h = date['get' + utc + 'Hours']();\n        var m = date['get' + utc + 'Minutes']();\n        var s = date['get' + utc + 'Seconds']();\n\n        tpl = tpl.replace('MM', s2d(M))\n            .toLowerCase()\n            .replace('yyyy', y)\n            .replace('yy', y % 100)\n            .replace('dd', s2d(d))\n            .replace('d', d)\n            .replace('hh', s2d(h))\n            .replace('h', h)\n            .replace('mm', s2d(m))\n            .replace('m', m)\n            .replace('ss', s2d(s))\n            .replace('s', s);\n\n        return tpl;\n    };\n\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n\n    formatUtil.truncateText = textContain.truncateText;\n\n    module.exports = formatUtil;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/format.js\n// module id = 197\n// module chunks = 0 1 2 3 4 5 6","/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // canvas\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n                // events currently. So we dont use that on other browsers unless tested sufficiently.\n                // Although IE 10 supports pointer event, it use old style and is different from the\n                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n                && (browser.edge || (browser.ie && browser.version >= 11))\n        };\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/env.js\n// module id = 198\n// module chunks = 0 1 2 3 4 5 6","/**\n * @module echarts/model/Model\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazzUtil = require('../util/clazz');\n    var env = require('zrender/lib/core/env');\n\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;\n\n        // Simple optimization\n        // if (this.init) {\n        //     if (arguments.length <= 4) {\n        //         this.init(option, parentModel, ecModel, extraOpt);\n        //     }\n        //     else {\n        //         this.init.apply(this, arguments);\n        //     }\n        // }\n    }\n\n    Model.prototype = {\n\n        constructor: Model,\n\n        /**\n         * Model \n         * @param {Object} option\n         */\n        init: null,\n\n        /**\n         *  Option merge\n         */\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        get: function (path, ignoreParent) {\n            if (path == null) {\n                return this.option;\n            }\n\n            return doGet(\n                this.option,\n                this.parsePath(path),\n                !ignoreParent && getParent(this, path)\n            );\n        },\n\n        /**\n         * @param {string} key\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n\n            var val = option == null ? option : option[key];\n            var parentModel = !ignoreParent && getParent(this, key);\n            if (val == null && parentModel) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n\n        /**\n         * @param {string|Array.<string>} [path]\n         * @param {module:echarts/model/Model} [parentModel]\n         * @return {module:echarts/model/Model}\n         */\n        getModel: function (path, parentModel) {\n            var obj = path == null\n                ? this.option\n                : doGet(this.option, path = this.parsePath(path));\n\n            var thisParentModel;\n            parentModel = parentModel || (\n                (thisParentModel = getParent(this, path))\n                    && thisParentModel.getModel(path)\n            );\n\n            return new Model(obj, parentModel, this.ecModel);\n        },\n\n        /**\n         * If model has option\n         */\n        isEmpty: function () {\n            return this.option == null;\n        },\n\n        restoreData: function () {},\n\n        // Pending\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        },\n\n        // If path is null/undefined, return null/undefined.\n        parsePath: function(path) {\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            return path;\n        },\n\n        /**\n         * @param {Function} getParentMethod\n         *        param {Array.<string>|string} path\n         *        return {module:echarts/model/Model}\n         */\n        customizeGetParent: function (getParentMethod) {\n            clazzUtil.set(this, 'getParent', getParentMethod);\n        },\n\n        isAnimationEnabled: function () {\n            if (!env.node) {\n                if (this.option.animation != null) {\n                    return !!this.option.animation;\n                }\n                else if (this.parentModel) {\n                    return this.parentModel.isAnimationEnabled();\n                }\n            }\n        }\n    };\n\n    function doGet(obj, pathArr, parentModel) {\n        for (var i = 0; i < pathArr.length; i++) {\n            // Ignore empty\n            if (!pathArr[i]) {\n                continue;\n            }\n            // obj could be number/string/... (like 0)\n            obj = (obj && typeof obj === 'object') ? obj[pathArr[i]] : null;\n            if (obj == null) {\n                break;\n            }\n        }\n        if (obj == null && parentModel) {\n            obj = parentModel.get(pathArr);\n        }\n        return obj;\n    }\n\n    // `path` can be null/undefined\n    function getParent(model, path) {\n        var getParentMethod = clazzUtil.get(model, 'getParent');\n        return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n    }\n\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n\n    var mixin = zrUtil.mixin;\n    mixin(Model, require('./mixin/lineStyle'));\n    mixin(Model, require('./mixin/areaStyle'));\n    mixin(Model, require('./mixin/textStyle'));\n    mixin(Model, require('./mixin/itemStyle'));\n\n    module.exports = Model;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Model.js\n// module id = 199\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // \n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/BoundingRect.js\n// module id = 200\n// module chunks = 0 1 2 3 4 5 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var clazz = {};\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    var MEMBER_PRIFIX = '\\0ec_\\0';\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name] = value;` (can be right-value)\n     * @public\n     */\n    clazz.set = function (host, name, value) {\n        return (host[MEMBER_PRIFIX + name] = value);\n    };\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name];`\n     * @public\n     */\n    clazz.get = function (host, name) {\n        return host[MEMBER_PRIFIX + name];\n    };\n\n    /**\n     * For hidden private class member.\n     * The same behavior as `host.hasOwnProperty(name);`\n     * @public\n     */\n    clazz.hasOwn = function (host, name) {\n        return host.hasOwnProperty(MEMBER_PRIFIX + name);\n    };\n\n    /**\n     * Notice, parseClassType('') should returns {main: '', sub: ''}\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n        var ret = {main: '', sub: ''};\n        if (componentType) {\n            componentType = componentType.split(TYPE_DELIMITER);\n            ret.main = componentType[0] || '';\n            ret.sub = componentType[1] || '';\n        }\n        return ret;\n    };\n\n    /**\n     * @public\n     */\n    function checkClassType(componentType) {\n        zrUtil.assert(\n            /^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType),\n            'componentType \"' + componentType + '\" illegal'\n        );\n    }\n\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n\n            if (__DEV__) {\n                zrUtil.each(mandatoryMethods, function (method) {\n                    if (!proto[method]) {\n                        console.warn(\n                            'Method `' + method + '` should be implemented'\n                            + (proto.type ? ' in ' + proto.type : '') + '.'\n                        );\n                    }\n                });\n            }\n\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                }\n                else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n\n            zrUtil.extend(ExtendedClass.prototype, proto);\n\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n\n            return ExtendedClass;\n        };\n    };\n\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                checkClassType(componentType);\n                componentType = parseClassType(componentType);\n\n                if (!componentType.sub) {\n                    if (__DEV__) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                }\n                else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n\n        entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n            var Clazz = storage[componentMainType];\n\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error(\n                    !subType\n                        ? componentMainType + '.' + 'type should be specified.'\n                        : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.'\n                );\n            }\n\n            return Clazz;\n        };\n\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n\n            var result = [];\n            var obj = storage[componentType.main];\n\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            }\n            else {\n                result.push(obj);\n            }\n\n            return result;\n        };\n\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n\n        entity.parseClassType = parseClassType;\n\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n\n        return entity;\n    };\n\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n        // FIXME It seems broken in IE8 simulation of IE11\n        // if (!zrUtil.isArray(properties)) {\n        //     properties = properties != null ? [properties] : [];\n        // }\n        // zrUtil.each(properties, function (prop) {\n        //     var value = obj[prop];\n\n        //     Object.defineProperty\n        //         && Object.defineProperty(obj, prop, {\n        //             value: value, writable: false\n        //         });\n        //     zrUtil.isArray(obj[prop])\n        //         && Object.freeze\n        //         && Object.freeze(obj[prop]);\n        // });\n    };\n\n    module.exports = clazz;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/clazz.js\n// module id = 201\n// module chunks = 0 1 2 3 4 5 6","/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\n\n    var Model = require('./Model');\n    var zrUtil = require('zrender/lib/core/util');\n    var arrayPush = Array.prototype.push;\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var layout = require('../util/layout');\n\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n\n        type: 'component',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        id: '',\n\n        /**\n         * @readOnly\n         */\n        name: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        mainType: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        subType: '',\n\n        /**\n         * @readOnly\n         * @type {number}\n         */\n        componentIndex: 0,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        ecModel: null,\n\n        /**\n         * key: componentType\n         * value:  Component model list, can not be null.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @readOnly\n         */\n        dependentModels: [],\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        uid: null,\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        $constructor: function (option, parentModel, ecModel, extraOpt) {\n            Model.call(this, option, parentModel, ecModel, extraOpt);\n\n            this.uid = componentUtil.getUID('componentModel');\n        },\n\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n            this.mergeDefaultAndTheme(option, ecModel);\n        },\n\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            var themeModel = ecModel.getTheme();\n            zrUtil.merge(option, themeModel.get(this.mainType));\n            zrUtil.merge(option, this.getDefaultOption());\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (option, extraOpt) {\n            zrUtil.merge(this.option, option, true);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, option, layoutMode);\n            }\n        },\n\n        // Hooker after init or mergeOption\n        optionUpdated: function (newCptOption, isInit) {},\n\n        getDefaultOption: function () {\n            if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n                var optList = [];\n                var Class = this.constructor;\n                while (Class) {\n                    var opt = Class.prototype.defaultOption;\n                    opt && optList.push(opt);\n                    Class = Class.superClass;\n                }\n\n                var defaultOption = {};\n                for (var i = optList.length - 1; i >= 0; i--) {\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                }\n                clazzUtil.set(this, '__defaultOption', defaultOption);\n            }\n            return clazzUtil.get(this, '__defaultOption');\n        },\n\n        getReferringComponents: function (mainType) {\n            return this.ecModel.queryComponents({\n                mainType: mainType,\n                index: this.get(mainType + 'Index', true),\n                id: this.get(mainType + 'Id', true)\n            });\n        }\n\n    });\n\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n\n    //         this.uid = componentUtil.getUID('componentModel');\n\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(\n        ComponentModel, {registerWhenExtend: true}\n    );\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n\n    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n\n    module.exports = ComponentModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Component.js\n// module id = 202\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n// Layout helpers for each component positioning\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n    var numberUtil = require('./number');\n    var formatUtil = require('./format');\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n\n    var layout = {};\n\n    /**\n     * @public\n     */\n    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [\n        'left', 'right', 'top', 'bottom', 'width', 'height'\n    ];\n\n    /**\n     * @public\n     */\n    var HV_NAMES = layout.HV_NAMES = [\n        ['width', 'left', 'right'],\n        ['height', 'top', 'bottom']\n    ];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            }\n            else {\n                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n\n            if (child.newline) {\n                return;\n            }\n\n            position[0] = x;\n            position[1] = y;\n\n            orient === 'horizontal'\n                ? (x = nextX + gap)\n                : (y = nextY + gap);\n        });\n    }\n\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (\n        positionInfo, containerRect, margin\n    ) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            }\n            else {\n                height = containerHeight * 0.8;\n            }\n        }\n\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n            case 'center':\n                left = containerWidth / 2 - width / 2 - margin[3];\n                break;\n            case 'right':\n                left = containerWidth - width - horizontalMargin;\n                break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n            case 'middle':\n            case 'center':\n                top = containerHeight / 2 - height / 2 - margin[0];\n                break;\n            case 'bottom':\n                top = containerHeight - height - verticalMargin;\n                break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n\n\n    /**\n     * Position a zr element in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * Logic:\n     *     1. Scale (against origin point in parent coord)\n     *     2. Rotate (against origin point in parent coord)\n     *     3. Traslate (with el.position by this method)\n     * So this method only fixes the last step 'Traslate', which does not affect\n     * scaling and rotating.\n     *\n     * If be called repeatly with the same input el, the same result will be gotten.\n     *\n     * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @param {Object} [opt]\n     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n     * @param {Array.<number>} [opt.boundingMode='all']\n     *        Specify how to calculate boundingRect when locating.\n     *        'all': Position the boundingRect that is transformed and uioned\n     *               both itself and its descendants.\n     *               This mode simplies confine the elements in the bounding\n     *               of their container (e.g., using 'right: 0').\n     *        'raw': Position the boundingRect that is not transformed and only itself.\n     *               This mode is useful when you want a element can overflow its\n     *               container. (Consider a rotated circle needs to be located in a corner.)\n     *               In this mode positionInfo.width/height can only be number.\n     */\n    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\n        var h = !opt || !opt.hv || opt.hv[0];\n        var v = !opt || !opt.hv || opt.hv[1];\n        var boundingMode = opt && opt.boundingMode || 'all';\n\n        if (!h && !v) {\n            return;\n        }\n\n        var rect;\n        if (boundingMode === 'raw') {\n            rect = el.type === 'group'\n                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n                : el.getBoundingRect();\n        }\n        else {\n            rect = el.getBoundingRect();\n            if (el.needLocalTransform()) {\n                var transform = el.getLocalTransform();\n                // Notice: raw rect may be inner object of el,\n                // which should not be modified.\n                rect = rect.clone();\n                rect.applyTransform(transform);\n            }\n        }\n\n        positionInfo = layout.getLayoutRect(\n            zrUtil.defaults(\n                {width: rect.width, height: rect.height},\n                positionInfo\n            ),\n            containerRect,\n            margin\n        );\n\n        // Because 'tranlate' is the last step in transform\n        // (see zrender/core/Transformable#getLocalTransfrom),\n        // we can just only modify el.position to get final result.\n        var elPos = el.position;\n        var dx = h ? positionInfo.x - rect.x : 0;\n        var dy = v ? positionInfo.y - rect.y : 0;\n\n        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n    };\n\n    /**\n     * @param {Object} option Contains some of the properties in HV_NAMES.\n     * @param {number} hvIdx 0: horizontal; 1: vertical.\n     */\n    layout.sizeCalculable = function (option, hvIdx) {\n        return option[HV_NAMES[hvIdx][0]] != null\n            || (option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null);\n    };\n\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n\n        var ignoreSize = opt.ignoreSize;\n        !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n\n        var hResult = merge(HV_NAMES[0], 0);\n        var vResult = merge(HV_NAMES[1], 1);\n\n        copy(HV_NAMES[0], targetOption, hResult);\n        copy(HV_NAMES[1], targetOption, vResult);\n\n        function merge(names, hvIdx) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = 2;\n\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n\n            if (ignoreSize[hvIdx]) {\n                // Only one of left/right is premitted to exist.\n                if (hasValue(newOption, names[1])) {\n                    merged[names[2]] = null;\n                }\n                else if (hasValue(newOption, names[2])) {\n                    merged[names[1]] = null;\n                }\n                return merged;\n            }\n\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }\n            // Case: newOption: {width: ..., right: ...},\n            // Than we can make sure user only want those two, and ignore\n            // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            }\n            else {\n                // Chose another param from targetOption by priority.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n\n    module.exports = layout;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/layout.js\n// module id = 203\n// module chunks = 0 1 2 3 4 5 6","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * \n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/matrix.js\n// module id = 204\n// module chunks = 0 1 2 3 4 5 6","\n\n    var OrdinalScale = require('../scale/Ordinal');\n    var IntervalScale = require('../scale/Interval');\n    require('../scale/Time');\n    require('../scale/Log');\n    var Scale = require('../scale/Scale');\n\n    var numberUtil = require('../util/number');\n    var zrUtil = require('zrender/lib/core/util');\n    var textContain = require('zrender/lib/contain/text');\n    var axisHelper = {};\n\n    /**\n     * Get axis scale extent before niced.\n     * Item of returned array can only be number (including Infinity and NaN).\n     */\n    axisHelper.getScaleExtent = function (scale, model) {\n        var scaleType = scale.type;\n\n        var min = model.getMin();\n        var max = model.getMax();\n        var fixMin = min != null;\n        var fixMax = max != null;\n        var originalExtent = scale.getExtent();\n\n        var axisDataLen;\n        var boundaryGap;\n        var span;\n        if (scaleType === 'ordinal') {\n            axisDataLen = (model.get('data') || []).length;\n        }\n        else {\n            boundaryGap = model.get('boundaryGap');\n            if (!zrUtil.isArray(boundaryGap)) {\n                boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n            }\n            if (typeof boundaryGap[0] === 'boolean') {\n                if (__DEV__) {\n                    console.warn('Boolean type for boundaryGap is only '\n                        + 'allowed for ordinal axis. Please use string in '\n                        + 'percentage instead, e.g., \"20%\". Currently, '\n                        + 'boundaryGap is set to be 0.');\n                }\n                boundaryGap = [0, 0];\n            }\n            boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n            span = (originalExtent[1] - originalExtent[0])\n                || Math.abs(originalExtent[0]);\n        }\n\n        // Notice: When min/max is not set (that is, when there are null/undefined,\n        // which is the most common case), these cases should be ensured:\n        // (1) For 'ordinal', show all axis.data.\n        // (2) For others:\n        //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n        //      disabled).\n        //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n        //      be the result that originalExtent enlarged by boundaryGap.\n        // (3) If no data, it should be ensured that `scale.setBlank` is set.\n\n        // FIXME\n        // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n        // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n        // that the results processed by boundaryGap are positive/negative?\n\n        if (min == null) {\n            min = scaleType === 'ordinal'\n                ? (axisDataLen ? 0 : NaN)\n                : originalExtent[0] - boundaryGap[0] * span;\n        }\n        if (max == null) {\n            max = scaleType === 'ordinal'\n                ? (axisDataLen ? axisDataLen - 1 : NaN)\n                : originalExtent[1] + boundaryGap[1] * span;\n        }\n\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n\n        (min == null || !isFinite(min)) && (min = NaN);\n        (max == null || !isFinite(max)) && (max = NaN);\n\n        scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max));\n\n        // Evaluate if axis needs cross zero\n        if (model.getNeedCrossZero()) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n\n        return [min, max];\n    };\n\n    axisHelper.niceScaleExtent = function (scale, model) {\n        var extent = axisHelper.getScaleExtent(scale, model);\n        var fixMin = model.getMin() != null;\n        var fixMax = model.getMax() != null;\n        var splitNumber = model.get('splitNumber');\n\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent({\n            splitNumber: splitNumber,\n            fixMin: fixMin,\n            fixMax: fixMax,\n            minInterval: scale.type === 'interval' ? model.get('minInterval') : null\n        });\n\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function(model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n                // Buildin scale\n                case 'category':\n                    return new OrdinalScale(\n                        model.getCategories(), [Infinity, -Infinity]\n                    );\n                case 'value':\n                    return new IntervalScale();\n                // Extended scale, like time and log\n                default:\n                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n    };\n\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // axislabelhorizontalvertical.\n\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(\n                labels[i], font, 'center', 'top'\n            );\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }\n            // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            }\n            else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = (function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val != null ? val : '');\n                };\n            })(labelFormatter);\n            // Consider empty array\n            return zrUtil.map(labels, labelFormatter);\n        }\n        else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(\n                    axisHelper.getAxisRawValue(axis, tick),\n                    idx\n                );\n            }, this);\n        }\n        else {\n            return labels;\n        }\n    };\n\n    axisHelper.getAxisRawValue = function (axis, value) {\n        // In category axis with data zoom, tick is not the original\n        // index of axis.data. So tick should not be exposed to user\n        // in category axis.\n        return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n    };\n\n    module.exports = axisHelper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisHelper.js\n// module id = 205\n// module chunks = 0 1 2 3 4 5 6","\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText  Canvas \n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME \n        var lineHeight = getTextWidth('', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var lineHeight = textRect.lineHeight;\n        var halfHeight = height / 2 - textHeight / 2 + lineHeight;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight - lineHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance + lineHeight;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance + lineHeight;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance + lineHeight;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance + lineHeight;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'alphabetic'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/text.js\n// module id = 206\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // \n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} \n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] \n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out \n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/curve.js\n// module id = 207\n// module chunks = 0 1 2 3 4 5 6","/**\n * @module zrender/tool/color\n */\n\n\n    var LRU = require('../core/LRU');\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    function setRgba(out, r, g, b, a) {\n        out[0] = r; out[1] = g; out[2] = b; out[3] = a;\n        return out;\n    }\n    function copyRgba(out, a) {\n        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n        return out;\n    }\n    var colorCache = new LRU(20);\n    var lastRemovedArr = null;\n    function putToCache(colorStr, rgbaArr) {\n        // Reuse removed array\n        if (lastRemovedArr) {\n            copyRgba(lastRemovedArr, rgbaArr);\n        }\n        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n    }\n    /**\n     * @param {string} colorStr\n     * @param {Array.<number>} out\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr, rgbaArr) {\n        if (!colorStr) {\n            return;\n        }\n        rgbaArr = rgbaArr || [];\n\n        var cached = colorCache.get(colorStr);\n        if (cached) {\n            return copyRgba(rgbaArr, cached);\n        }\n\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            copyRgba(rgbaArr, kCSSColorTable[str]);\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    setRgba(rgbaArr,\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    );\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsla':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsl':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                default:\n                    return;\n            }\n        }\n\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla, rgba) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        rgba = rgba || [];\n        setRgba(rgba,\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),\n            1\n        );\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array.\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>} will be null/undefined if input illegal.\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        out = out || [];\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssFloat(lerp(leftColor[3], rightColor[3], dv));\n\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<number>} arrColor like [12,33,44,0.4]\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color. (If input illegal, return undefined).\n     */\n    function stringify(arrColor, type) {\n        if (!arrColor || !arrColor.length) {\n            return;\n        }\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/color.js\n// module id = 208\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = require('../mixin/Eventful');\n    var env = require('./env');\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * domtouch.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * preventDefault and stopPropagation.\n     * Notice: do not do that in zrender. Upper application\n     * do that if necessary.\n     *\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // \n        Dispatcher: Eventful\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/event.js\n// module id = 209\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * \n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * trigger\n         *\n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} [handler] \n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * \n         *\n         * @param {string} type \n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * context, context\n         * @param {string} type \n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    //  onxxxx \n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Eventful.js\n// module id = 210\n// module chunks = 0 1 2 3 4 5 6","/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array;\n\n    var dataCtors = {\n        'float': Float64Array,\n        'int': Int32Array,\n        // Ordinal data type can be string or int\n        'ordinal': Array,\n        'number': Array,\n        'time': Array\n    };\n\n    var Model = require('../model/Model');\n    var DataDiffer = require('./DataDiffer');\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var isObject = zrUtil.isObject;\n\n    var TRANSFERABLE_PROPERTIES = [\n        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n    ];\n\n    function transferProperties(a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n\n        a.__wrappedMethods = b.__wrappedMethods;\n    }\n\n    function DefaultDataProvider(dataArray) {\n        this._array = dataArray || [];\n    }\n\n    DefaultDataProvider.prototype.pure = false;\n\n    DefaultDataProvider.prototype.count = function () {\n        return this._array.length;\n    };\n    DefaultDataProvider.prototype.getItem = function (idx) {\n        return this._array[idx];\n    };\n\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string|Object>} dimensions\n     *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n     *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n\n        dimensions = dimensions || ['x', 'y'];\n\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    coordDim: dimensionName,\n                    coordDimIndex: 0,\n                    stackable: false,\n                    // Type can be 'float', 'int', 'number'\n                    // Default is number, Precision of float may not enough\n                    type: 'number'\n                };\n            }\n            else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n                if (!dimensionInfo.coordDim) {\n                    dimensionInfo.coordDim = dimensionName;\n                    dimensionInfo.coordDimIndex = 0;\n                }\n            }\n            dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n\n    var listProto = List.prototype;\n\n    listProto.type = 'list';\n\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n\n        var isDataArray = zrUtil.isArray(data);\n        if (isDataArray) {\n            data = new DefaultDataProvider(data);\n        }\n        if (__DEV__) {\n            if (!isDataArray && (typeof data.getItem != 'function' || typeof data.count != 'function')) {\n                throw new Error('Inavlid data provider.');\n            }\n        }\n\n        this._rawData = data;\n\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n\n        var dimensions = this.dimensions;\n        var dimensionInfoMap = this._dimensionInfos;\n\n        var size = data.count();\n\n        var idList = [];\n        var nameRepeatCount = {};\n        var nameDimIdx;\n\n        nameList = nameList || [];\n\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(\n                (value instanceof Array)\n                    ? value[dimIndex]\n                    // If value is a single number or something else not array.\n                    : value,\n                dimensionInfoMap[dimName]\n            );\n        };\n\n        for (var i = 0; i < size; i++) {\n            // NOTICE: Try not to write things into dataItem\n            var dataItem = data.getItem(i);\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[i] = dimValueGetter(dataItem, dim, i, k);\n            }\n\n            indices.push(i);\n        }\n\n        // Use the name in option and create id\n        for (var i = 0; i < size; i++) {\n            var dataItem = data.getItem(i);\n            if (!nameList[i] && dataItem) {\n                if (dataItem.name != null) {\n                    nameList[i] = dataItem.name;\n                }\n                else if (nameDimIdx != null) {\n                    nameList[i] = storage[dimensions[nameDimIdx]][i];\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = dataItem && dataItem.id;\n\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n\n        // If value not exists\n        if (dataIndex == null || !storage[dim]) {\n            return NaN;\n        }\n\n        var value = storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n                        || (value <= 0 && stackedValue < 0) // Negative stack\n                    ) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n\n        return values;\n    };\n\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (\n                // Ordinal type can be string or number\n                dimensionInfos[dimensions[i]].type !== 'ordinal'\n                && isNaN(this.get(dimensions[i], idx))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     * @param {Function} filter\n     */\n    listProto.getDataExtent = function (dim, stack, filter) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = (dimInfo && dimInfo.stackable) && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                if (!filter || filter(value, dim, i)) {\n                    value < min && (min = value);\n                    value > max && (max = value);\n                }\n            }\n            return (this._extent[dim + !!stack] = [min, max]);\n        }\n        else {\n            return [Infinity, -Infinity];\n        }\n    };\n\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n\n        // If rawIndex === dataIndex\n        var rawDataIndex = indices[rawIndex];\n        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n            return rawIndex;\n        }\n\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            }\n            else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {Array.<number>} Considere multiple points has the same value.\n     */\n    listProto.indicesOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var nearestIndices = [];\n\n        if (!dimData) {\n            return nearestIndices;\n        }\n\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n\n        var minDist = Number.MAX_VALUE;\n        var minDiff = -1;\n        for (var i = 0, len = this.count(); i < len; i++) {\n            var diff = value - this.get(dim, i, stack);\n            var dist = Math.abs(diff);\n            if (diff <= maxDistance && dist <= minDist) {\n                // For the case of two data are same on xAxis, which has sequence data.\n                // Show the nearest index\n                // https://github.com/ecomfe/echarts/issues/2869\n                if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                    minDist = dist;\n                    minDiff = diff;\n                    nearestIndices.length = 0;\n                }\n                nearestIndices.push(i);\n            }\n        }\n        return nearestIndices;\n    };\n\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData.getItem(this.getRawIndex(idx));\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n    };\n\n\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n                case 0:\n                    cb.call(context, i);\n                    break;\n                case 1:\n                    cb.call(context, this.get(dims[0], i, stack), i);\n                    break;\n                case 2:\n                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                    break;\n                default:\n                    for (var k = 0; k < dimSize; k++) {\n                        value[k] = this.get(dims[k], i, stack);\n                    }\n                    // Index\n                    value[k] = i;\n                    cb.apply(context, value);\n            }\n        }\n    };\n\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (!dimSize) {\n                keep = cb.call(context, i);\n            }\n            else if (dimSize === 1) {\n                keep = cb.call(\n                    context, this.get(dimensions[0], i, stack), i\n                );\n            }\n            else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n\n        this.indices = newIndices;\n\n        // Reset data extent\n        this._extent = {};\n\n        return this;\n    };\n\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(\n            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n            original.hostModel\n        );\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(\n                    originalStorage[dim].length\n                );\n            }\n            else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n\n        var storage = list._storage;\n\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n\n        return list;\n    };\n\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n\n        return list;\n    };\n\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);\n    };\n\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        var val;\n        // Use prefix to avoid index to be the same as otherIdList[idx],\n        // which will cause weird udpate animation.\n        var prefix = 'e\\0\\0';\n\n        return new DataDiffer(\n            otherList ? otherList.indices : [],\n            this.indices,\n            function (idx) {\n                return (val = otherIdList[idx]) != null ? val : prefix + idx;\n            },\n            function (idx) {\n                return (val = idList[idx]) != null ? val : prefix + idx;\n            }\n        );\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge\n            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n            : layout;\n    };\n\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} [ignoreParent=false]\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n\n        this._graphicEls[idx] = el;\n    };\n\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n\n        // FIXME\n        list._storage = this._storage;\n\n        transferProperties(list, this);\n\n\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n\n        return list;\n    };\n\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\n    module.exports = List;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/List.js\n// module id = 211\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    // var CMD_MEM_SIZE = {\n    //     M: 3,\n    //     L: 3,\n    //     C: 7,\n    //     Q: 5,\n    //     A: 9,\n    //     R: 5,\n    //     Z: 1\n    // };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function (notSaveData) {\n\n        this._saveData = !(notSaveData || false);\n\n        if (this._saveData) {\n            /**\n             * Path data. Stored as flat array\n             * @type {Array.<Object>}\n             */\n            this.data = [];\n        }\n\n        this._ctx = null;\n    };\n\n    /**\n     * Path\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _xi: 0,\n        _yi: 0,\n\n        _x0: 0,\n        _y0: 0,\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        _ux: 0,\n        _uy: 0,\n\n        _len: 0,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            if (this._saveData) {\n                this._len = 0;\n            }\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi  _dashedXXXXTo \n            // xi, yi , x0, y0  closePath \n            //  beginPath  lineTo x0, y0 \n            //  lineTo dashed line  IE10- \n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._yi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context  rebuildPath  fill\n         * stroke \n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         *  Path \n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * \n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         *  Path \n         * \n         */\n        addData: function (cmd) {\n            if (!this._saveData) {\n                return;\n            }\n\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                //  Float32Array\n                // \n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         *  Float32Array \n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo  subpath, \n                        //  closePath \n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc \n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc \n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/PathProxy.js\n// module id = 212\n// module chunks = 0 1 2 3 4 5 6","/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n\n    var clazzUtil = require('../util/clazz');\n\n    /**\n     * @param {Object} [setting]\n     */\n    function Scale(setting) {\n        this._setting = setting || {};\n\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [Infinity, -Infinity];\n\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n\n        this.init && this.init.apply(this, arguments);\n    }\n\n    var scaleProto = Scale.prototype;\n\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n\n    scaleProto.getSetting = function (name) {\n        return this._setting[name];\n    };\n\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        // not setExtent because in log axis it may transformed to power\n        // this.setExtent(extent[0], extent[1]);\n    };\n\n    /**\n     * Set extent from data\n     * @param {module:echarts/data/List} data\n     * @param {string} dim\n     */\n    scaleProto.unionExtentFromData = function (data, dim) {\n        this.unionExtent(data.getDataExtent(dim, true));\n    };\n\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.isBlank = function () {\n        return this._isBlank;\n    },\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.setBlank = function (isBlank) {\n        this._isBlank = isBlank;\n    };\n\n\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, {\n        registerWhenExtend: true\n    });\n\n    module.exports = Scale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Scale.js\n// module id = 213\n// module chunks = 0 1 2 3 4 5 6","\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config\n     * @exports zrender/config\n     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debugcatchBrushExceptiontrue\n         * 0 : debug\n         * 1 : \n         * 2 : \n         */\n        debugMode: 0,\n\n        // retina \n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/config.js\n// module id = 214\n// module chunks = 0 1 2 3 4 5 6","/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * \n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         *  index \n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * \n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         *  nextSibling \n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToStorage(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromStorage(child);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * \n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromStorage(child);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToStorage(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromStorage(child);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/container/Group.js\n// module id = 215\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var coordinateSystemCreators = {};\n\n    function CoordinateSystemManager() {\n\n        this._coordinateSystems = [];\n    }\n\n    CoordinateSystemManager.prototype = {\n\n        constructor: CoordinateSystemManager,\n\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n                var list = creater.create(ecModel, api);\n                coordinateSystems = coordinateSystems.concat(list || []);\n            });\n\n            this._coordinateSystems = coordinateSystems;\n        },\n\n        update: function (ecModel, api) {\n            zrUtil.each(this._coordinateSystems, function (coordSys) {\n                // FIXME MUST have\n                coordSys.update && coordSys.update(ecModel, api);\n            });\n        },\n\n        getCoordinateSystems: function () {\n            return this._coordinateSystems.slice();\n        }\n    };\n\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n\n    module.exports = CoordinateSystemManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/CoordinateSystem.js\n// module id = 216\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../util/format');\n    var classUtil = require('../util/clazz');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var colorPaletteMixin = require('./mixin/colorPalette');\n    var env = require('zrender/lib/core/env');\n    var layout = require('../util/layout');\n\n    var set = classUtil.set;\n    var get = classUtil.get;\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            var data = this.getInitialData(option, ecModel);\n            if (__DEV__) {\n                zrUtil.assert(data, 'getInitialData returned invalid data.');\n            }\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            set(this, 'dataBeforeProcessed', data);\n\n            // If we reverse the order (make data firstly, and then make\n            // dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause data.graph.data !== data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this.restoreData();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `position` and `show`\n            // FIXME Set label in mergeOption\n            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\n            this.fillDataTextStyle(option.data);\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n            }\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                set(this, 'data', data);\n                set(this, 'dataBeforeProcessed', data.cloneShallow());\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `position` and `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            var data = get(this, 'data');\n            return dataType == null ? data : data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            set(this, 'data', data);\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return get(this, 'dataBeforeProcessed');\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return modelUtil.coordDimToDataDim(this.getData(), coordDim);\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return modelUtil.dataDimToCoordDim(this.getData(), dataDim);\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var vertially = zrUtil.reduce(value, function (vertially, val, idx) {\n                    var dimItem = data.getDimensionInfo(idx);\n                    return vertially |= dimItem && dimItem.tooltip !== false && dimItem.tooltipName != null;\n                }, 0);\n\n                var result = [];\n                var tooltipDims = modelUtil.otherDimToDataDim(data, 'tooltip');\n\n                tooltipDims.length\n                    ? zrUtil.each(tooltipDims, function (dimIdx) {\n                        setEachItem(data.get(dimIdx, dataIndex), dimIdx);\n                    })\n                    // By default, all dims is used on tooltip.\n                    : zrUtil.each(value, setEachItem);\n\n                function setEachItem(val, dimIdx) {\n                    var dimInfo = data.getDimensionInfo(dimIdx);\n                    // If `dimInfo.tooltip` is not set, show tooltip.\n                    if (!dimInfo || dimInfo.otherDims.tooltip === false) {\n                        return;\n                    }\n                    var dimType = dimInfo.type;\n                    var valStr = (vertially ? '- ' + (dimInfo.tooltipName || dimInfo.name) + ': ' : '')\n                        + (dimType === 'ordinal'\n                            ? val + ''\n                            : dimType === 'time'\n                            ? (multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val))\n                            : addCommas(val)\n                        );\n                    valStr && result.push(encodeHTML(valStr));\n                }\n\n                return (vertially ? '<br/>' : '') + result.join(vertially ? '<br/>' : ', ');\n            }\n\n            var data = get(this, 'data');\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = zrUtil.isArray(value)\n                ? formatArrayValue(value) : encodeHTML(addCommas(value));\n            var name = data.getName(dataIndex);\n\n            var color = data.getItemVisual(dataIndex, 'color');\n            if (zrUtil.isObject(color) && color.colorStops) {\n                color = (color.colorStops[0] || {}).color;\n            }\n            color = color || 'transparent';\n\n            var colorEl = formatUtil.getTooltipMarker(color);\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            seriesName = seriesName\n                ? encodeHTML(seriesName) + (!multipleSeries ? '<br/>' : ': ')\n                : '';\n            return !multipleSeries\n                ? seriesName + colorEl\n                    + (name\n                        ? encodeHTML(name) + ': ' + formattedValue\n                        : formattedValue\n                    )\n                : colorEl + seriesName + formattedValue;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        isAnimationEnabled: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Object} {dataIndices, nestestValue}.\n         */\n        getAxisTooltipData: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Series.js\n// module id = 217\n// module chunks = 0 1 2 3 4 5 6","/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var each = zrUtil.each;\n    var isString = zrUtil.isString;\n    var defaults = zrUtil.defaults;\n    var normalizeToArray = modelUtil.normalizeToArray;\n\n    var OTHER_DIMS = {tooltip: 1, label: 1, itemName: 1};\n\n    /**\n     * Complete the dimensions array, by user defined `dimension` and `encode`,\n     * and guessing from the data structure.\n     * If no 'value' dimension specified, the first no-named dimension will be\n     * named as 'value'.\n     *\n     * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which\n     *      provides not only dim template, but also default order.\n     *      `name` of each item provides default coord name.\n     *      [{dimsDef: []}, ...] can be specified to give names.\n     * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].\n     * @param {Object} [opt]\n     * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions\n     *      For example: ['asdf', {name, type}, ...].\n     * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}\n     * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.\n     * @param {string} [opt.extraFromZero] If specified, extra dim names will be:\n     *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...\n     *                      If not specified, extra dim names will be:\n     *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...\n     * @param {number} [opt.dimCount] If not specified, guess by the first data item.\n     * @return {Array.<Object>} [{\n     *      name: string mandatory,\n     *      coordDim: string mandatory,\n     *      coordDimIndex: number mandatory,\n     *      type: string optional,\n     *      tooltipName: string optional,\n     *      otherDims: {\n     *          tooltip: number optional,\n     *          label: number optional\n     *      },\n     *      isExtraCoord: boolean true or undefined.\n     *      other props ...\n     * }]\n     */\n    function completeDimensions(sysDims, data, opt) {\n        data = data || [];\n        opt = opt || {};\n        sysDims = (sysDims || []).slice();\n        var dimsDef = (opt.dimsDef || []).slice();\n        var encodeDef = zrUtil.createHashMap(opt.encodeDef);\n        var dataDimNameMap = zrUtil.createHashMap();\n        var coordDimNameMap = zrUtil.createHashMap();\n        // var valueCandidate;\n        var result = [];\n\n        var dimCount = opt.dimCount;\n        if (dimCount == null) {\n            var value0 = retrieveValue(data[0]);\n            dimCount = Math.max(\n                zrUtil.isArray(value0) && value0.length || 1,\n                sysDims.length,\n                dimsDef.length\n            );\n            each(sysDims, function (sysDimItem) {\n                var sysDimItemDimsDef = sysDimItem.dimsDef;\n                sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));\n            });\n        }\n\n        // Apply user defined dims (`name` and `type`) and init result.\n        for (var i = 0; i < dimCount; i++) {\n            var dimDefItem = isString(dimsDef[i]) ? {name: dimsDef[i]} : (dimsDef[i] || {});\n            var userDimName = dimDefItem.name;\n            var resultItem = result[i] = {otherDims: {}};\n            // Name will be applied later for avoiding duplication.\n            if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n                // Only if `series.dimensions` is defined in option, tooltipName\n                // will be set, and dimension will be diplayed vertically in\n                // tooltip by default.\n                resultItem.name = resultItem.tooltipName = userDimName;\n                dataDimNameMap.set(userDimName, i);\n            }\n            dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n        }\n\n        // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.\n        encodeDef.each(function (dataDims, coordDim) {\n            dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice());\n            each(dataDims, function (resultDimIdx, coordDimIndex) {\n                // The input resultDimIdx can be dim name or index.\n                isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));\n                if (resultDimIdx != null && resultDimIdx < dimCount) {\n                    dataDims[coordDimIndex] = resultDimIdx;\n                    applyDim(result[resultDimIdx], coordDim, coordDimIndex);\n                }\n            });\n        });\n\n        // Apply templetes and default order from `sysDims`.\n        var availDimIdx = 0;\n        each(sysDims, function (sysDimItem, sysDimIndex) {\n            var coordDim;\n            var sysDimItem;\n            var sysDimItemDimsDef;\n            var sysDimItemOtherDims;\n            if (isString(sysDimItem)) {\n                coordDim = sysDimItem;\n                sysDimItem = {};\n            }\n            else {\n                coordDim = sysDimItem.name;\n                sysDimItem = zrUtil.clone(sysDimItem);\n                // `coordDimIndex` should not be set directly.\n                sysDimItemDimsDef = sysDimItem.dimsDef;\n                sysDimItemOtherDims = sysDimItem.otherDims;\n                sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex\n                    = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n            }\n\n            var dataDims = normalizeToArray(encodeDef.get(coordDim));\n            // dimensions provides default dim sequences.\n            if (!dataDims.length) {\n                for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n                    while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n                        availDimIdx++;\n                    }\n                    availDimIdx < result.length && dataDims.push(availDimIdx++);\n                }\n            }\n            // Apply templates.\n            each(dataDims, function (resultDimIdx, coordDimIndex) {\n                var resultItem = result[resultDimIdx];\n                applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n                if (resultItem.name == null && sysDimItemDimsDef) {\n                    resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];\n                }\n                sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n            });\n        });\n\n        // Make sure the first extra dim is 'value'.\n        var extra = opt.extraPrefix || 'value';\n\n        // Set dim `name` and other `coordDim` and other props.\n        for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n            var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};\n            var coordDim = resultItem.coordDim;\n\n            coordDim == null && (\n                resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero),\n                resultItem.coordDimIndex = 0,\n                resultItem.isExtraCoord = true\n            );\n\n            resultItem.name == null && (resultItem.name = genName(\n                resultItem.coordDim,\n                dataDimNameMap\n            ));\n\n            resultItem.type == null && guessOrdinal(data, resultDimIdx)\n                && (resultItem.type = 'ordinal');\n        }\n\n        return result;\n\n        function applyDim(resultItem, coordDim, coordDimIndex) {\n            if (OTHER_DIMS[coordDim]) {\n                resultItem.otherDims[coordDim] = coordDimIndex;\n            }\n            else {\n                resultItem.coordDim = coordDim;\n                resultItem.coordDimIndex = coordDimIndex;\n                coordDimNameMap.set(coordDim, true);\n            }\n        }\n\n        function genName(name, map, fromZero) {\n            if (fromZero || map.get(name) != null) {\n                var i = 0;\n                while (map.get(name + i) != null) {\n                    i++;\n                }\n                name += i;\n            }\n            map.set(name, true);\n            return name;\n        }\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            // Consider usage convenience, '1', '2' will be treated as \"number\".\n            if (value != null && isFinite(value)) {\n                return false;\n            }\n            else if (isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/helper/completeDimensions.js\n// module id = 218\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n// Symbol factory\n\n\n    var graphic = require('./graphic');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME  onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            // TODO Support image object, DynamicImage.\n\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/symbol.js\n// module id = 219\n// module chunks = 0 1 2 3 4 5 6","// TODO Parse shadow style\n// TODO Only shallow path support\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n               properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes, includes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if ((excludes && zrUtil.indexOf(excludes, propName) >= 0)\n                    || (includes && zrUtil.indexOf(includes, propName) < 0)\n                ) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/makeStyleMapper.js\n// module id = 220\n// module chunks = 0 1 2 3 4 5 6","/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\n\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var Scale = require('./Scale');\n    var helper = require('./helper');\n\n    var roundNumber = numberUtil.round;\n\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n\n        type: 'interval',\n\n        _interval: 0,\n\n        _intervalPrecision: 2,\n\n        setExtent: function (start, end) {\n            var thisExtent = this._extent;\n            //start,end may be a Number like '25',so...\n            if (!isNaN(start)) {\n                thisExtent[0] = parseFloat(start);\n            }\n            if (!isNaN(end)) {\n                thisExtent[1] = parseFloat(end);\n            }\n        },\n\n        unionExtent: function (other) {\n            var extent = this._extent;\n            other[0] < extent[0] && (extent[0] = other[0]);\n            other[1] > extent[1] && (extent[1] = other[1]);\n\n            // unionExtent may called by it's sub classes\n            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n        },\n        /**\n         * Get interval\n         */\n        getInterval: function () {\n            return this._interval;\n        },\n\n        /**\n         * Set interval\n         */\n        setInterval: function (interval) {\n            this._interval = interval;\n            // Dropped auto calculated niceExtent and use user setted extent\n            // We assume user wan't to set both interval, min, max to get a better result\n            this._niceExtent = this._extent.slice();\n\n            this._intervalPrecision = helper.getIntervalPrecision(interval);\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            return helper.intervalScaleGetTicks(\n                this._interval, this._extent, this._niceExtent, this._intervalPrecision\n            );\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getTicksLabels: function () {\n            var labels = [];\n            var ticks = this.getTicks();\n            for (var i = 0; i < ticks.length; i++) {\n                labels.push(this.getLabel(ticks[i]));\n            }\n            return labels;\n        },\n\n        /**\n         * @param {number} data\n         * @param {Object} [opt]\n         * @param {number|string} [opt.precision] If 'auto', use nice presision.\n         * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n         * @return {string}\n         */\n        getLabel: function (data, opt) {\n            if (data == null) {\n                return '';\n            }\n\n            var precision = opt && opt.precision;\n\n            if (precision == null) {\n                precision = numberUtil.getPrecisionSafe(data) || 0;\n            }\n            else if (precision === 'auto') {\n                // Should be more precise then tick.\n                precision = this._intervalPrecision;\n            }\n\n            // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n            // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n            data = roundNumber(data, precision, true);\n\n            return formatUtil.addCommas(data);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         *\n         * @param {number} [splitNumber = 5] Desired number of ticks\n         * @param {number} [minInterval]\n         */\n        niceTicks: function (splitNumber, minInterval) {\n            splitNumber = splitNumber || 5;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (!isFinite(span)) {\n                return;\n            }\n            // User may set axis min 0 and data are all negative\n            // FIXME If it needs to reverse ?\n            if (span < 0) {\n                span = -span;\n                extent.reverse();\n            }\n\n            var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval);\n\n            this._intervalPrecision = result.intervalPrecision;\n            this._interval = result.interval;\n            this._niceExtent = result.niceTickExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {Object} opt\n         * @param {number} [opt.splitNumber = 5] Given approx tick number\n         * @param {boolean} [opt.fixMin=false]\n         * @param {boolean} [opt.fixMax=false]\n         * @param {boolean} [opt.minInterval=false]\n         */\n        niceExtent: function (opt) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                if (extent[0] !== 0) {\n                    // Expand extent\n                    var expandSize = extent[0];\n                    // In the fowllowing case\n                    //      Axis has been fixed max 100\n                    //      Plus data are all 100 and axis extent are [100, 100].\n                    // Extend to the both side will cause expanded max is larger than fixed max.\n                    // So only expand to the smaller side.\n                    if (!opt.fixMax) {\n                        extent[1] += expandSize / 2;\n                        extent[0] -= expandSize / 2;\n                    }\n                    else {\n                        extent[0] -= expandSize / 2;\n                    }\n                }\n                else {\n                    extent[1] = 1;\n                }\n            }\n            var span = extent[1] - extent[0];\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (!isFinite(span)) {\n                extent[0] = 0;\n                extent[1] = 1;\n            }\n\n            this.niceTicks(opt.splitNumber, opt.minInterval);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!opt.fixMin) {\n                extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n            }\n            if (!opt.fixMax) {\n                extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n            }\n        }\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n\n    module.exports = IntervalScale;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Interval.js\n// module id = 222\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = require('../core/util');\n\n    var Style = require('./Style');\n\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable Painter \n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * true\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * zlevelcanvas\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * \n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * \n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         *  x, y \n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         *  x, y \n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * \n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * \n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO,  bind \n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Displayable.js\n// module id = 223\n// module chunks = 0 1 2 3 4 5 6","\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Gradient.js\n// module id = 224\n// module chunks = 0 1 2 3 4 5 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazz = require('./clazz');\n\n    var parseClassType = clazz.parseClassType;\n\n    var base = 0;\n\n    var componentUtil = {};\n\n    var DELIMITER = '_';\n\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [(type || ''), base++, Math.random()].join(DELIMITER);\n    };\n\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n\n        var subTypeDefaulters = {};\n\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n\n        return entity;\n    };\n\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(\n                    currVertex.successor,\n                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n                );\n            }\n\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n\n            zrUtil.each(fullNameList, function (name) {\n\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n\n            return {graph: graph, noEntryList: noEntryList};\n        }\n\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {predecessor: [], successor: []};\n            }\n            return graph[name];\n        }\n\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n\n    module.exports = componentUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/component.js\n// module id = 225\n// module chunks = 0 1 2 3 4 5 6","// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/timsort.js\n// module id = 226\n// module chunks = 0 1 2 3 4 5 6","\n\n    var numberUtil = require('../util/number');\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('./axisHelper');\n\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n\n    var normalizedExtent = [0, 1];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [0, 0];\n\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._labelInterval;\n    };\n\n    Axis.prototype = {\n\n        constructor: Axis,\n\n        /**\n         * If axis extent contain given coord\n         * @param {number} coord\n         * @return {boolean}\n         */\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n\n        /**\n         * If axis extent contain given data\n         * @param {number} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n\n        /**\n         * Get coord extent.\n         * @return {Array.<number>}\n         */\n        getExtent: function () {\n            return this._extent.slice();\n        },\n\n        /**\n         * Get precision used for formatting\n         * @param {Array.<number>} [dataExtent]\n         * @return {number}\n         */\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(\n                dataExtent || this.scale.getExtent(),\n                this._extent\n            );\n        },\n\n        /**\n         * Set coord extent\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n\n        /**\n         * Convert data to coord. Data is the rank if it has a ordinal scale\n         * @param {number} data\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n\n        /**\n         * Convert coord to data. Data is the rank if it has a ordinal scale\n         * @param {number} coord\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\n            return this.scale.scale(t);\n        },\n\n        /**\n         * Convert pixel point to data in axis\n         * @param {Array.<number>} point\n         * @param  {boolean} clamp\n         * @return {number} data\n         */\n        pointToData: function (point, clamp) {\n            // Should be implemented in derived class if necessary.\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            }\n            else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n\n        /**\n         * Coords of labels are on the ticks or on the middle of bands\n         * @return {Array.<number>}\n         */\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n\n        /**\n         * Get bands.\n         *\n         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n         * |---1---|---2---|---3---|---4---|.\n         *\n         * @return {Array}\n         */\n         // FIXME Situation when labels is on ticks\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n\n        /**\n         * Get width of band\n         * @return {number}\n         */\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n            return Math.abs(size) / len;\n        },\n\n        /**\n         * Get interval of the axis label.\n         * @return {number}\n         */\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                var axisModel = this.model;\n                var labelModel = axisModel.getModel('axisLabel');\n                var interval = labelModel.get('interval');\n                if (!(this.type === 'category' && interval === 'auto')) {\n                    labelInterval = interval === 'auto' ? 0 : interval;\n                }\n                else if (this.isHorizontal){\n                    labelInterval = axisHelper.getAxisLabelInterval(\n                        zrUtil.map(this.scale.getTicks(), this.dataToCoord, this),\n                        axisModel.getFormattedLabels(),\n                        labelModel.getModel('textStyle').getFont(),\n                        this.isHorizontal()\n                    );\n                }\n                this._labelInterval = labelInterval;\n            }\n            return labelInterval;\n        }\n\n    };\n\n    module.exports = Axis;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/Axis.js\n// module id = 227\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var List = require('../../data/List');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var CoordinateSystem = require('../../CoordinateSystem');\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null\n            && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        var completeDimOpt = {\n            encodeDef: seriesModel.get('encode'),\n            dimsDef: seriesModel.get('dimensions')\n        };\n\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = (registeredCoordSys && (\n                registeredCoordSys.getDimensionsInfo\n                    ? registeredCoordSys.getDimensionsInfo()\n                    : registeredCoordSys.dimensions.slice()\n            )) || ['x', 'y'];\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n        }\n\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n        var list = new List(dimensions, seriesModel);\n\n        var nameList = createNameList(axesInfo, data);\n\n        var categories = {};\n        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex\n                    ? dataIndex\n                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            }\n            : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName]\n                            || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n\n        return list;\n    }\n\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category'\n            ? 'ordinal'\n            : axisType === 'time'\n            ? 'time'\n            : 'float';\n    }\n\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n\n        cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) {\n\n            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n                return ecModel.queryComponents({\n                    mainType: name,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n            });\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (__DEV__) {\n                if (!xAxisModel) {\n                    throw new Error('xAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('xAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n                if (!yAxisModel) {\n                    throw new Error('yAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('yAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n\n            var xAxisType = xAxisModel.get('type');\n            var yAxisType = yAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'x',\n                    type: getDimTypeByAxis(xAxisType),\n                    stackable: isStackable(xAxisType)\n                },\n                {\n                    name: 'y',\n                    // If two category axes\n                    type: getDimTypeByAxis(yAxisType),\n                    stackable: isStackable(yAxisType)\n                }\n            ];\n\n            var isXAxisCateogry = xAxisType === 'category';\n            var isYAxisCategory = yAxisType === 'category';\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isXAxisCateogry) {\n                categoryAxesModels.x = xAxisModel;\n            }\n            if (isYAxisCategory) {\n                categoryAxesModels.y = yAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        singleAxis: function (data, seriesModel, ecModel, completeDimOpt) {\n\n            var singleAxisModel = ecModel.queryComponents({\n                mainType: 'singleAxis',\n                index: seriesModel.get('singleAxisIndex'),\n                id: seriesModel.get('singleAxisId')\n            })[0];\n\n            if (__DEV__) {\n                if (!singleAxisModel) {\n                    throw new Error('singleAxis should be specified.');\n                }\n            }\n\n            var singleAxisType = singleAxisModel.get('type');\n            var isCategory = singleAxisType === 'category';\n\n            var dimensions = [{\n                name: 'single',\n                type: getDimTypeByAxis(singleAxisType),\n                stackable: isStackable(singleAxisType)\n            }];\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isCategory) {\n                categoryAxesModels.single = singleAxisModel;\n            }\n\n            return {\n                dimensions: dimensions,\n                categoryIndex: isCategory ? 0 : -1,\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        polar: function (data, seriesModel, ecModel, completeDimOpt) {\n            var polarModel = ecModel.queryComponents({\n                mainType: 'polar',\n                index: seriesModel.get('polarIndex'),\n                id: seriesModel.get('polarId')\n            })[0];\n\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n            if (__DEV__) {\n                if (!angleAxisModel) {\n                    throw new Error('angleAxis option not found');\n                }\n                if (!radiusAxisModel) {\n                    throw new Error('radiusAxis option not found');\n                }\n            }\n\n            var radiusAxisType = radiusAxisModel.get('type');\n            var angleAxisType = angleAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'radius',\n                    type: getDimTypeByAxis(radiusAxisType),\n                    stackable: isStackable(radiusAxisType)\n                },\n                {\n                    name: 'angle',\n                    type: getDimTypeByAxis(angleAxisType),\n                    stackable: isStackable(angleAxisType)\n                }\n            ];\n            var isAngleAxisCateogry = angleAxisType === 'category';\n            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isRadiusAxisCateogry) {\n                categoryAxesModels.radius = radiusAxisModel;\n            }\n            if (isAngleAxisCateogry) {\n                categoryAxesModels.angle = angleAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        geo: function (data, seriesModel, ecModel, completeDimOpt) {\n            // TODO Region\n            // \n            return {\n                dimensions: completeDimensions([\n                    {name: 'lng'},\n                    {name: 'lat'}\n                ], data, completeDimOpt)\n            };\n        }\n    };\n\n    function createNameList(result, data) {\n        var nameList = [];\n\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                }\n                else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n\n        return nameList;\n    }\n\n    module.exports = createListFromArray;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/helper/createListFromArray.js\n// module id = 228\n// module chunks = 0 1 2 3 4 5 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n    var Model = require('../../model/Model');\n    var numberUtil = require('../../util/number');\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = require('zrender/lib/core/vector');\n    var matrix = require('zrender/lib/core/matrix');\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n\n    var PI = Math.PI;\n\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = {\n            componentType: axisModel.mainType\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     * @param {number} [opt.nameTruncateMaxWidth]\n     */\n    var AxisBuilder = function (axisModel, opt) {\n\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n\n        // Default value\n        zrUtil.defaults(\n            opt,\n            {\n                labelOffset: 0,\n                nameDirection: 1,\n                tickDirection: 1,\n                labelDirection: 1,\n                silent: true\n            }\n        );\n\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n            position: opt.position.slice(),\n            rotation: opt.rotation\n        });\n\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n\n        this._dumbGroup = dumbGroup;\n    };\n\n    AxisBuilder.prototype = {\n\n        constructor: AxisBuilder,\n\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n\n        add: function (name) {\n            builders[name].call(this);\n        },\n\n        getGroup: function () {\n            return this.group;\n        }\n\n    };\n\n    var builders = {\n\n        /**\n         * @private\n         */\n        axisLine: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisLine.show')) {\n                return;\n            }\n\n            var extent = this.axisModel.axis.getExtent();\n\n            var matrix = this._transform;\n            var pt1 = [extent[0], 0];\n            var pt2 = [extent[1], 0];\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n\n            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                // Id for animation\n                anid: 'line',\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.extend(\n                    {lineCap: 'round'},\n                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n                ),\n                strokeContainThreshold: opt.strokeContainThreshold || 5,\n                silent: true,\n                z2: 1\n            })));\n        },\n\n        /**\n         * @private\n         */\n        axisTick: function () {\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n\n            if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n                return;\n            }\n\n            var tickModel = axisModel.getModel('axisTick');\n            var opt = this.opt;\n\n            var lineStyleModel = tickModel.getModel('lineStyle');\n            var tickLen = tickModel.get('length');\n\n            var tickInterval = getInterval(tickModel, opt.labelInterval);\n            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n            var ticks = axis.scale.getTicks();\n\n            var pt1 = [];\n            var pt2 = [];\n            var matrix = this._transform;\n\n            for (var i = 0; i < ticksCoords.length; i++) {\n                // Only ordinal scale support tick interval\n                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                     continue;\n                }\n\n                var tickCoord = ticksCoords[i];\n\n                pt1[0] = tickCoord;\n                pt1[1] = 0;\n                pt2[0] = tickCoord;\n                pt2[1] = opt.tickDirection * tickLen;\n\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                // Tick line, Not use group transform to have better line draw\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                    // Id for animation\n                    anid: 'tick_' + ticks[i],\n\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.defaults(\n                        lineStyleModel.getLineStyle(),\n                        {\n                            stroke: axisModel.get('axisLine.lineStyle.color')\n                        }\n                    ),\n                    z2: 2,\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @private\n         */\n        axisLabel: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n            if (!show || axis.scale.isBlank()) {\n                return;\n            }\n\n            var labelModel = axisModel.getModel('axisLabel');\n            var textStyleModel = labelModel.getModel('textStyle');\n            var labelMargin = labelModel.get('margin');\n            var ticks = axis.scale.getTicks();\n            var labels = axisModel.getFormattedLabels();\n\n            // Special label rotate.\n            var labelRotation = (\n                retrieve(opt.labelRotate, labelModel.get('rotate')) || 0\n            ) * PI / 180;\n\n            var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n            var categoryData = axisModel.get('data');\n\n            var textEls = [];\n            var silent = isSilent(axisModel);\n            var triggerEvent = axisModel.get('triggerEvent');\n\n            zrUtil.each(ticks, function (tickVal, index) {\n                if (ifIgnoreOnTick(axis, index, opt.labelInterval)) {\n                     return;\n                }\n\n                var itemTextStyleModel = textStyleModel;\n                if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n                    itemTextStyleModel = new Model(\n                        categoryData[tickVal].textStyle, textStyleModel, axisModel.ecModel\n                    );\n                }\n                var textColor = itemTextStyleModel.getTextColor()\n                    || axisModel.get('axisLine.lineStyle.color');\n\n                var tickCoord = axis.dataToCoord(tickVal);\n                var pos = [\n                    tickCoord,\n                    opt.labelOffset + opt.labelDirection * labelMargin\n                ];\n                var labelStr = axis.scale.getLabel(tickVal);\n\n                var textEl = new graphic.Text({\n\n                    // Id for animation\n                    anid: 'label_' + tickVal,\n\n                    style: {\n                        text: labels[index],\n                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.textVerticalAlign,\n                        textFont: itemTextStyleModel.getFont(),\n                        fill: typeof textColor === 'function'\n                            ? textColor(\n                                // (1) In category axis with data zoom, tick is not the original\n                                // index of axis.data. So tick should not be exposed to user\n                                // in category axis.\n                                // (2) Compatible with previous version, which always returns labelStr.\n                                // But in interval scale labelStr is like '223,445', which maked\n                                // user repalce ','. So we modify it to return original val but remain\n                                // it as 'string' to avoid error in replacing.\n                                axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal,\n                                index\n                            )\n                            : textColor\n                    },\n                    position: pos,\n                    rotation: labelLayout.rotation,\n                    silent: silent,\n                    z2: 10\n                });\n\n                // Pack data for mouse event\n                if (triggerEvent) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisLabel';\n                    textEl.eventData.value = labelStr;\n                }\n\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n\n                textEls.push(textEl);\n                this.group.add(textEl);\n\n                textEl.decomposeTransform();\n\n            }, this);\n\n            fixMinMaxLabelShow(axisModel, textEls);\n        },\n\n        /**\n         * @private\n         */\n        axisName: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var name = retrieve(opt.axisName, axisModel.get('name'));\n\n            if (!name) {\n                return;\n            }\n\n            var nameLocation = axisModel.get('nameLocation');\n            var nameDirection = opt.nameDirection;\n            var textStyleModel = axisModel.getModel('nameTextStyle');\n            var gap = axisModel.get('nameGap') || 0;\n\n            var extent = this.axisModel.axis.getExtent();\n            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n            var pos = [\n                nameLocation === 'start'\n                    ? extent[0] - gapSignal * gap\n                    : nameLocation === 'end'\n                    ? extent[1] + gapSignal * gap\n                    : (extent[0] + extent[1]) / 2, // 'middle'\n                // Reuse labelOffset.\n                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n            ];\n\n            var labelLayout;\n\n            var nameRotation = axisModel.get('nameRotate');\n            if (nameRotation != null) {\n                nameRotation = nameRotation * PI / 180; // To radian.\n            }\n\n            var axisNameAvailableWidth;\n\n            if (nameLocation === 'middle') {\n                labelLayout = innerTextLayout(\n                    opt.rotation,\n                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                    nameDirection\n                );\n            }\n            else {\n                labelLayout = endTextLayout(\n                    opt, nameLocation, nameRotation || 0, extent\n                );\n\n                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                if (axisNameAvailableWidth != null) {\n                    axisNameAvailableWidth = Math.abs(\n                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                    );\n                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                }\n            }\n\n            var textFont = textStyleModel.getFont();\n\n            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n            var ellipsis = truncateOpt.ellipsis;\n            var maxWidth = retrieve(\n                opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth\n            );\n            var truncatedText = (ellipsis != null && maxWidth != null)\n                ? formatUtil.truncateText(\n                    name, maxWidth, textFont, ellipsis,\n                    {minChar: 2, placeholder: truncateOpt.placeholder}\n                )\n                : name;\n\n            var tooltipOpt = axisModel.get('tooltip', true);\n\n            var mainType = axisModel.mainType;\n            var formatterParams = {\n                componentType: mainType,\n                name: name,\n                $vars: ['name']\n            };\n            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n            var textEl = new graphic.Text({\n\n                // Id for animation\n                anid: 'name',\n\n                __fullText: name,\n                __truncatedText: truncatedText,\n\n                style: {\n                    text: truncatedText,\n                    textFont: textFont,\n                    fill: textStyleModel.getTextColor()\n                        || axisModel.get('axisLine.lineStyle.color'),\n                    textAlign: labelLayout.textAlign,\n                    textVerticalAlign: labelLayout.textVerticalAlign\n                },\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: isSilent(axisModel),\n                z2: 1,\n                tooltip: (tooltipOpt && tooltipOpt.show)\n                    ? zrUtil.extend({\n                        content: name,\n                        formatter: function () {\n                            return name;\n                        },\n                        formatterParams: formatterParams\n                    }, tooltipOpt)\n                    : null\n            });\n\n            if (axisModel.get('triggerEvent')) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisName';\n                textEl.eventData.name = name;\n            }\n\n            // FIXME\n            this._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            this.group.add(textEl);\n\n            textEl.decomposeTransform();\n        }\n\n    };\n\n    /**\n     * @public\n     * @static\n     * @param {Object} opt\n     * @param {number} axisRotation in radian\n     * @param {number} textRotation in radian\n     * @param {number} direction\n     * @return {Object} {\n     *  rotation, // according to axis\n     *  textAlign,\n     *  textVerticalAlign\n     * }\n     */\n    var innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - axisRotation);\n        var textAlign;\n        var textVerticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            }\n            else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    };\n\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var textVerticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = (textPosition === 'start' && !inverse)\n            || (textPosition !== 'start' && inverse);\n\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            textVerticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            textVerticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            }\n            else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    }\n\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent')\n            // Consider mouse cursor, add these restrictions.\n            || !(\n                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n            );\n    }\n\n    function fixMinMaxLabelShow(axisModel, textEls) {\n        // If min or max are user set, we need to check\n        // If the tick on min(max) are overlap on their neighbour tick\n        // If they are overlapped, we need to hide the min(max) tick label\n        var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n        var firstLabel = textEls[0];\n        var nextLabel = textEls[1];\n        var lastLabel = textEls[textEls.length - 1];\n        var prevLabel = textEls[textEls.length - 2];\n\n        if (showMinLabel === false) {\n            firstLabel.ignore = true;\n        }\n        else if (axisModel.getMin() != null && isTwoLabelOverlapped(firstLabel, nextLabel)) {\n            showMinLabel ? (nextLabel.ignore = true) : (firstLabel.ignore = true);\n        }\n\n        if (showMaxLabel === false) {\n            lastLabel.ignore = true;\n        }\n        else if (axisModel.getMax() != null && isTwoLabelOverlapped(prevLabel, lastLabel)) {\n            showMaxLabel ? (prevLabel.ignore = true) : (lastLabel.ignore = true);\n        }\n    }\n\n    function isTwoLabelOverlapped(current, next, labelLayout) {\n        // current and next has the same rotation.\n        var firstRect = current && current.getBoundingRect().clone();\n        var nextRect = next && next.getBoundingRect().clone();\n\n        if (!firstRect || !nextRect) {\n            return;\n        }\n\n        // When checking intersect of two rotated labels, we use mRotationBack\n        // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n        var mRotationBack = matrix.identity([]);\n        matrix.rotate(mRotationBack, mRotationBack, -current.rotation);\n\n        firstRect.applyTransform(matrix.mul([], mRotationBack, current.getLocalTransform()));\n        nextRect.applyTransform(matrix.mul([], mRotationBack, next.getLocalTransform()));\n\n        return firstRect.intersect(nextRect);\n    }\n\n\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n        var rawTick;\n        var scale = axis.scale;\n        return scale.type === 'ordinal'\n            && (\n                typeof interval === 'function'\n                    ? (\n                        rawTick = scale.getTicks()[i],\n                        !interval(rawTick, scale.getLabel(rawTick))\n                    )\n                    : i % (interval + 1)\n            );\n    };\n\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n        var interval = model.get('interval');\n        if (interval == null || interval == 'auto') {\n            interval = labelInterval;\n        }\n        return interval;\n    };\n\n    module.exports = AxisBuilder;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/AxisBuilder.js\n// module id = 229\n// module chunks = 0 1 2 3 4 5 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('./axisHelper');\n\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        }\n        else {\n            return obj + '';\n        }\n    }\n\n    module.exports = {\n\n        /**\n         * Format labels\n         * @return {Array.<string>}\n         */\n        getFormattedLabels: function () {\n            return axisHelper.getFormattedLabels(\n                this.axis,\n                this.get('axisLabel.formatter')\n            );\n        },\n\n        /**\n         * Get categories\n         */\n        getCategories: function () {\n            return this.get('type') === 'category'\n                && zrUtil.map(this.get('data'), getName);\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n         */\n        getMin: function (origin) {\n            var option = this.option;\n            var min = (!origin && option.rangeStart != null)\n                ? option.rangeStart : option.min;\n\n            if (this.axis && min != null && min !== 'dataMin' && !zrUtil.eqNaN(min)) {\n                min = this.axis.scale.parse(min);\n            }\n            return min;\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n         */\n        getMax: function (origin) {\n            var option = this.option;\n            var max = (!origin && option.rangeEnd != null)\n                ? option.rangeEnd : option.max;\n\n            if (this.axis && max != null && max !== 'dataMax' && !zrUtil.eqNaN(max)) {\n                max = this.axis.scale.parse(max);\n            }\n            return max;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        getNeedCrossZero: function () {\n            var option = this.option;\n            return (option.rangeStart != null || option.rangeEnd != null)\n                ? false : !option.scale;\n        },\n\n        /**\n         * Should be implemented by each axis model if necessary.\n         * @return {module:echarts/model/Component} coordinate system model\n         */\n        getCoordSysModel: zrUtil.noop,\n\n        /**\n         * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n         * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n         */\n        setRange: function (rangeStart, rangeEnd) {\n            this.option.rangeStart = rangeStart;\n            this.option.rangeEnd = rangeEnd;\n        },\n\n        /**\n         * Reset range\n         */\n        resetRange: function () {\n            // rangeStart and rangeEnd is readonly.\n            this.option.rangeStart = this.option.rangeEnd = null;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisModelCommonMixin.js\n// module id = 230\n// module chunks = 0 1 2 3 4 5 6","\n\n    var lib = {};\n\n    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n    var RATE = '\\0__throttleRate';\n    var THROTTLE_TYPE = '\\0__throttleType';\n\n    /**\n     * @public\n     * @param {(Function)} fn\n     * @param {number} [delay=0] Unit: ms.\n     * @param {boolean} [debounce=false]\n     *        true: If call interval less than `delay`, only the last call works.\n     *        false: If call interval less than `delay, call works on fixed rate.\n     * @return {(Function)} throttled fn.\n     */\n    lib.throttle = function (fn, delay, debounce) {\n\n        var currCall;\n        var lastCall = 0;\n        var lastExec = 0;\n        var timer = null;\n        var diff;\n        var scope;\n        var args;\n        var debounceNextCall;\n\n        delay = delay || 0;\n\n        function exec() {\n            lastExec = (new Date()).getTime();\n            timer = null;\n            fn.apply(scope, args || []);\n        }\n\n        var cb = function () {\n            currCall = (new Date()).getTime();\n            scope = this;\n            args = arguments;\n            var thisDelay = debounceNextCall || delay;\n            var thisDebounce = debounceNextCall || debounce;\n            debounceNextCall = null;\n            diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;\n\n            clearTimeout(timer);\n\n            if (thisDebounce) {\n                timer = setTimeout(exec, thisDelay);\n            }\n            else {\n                if (diff >= 0) {\n                    exec();\n                }\n                else {\n                    timer = setTimeout(exec, -diff);\n                }\n            }\n\n            lastCall = currCall;\n        };\n\n        /**\n         * Clear throttle.\n         * @public\n         */\n        cb.clear = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n\n        /**\n         * Enable debounce once.\n         */\n        cb.debounceNextCall = function (debounceDelay) {\n            debounceNextCall = debounceDelay;\n        };\n\n        return cb;\n    };\n\n    /**\n     * Create throttle method or update throttle rate.\n     *\n     * @example\n     * ComponentView.prototype.render = function () {\n     *     ...\n     *     throttle.createOrUpdate(\n     *         this,\n     *         '_dispatchAction',\n     *         this.model.get('throttle'),\n     *         'fixRate'\n     *     );\n     * };\n     * ComponentView.prototype.remove = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     * ComponentView.prototype.dispose = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     * @param {number} [rate]\n     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n     * @return {Function} throttled function.\n     */\n    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n        var fn = obj[fnAttr];\n\n        if (!fn) {\n            return;\n        }\n\n        var originFn = fn[ORIGIN_METHOD] || fn;\n        var lastThrottleType = fn[THROTTLE_TYPE];\n        var lastRate = fn[RATE];\n\n        if (lastRate !== rate || lastThrottleType !== throttleType) {\n            if (rate == null || !throttleType) {\n                return (obj[fnAttr] = originFn);\n            }\n\n            fn = obj[fnAttr] = lib.throttle(\n                originFn, rate, throttleType === 'debounce'\n            );\n            fn[ORIGIN_METHOD] = originFn;\n            fn[THROTTLE_TYPE] = throttleType;\n            fn[RATE] = rate;\n        }\n\n        return fn;\n    };\n\n    /**\n     * Clear throttle. Example see throttle.createOrUpdate.\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     */\n    lib.clear = function (obj, fnAttr) {\n        var fn = obj[fnAttr];\n        if (fn && fn[ORIGIN_METHOD]) {\n            obj[fnAttr] = fn[ORIGIN_METHOD];\n        }\n    };\n\n    module.exports = lib;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/throttle.js\n// module id = 231\n// module chunks = 0 1 2 3 4 5 6","\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var modelUtil = require('../util/model');\n    var zrUtil = require('zrender/lib/core/util');\n\n    function Chart() {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n\n    Chart.prototype = {\n\n        type: 'chart',\n\n        /**\n         * Init the chart\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        init: function (ecModel, api) {},\n\n        /**\n         * Render the chart\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        render: function (seriesModel, ecModel, api, payload) {},\n\n        /**\n         * Highlight series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n\n        /**\n         * Downplay series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n\n        /**\n         * Remove self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n\n        /**\n         * Dispose self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        dispose: function () {}\n\n        /**\n         * The view contains the given point.\n         * @interface\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        // containPoint: function () {}\n\n    };\n\n    var chartProto = Chart.prototype;\n    chartProto.updateView\n        = chartProto.updateLayout\n        = chartProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            this.render(seriesModel, ecModel, api, payload);\n        };\n\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n        if (dataIndex != null) {\n            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n                elSetState(data.getItemGraphicEl(dataIdx), state);\n            });\n        }\n        else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\n    module.exports = Chart;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/view/Chart.js\n// module id = 232\n// module chunks = 0 1 2 3 4 5 6","\n        var config = require('../config');\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/log.js\n// module id = 234\n// module chunks = 0 1 2 3 4 5 6","/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // \n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // \n                if (!image.width || !image.height) {\n                    return;\n                }\n                var width = style.width;\n                var height = style.height;\n                var aspect = image.width / image.height;\n                if (width == null && height != null) {\n                    // Keep image/height ratio\n                    width = height * aspect;\n                }\n                else if (height == null && width != null) {\n                    height = width / aspect;\n                }\n                else if (width == null && height == null) {\n                    width = image.width;\n                    height = image.height;\n                }\n\n                // transform\n                this.setTransform(ctx);\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Image.js\n// module id = 235\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * \n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * \n     * , position, rotation, scaletransformtransform\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // \n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // \n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        return Transformable.getLocalTransform(this, m);\n    };\n\n    /**\n     * transformcontext\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    };\n\n    var tmpTransform = [];\n\n    /**\n     * `transform``position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     *  shape \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    /**\n     * @static\n     * @param {Object} target\n     * @param {Array.<number>} target.origin\n     * @param {number} target.rotation\n     * @param {Array.<number>} target.position\n     * @param {Array.<number>} [m]\n     */\n    Transformable.getLocalTransform = function (target, m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = target.origin;\n        var scale = target.scale || [1, 1];\n        var rotation = target.rotation || 0;\n        var position = target.position || [0, 0];\n\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n\n    module.exports = Transformable;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Transformable.js\n// module id = 236\n// module chunks = 0 1 2 3 4 5 6","\n\n    var classUtil = require('../../util/clazz');\n    var set = classUtil.set;\n    var get = classUtil.get;\n\n    module.exports = {\n        clearColorPalette: function () {\n            set(this, 'colorIdx', 0);\n            set(this, 'colorNameMap', {});\n        },\n\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = get(scope, 'colorIdx') || 0;\n            var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {});\n            // Use `hasOwnProperty` to avoid conflict with Object.prototype.\n            if (colorNameMap.hasOwnProperty(name)) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n\n            return color;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/colorPalette.js\n// module id = 237\n// module chunks = 0 1 2 3 4 5 6","/**\n * For testable.\n */\n\n\n    var numberUtil = require('../util/number');\n\n    var roundNumber = numberUtil.round;\n\n    var helper = {};\n\n    /**\n     * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n     *                                Should be extent[0] < extent[1].\n     * @param {number} splitNumber splitNumber should be >= 1.\n     * @param {number} [minInterval]\n     * @return {Object} {interval, intervalPrecision, niceTickExtent}\n     */\n    helper.intervalScaleNiceTicks = function (extent, splitNumber, minInterval) {\n        var result = {};\n        var span = extent[1] - extent[0];\n\n        var interval = result.interval = numberUtil.nice(span / splitNumber, true);\n        if (minInterval != null && interval < minInterval) {\n            interval = result.interval = minInterval;\n        }\n        // Tow more digital for tick.\n        var precision = result.intervalPrecision = helper.getIntervalPrecision(interval);\n        // Niced extent inside original extent\n        var niceTickExtent = result.niceTickExtent = [\n            roundNumber(Math.ceil(extent[0] / interval) * interval, precision),\n            roundNumber(Math.floor(extent[1] / interval) * interval, precision)\n        ];\n\n        helper.fixExtent(niceTickExtent, extent);\n\n        return result;\n    };\n\n    /**\n     * @param {number} interval\n     * @return {number} interval precision\n     */\n    helper.getIntervalPrecision = function (interval) {\n        // Tow more digital for tick.\n        return numberUtil.getPrecisionSafe(interval) + 2;\n    };\n\n    function clamp(niceTickExtent, idx, extent) {\n        niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n    }\n\n    // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\n    helper.fixExtent = function (niceTickExtent, extent) {\n        !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n        !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n        clamp(niceTickExtent, 0, extent);\n        clamp(niceTickExtent, 1, extent);\n        if (niceTickExtent[0] > niceTickExtent[1]) {\n            niceTickExtent[0] = niceTickExtent[1];\n        }\n    };\n\n    helper.intervalScaleGetTicks = function (interval, extent, niceTickExtent, intervalPrecision) {\n        var ticks = [];\n\n        // If interval is 0, return [];\n        if (!interval) {\n            return ticks;\n        }\n\n        // Consider this case: using dataZoom toolbox, zoom and zoom.\n        var safeLimit = 10000;\n\n        if (extent[0] < niceTickExtent[0]) {\n            ticks.push(extent[0]);\n        }\n        var tick = niceTickExtent[0];\n\n        while (tick <= niceTickExtent[1]) {\n            ticks.push(tick);\n            // Avoid rounding error\n            tick = roundNumber(tick + interval, intervalPrecision);\n            if (tick === ticks[ticks.length - 1]) {\n                // Consider out of safe float point, e.g.,\n                // -3711126.9907707 + 2e-10 === -3711126.9907707\n                break;\n            }\n            if (ticks.length > safeLimit) {\n                return [];\n            }\n        }\n        // Consider this case: the last item of ticks is smaller\n        // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n        if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {\n            ticks.push(extent[1]);\n        }\n\n        return ticks;\n    };\n\n    module.exports = helper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/helper.js\n// module id = 238\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * \n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * \n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender  element  zrender \n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * true\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * (shape) Group \n         * \n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Element.js\n// module id = 239\n// module chunks = 0 1 2 3 4 5 6","/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = len && p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function getArrayDim(keyframes) {\n        var lastValue = keyframes[keyframes.length - 1].value;\n        return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * \n         * @param  {number} time ms\n         * @param  {Object} props key-value\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        pause: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].pause();\n            }\n            this._paused = true;\n        },\n\n        resume: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].resume();\n            }\n            this._paused = false;\n        },\n\n        isPaused: function () {\n            return !!this._paused;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * \n         * @param  {string|Function} easing\n         *         {@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * \n         * @param  {number} time ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animator.js\n// module id = 240\n// module chunks = 0 1 2 3 4 5 6","\n\n    module.exports = (typeof window !== 'undefined' &&\n                ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window))\n                // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\n                || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))\n                || window.mozRequestAnimationFrame\n                || window.webkitRequestAnimationFrame)\n            )\n            || function (func) {\n                setTimeout(func, 16);\n            };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/requestAnimationFrame.js\n// module id = 241\n// module chunks = 0 1 2 3 4 5 6","\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/util.js\n// module id = 242\n// module chunks = 0 1 2 3 4 5 6","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function () {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function (val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function (entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            entry.next = null;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function (entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function () {\n        return this._len;\n    };\n\n    /**\n     * Clear list\n     */\n    linkedListProto.clear = function () {\n        this.head = this.tail = null;\n        this._len = 0;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function (val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function (maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n\n        this._lastRemovedEntry = null;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     * @return {} Removed value\n     */\n    LRUProto.put = function (key, value) {\n        var list = this._list;\n        var map = this._map;\n        var removed = null;\n        if (map[key] == null) {\n            var len = list.len();\n            // Reuse last removed entry\n            var entry = this._lastRemovedEntry;\n\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n\n                removed = leastUsedEntry.value;\n                this._lastRemovedEntry = leastUsedEntry;\n            }\n\n            if (entry) {\n                entry.value = value;\n            }\n            else {\n                entry = new Entry(value);\n            }\n            entry.key = key;\n            list.insertEntry(entry);\n            map[key] = entry;\n        }\n\n        return removed;\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function (key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function () {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/LRU.js\n// module id = 243\n// module chunks = 0 1 2 3 4 5 6","/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/guid.js\n// module id = 244\n// module chunks = 0 1 2 3 4 5 6","\n\n    var Pattern = function (image, repeat) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {image: ...}`, where this constructor will not be called.\n\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n        return ctx.createPattern(this.image, this.repeat || 'repeat');\n    };\n\n    module.exports = Pattern;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Pattern.js\n// module id = 245\n// module chunks = 0 1 2 3 4 5 6","/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        var x = obj.x == null ? 0 : obj.x;\n        var x2 = obj.x2 == null ? 1 : obj.x2;\n        var y = obj.y == null ? 0 : obj.y;\n        var y2 = obj.y2 == null ? 0 : obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x == null ? 0.5 : obj.x;\n        var y = obj.y == null ? 0.5 : obj.y;\n        var r = obj.r == null ? 0.5 : obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * If not specified, use the boundingRect of a `displayable`.\n         * @type {Object}\n         */\n        textPositionRect: null,\n\n        /**\n         * [x, y]\n         * @type {Array.<number>}\n         */\n        textOffset: null,\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Style.js\n// module id = 246\n// module chunks = 0 1 2 3 4 5 6","\n\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/poly.js\n// module id = 247\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    function defaultKeyGetter(item) {\n        return item;\n    }\n\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n\n    DataDiffer.prototype = {\n\n        constructor: DataDiffer,\n\n        /**\n         * Callback function when add a data\n         */\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n\n        /**\n         * Callback function when update a data\n         */\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n\n        /**\n         * Callback function when remove a data\n         */\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    }\n                    else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                }\n                else {\n                    this._remove && this._remove(i);\n                }\n            }\n\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    }\n                    else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            // Add prefix to avoid conflict with Object.prototype.\n            var key = '_ec_' + keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            }\n            else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n\n    module.exports = DataDiffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/DataDiffer.js\n// module id = 252\n// module chunks = 0 1 2 3 4 5 6","\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n\n    Component.prototype = {\n\n        constructor: Component,\n\n        init: function (ecModel, api) {},\n\n        render: function (componentModel, ecModel, api, payload) {},\n\n        dispose: function () {}\n\n    };\n\n    var componentProto = Component.prototype;\n    componentProto.updateView\n        = componentProto.updateLayout\n        = componentProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            // Do nothing;\n        };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\n    module.exports = Component;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/view/Component.js\n// module id = 256\n// module chunks = 0 1 2 3 4 5 6","/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * `min``max`\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points \n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * (p0, p1, p2, p3)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * (p0, p1, p2)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * `min``max`\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/bbox.js\n// module id = 257\n// module chunks = 0 1 2 3 4 5 6","\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/line.js\n// module id = 259\n// module chunks = 0 1 2 3 4 5 6","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/quadratic.js\n// module id = 260\n// module chunks = 0 1 2 3 4 5 6","\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/windingLine.js\n// module id = 261\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'linear', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/LinearGradient.js\n// module id = 262\n// module chunks = 0 1 2 3 4 5 6","/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                // FIXME in text contain default is top\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    // Fill after stroke so the outline will not cover the main part.\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (!this._rect) {\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                if (style.hasStroke()) {\n                    var w = style.lineWidth;\n                    rect.x -= w / 2;\n                    rect.y -= w / 2;\n                    rect.width += w;\n                    rect.height += w;\n                }\n                this._rect = rect;\n            }\n\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Text.js\n// module id = 263\n// module chunks = 0 1 2 3 4 5 6","/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var textOffset = style.textOffset;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n            rect = style.textPositionRect || rect;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            if (textOffset) {\n                x += textOffset[0];\n                y += textOffset[1];\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                // Fill after stroke so the outline will not cover the main part.\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                textFill && ctx.fillText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/mixin/RectText.js\n// module id = 264\n// module chunks = 0 1 2 3 4 5 6","/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n    var zrUtil = require('./core/util');\n\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: require('./Painter')\n    };\n\n    var instances = {};    // ZRendermap\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.5.2';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        // TODO WebGL\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        //  storage.delFromStorage, \n        // FIXME ugly\n        var oldDelFromStorage = storage.delFromStorage;\n        var oldAddToStorage = storage.addToStorage;\n\n        storage.delFromStorage = function (el) {\n            oldDelFromStorage.call(storage, el);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToStorage = function (el) {\n            oldAddToStorage.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * \n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, dpr) {\n            return this.painter.pathToImage(e, dpr);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Find hovered element\n         * @param {number} x\n         * @param {number} y\n         * @return {Object} {target, topTarget}\n         */\n        findHover: function (x, y) {\n            return this.handler.findHover(x, y);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/zrender.js\n// module id = 265\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var echartsAPIList = [\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed',\n        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',\n        'getViewOfComponentModel', 'getViewOfSeriesModel'\n    ];\n    // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js\n\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n\n    module.exports = ExtensionAPI;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/ExtensionAPI.js\n// module id = 266\n// module chunks = 0 1 2 3 4 5 6","\n\n    var createListFromArray = require('./chart/helper/createListFromArray');\n    var symbolUtil = require('./util/symbol');\n    var axisHelper = require('./coord/axisHelper');\n    var axisModelCommonMixin = require('./coord/axisModelCommonMixin');\n    var Model = require('./model/Model');\n    var util = require('zrender/lib/core/util');\n\n    module.exports = {\n        /**\n         * Create a muti dimension List structure from seriesModel.\n         * @param  {module:echarts/model/Model} seriesModel\n         * @return {module:echarts/data/List} list\n         */\n        createList: function (seriesModel) {\n            var data = seriesModel.get('data');\n            return createListFromArray(data, seriesModel, seriesModel.ecModel);\n        },\n\n        /**\n         * @see {module:echarts/data/helper/completeDimensions}\n         */\n        completeDimensions: require('./data/helper/completeDimensions'),\n\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @see http://echarts.baidu.com/option.html#series-scatter.symbol\n         * @param {string} symbolDesc\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: symbolUtil.createSymbol,\n\n        /**\n         * Create scale\n         * @param {Array.<number>} dataExtent\n         * @param {Object|module:echarts/Model} option\n         */\n        createScale: function (dataExtent, option) {\n            var axisModel = option;\n            if (!(option instanceof Model)) {\n                axisModel = new Model(option);\n                util.mixin(axisModel, axisModelCommonMixin);\n            }\n\n            var scale = axisHelper.createScaleByModel(axisModel);\n            scale.setExtent(dataExtent[0], dataExtent[1]);\n\n            axisHelper.niceScaleExtent(scale, axisModel);\n            return scale;\n        },\n\n        /**\n         * Mixin common methods to axis model,\n         *\n         * Inlcude methods\n         * `getFormattedLabels() => Array.<string>`\n         * `getCategories() => Array.<string>`\n         * `getMin(origin: boolean) => number`\n         * `getMax(origin: boolean) => number`\n         * `getNeedCrossZero() => boolean`\n         * `setRange(start: number, end: number)`\n         * `resetRange()`\n         */\n        mixinAxisModelCommonMethods: function (Model) {\n            util.mixin(Model, axisModelCommonMixin);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/helper.js\n// module id = 268\n// module chunks = 0 1 2 3 4 5 6","\n\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    module.exports = function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n            style: {\n                fill: opts.maskColor\n            },\n            zlevel: opts.zlevel,\n            z: 10000\n        });\n        var arc = new graphic.Arc({\n            shape: {\n                startAngle: -PI / 2,\n                endAngle: -PI / 2 + 0.1,\n                r: 10\n            },\n            style: {\n                stroke: opts.color,\n                lineCap: 'round',\n                lineWidth: 5\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n        var labelRect = new graphic.Rect({\n            style: {\n                fill: 'none',\n                text: opts.text,\n                textPosition: 'right',\n                textDistance: 10,\n                textFill: opts.textColor\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n\n        arc.animateShape(true)\n            .when(1000, {\n                endAngle: PI * 3 / 2\n            })\n            .start('circularInOut');\n        arc.animateShape(true)\n            .when(1000, {\n                startAngle: PI * 3 / 2\n            })\n            .delay(300)\n            .start('circularInOut');\n\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/loading/default.js\n// module id = 269\n// module chunks = 0 1 2 3 4 5 6","/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n\n    /**\n     * Caution: If the mechanism should be changed some day, these cases\n     * should be considered:\n     *\n     * (1) In `merge option` mode, if using the same option to call `setOption`\n     * many times, the result should be the same (try our best to ensure that).\n     * (2) In `merge option` mode, if a component has no id/name specified, it\n     * will be merged by index, and the result sequence of the components is\n     * consistent to the original sequence.\n     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n     * `mergeOption` in module:echarts/model/OptionManager.\n     */\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var Model = require('./Model');\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n\n    var ComponentModel = require('./Component');\n\n    var globalDefault = require('./globalDefault');\n\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n\n        constructor: GlobalModel,\n\n        init: function (option, parentModel, theme, optionManager) {\n            theme = theme || {};\n\n            this.option = null; // Mark as not initialized.\n\n            /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n            this._theme = new Model(theme);\n\n            /**\n             * @type {module:echarts/model/OptionManager}\n             */\n            this._optionManager = optionManager;\n        },\n\n        setOption: function (option, optionPreprocessorFuncs) {\n            zrUtil.assert(\n                !(OPTION_INNER_KEY in option),\n                'please use chart.getOption()'\n            );\n\n            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n            this.resetOption(null);\n        },\n\n        /**\n         * @param {string} type null/undefined: reset all.\n         *                      'recreate': force recreate all.\n         *                      'timeline': only reset timeline option\n         *                      'media': only reset media query option\n         * @return {boolean} Whether option changed.\n         */\n        resetOption: function (type) {\n            var optionChanged = false;\n            var optionManager = this._optionManager;\n\n            if (!type || type === 'recreate') {\n                var baseOption = optionManager.mountOption(type === 'recreate');\n\n                if (!this.option || type === 'recreate') {\n                    initBase.call(this, baseOption);\n                }\n                else {\n                    this.restoreData();\n                    this.mergeOption(baseOption);\n                }\n                optionChanged = true;\n            }\n\n            if (type === 'timeline' || type === 'media') {\n                this.restoreData();\n            }\n\n            if (!type || type === 'recreate' || type === 'timeline') {\n                var timelineOption = optionManager.getTimelineOption(this);\n                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n            }\n\n            if (!type || type === 'recreate' || type === 'media') {\n                var mediaOptions = optionManager.getMediaOption(this, this._api);\n                if (mediaOptions.length) {\n                    each(mediaOptions, function (mediaOption) {\n                        this.mergeOption(mediaOption, optionChanged = true);\n                    }, this);\n                }\n            }\n\n            return optionChanged;\n        },\n\n        /**\n         * @protected\n         */\n        mergeOption: function (newOption) {\n            var option = this.option;\n            var componentsMap = this._componentsMap;\n            var newCptTypes = [];\n\n            //  component model  merge\n            each(newOption, function (componentOption, mainType) {\n                if (componentOption == null) {\n                    return;\n                }\n\n                if (!ComponentModel.hasClass(mainType)) {\n                    option[mainType] = option[mainType] == null\n                        ? zrUtil.clone(componentOption)\n                        : zrUtil.merge(option[mainType], componentOption, true);\n                }\n                else {\n                    newCptTypes.push(mainType);\n                }\n            });\n\n            // FIXME OPTION \n            ComponentModel.topologicalTravel(\n                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n            );\n\n            this._seriesIndices = this._seriesIndices || [];\n\n            function visitComponent(mainType, dependencies) {\n                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\n                var mapResult = modelUtil.mappingToExists(\n                    componentsMap.get(mainType), newCptOptionList\n                );\n\n                modelUtil.makeIdAndName(mapResult);\n\n                // Set mainType and complete subType.\n                each(mapResult, function (item, index) {\n                    var opt = item.option;\n                    if (isObject(opt)) {\n                        item.keyInfo.mainType = mainType;\n                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n                    }\n                });\n\n                var dependentModels = getComponentsByTypes(\n                    componentsMap, dependencies\n                );\n\n                option[mainType] = [];\n                componentsMap.set(mainType, []);\n\n                each(mapResult, function (resultItem, index) {\n                    var componentModel = resultItem.exist;\n                    var newCptOption = resultItem.option;\n\n                    zrUtil.assert(\n                        isObject(newCptOption) || componentModel,\n                        'Empty component definition'\n                    );\n\n                    // Consider where is no new option and should be merged using {},\n                    // see removeEdgeAndAdd in topologicalTravel and\n                    // ComponentModel.getAllClassMainTypes.\n                    if (!newCptOption) {\n                        componentModel.mergeOption({}, this);\n                        componentModel.optionUpdated({}, false);\n                    }\n                    else {\n                        var ComponentModelClass = ComponentModel.getClass(\n                            mainType, resultItem.keyInfo.subType, true\n                        );\n\n                        if (componentModel && componentModel instanceof ComponentModelClass) {\n                            componentModel.name = resultItem.keyInfo.name;\n                            componentModel.mergeOption(newCptOption, this);\n                            componentModel.optionUpdated(newCptOption, false);\n                        }\n                        else {\n                            // PENDING Global as parent ?\n                            var extraOpt = zrUtil.extend(\n                                {\n                                    dependentModels: dependentModels,\n                                    componentIndex: index\n                                },\n                                resultItem.keyInfo\n                            );\n                            componentModel = new ComponentModelClass(\n                                newCptOption, this, this, extraOpt\n                            );\n                            zrUtil.extend(componentModel, extraOpt);\n                            componentModel.init(newCptOption, this, this, extraOpt);\n                            // Call optionUpdated after init.\n                            // newCptOption has been used as componentModel.option\n                            // and may be merged with theme and default, so pass null\n                            // to avoid confusion.\n                            componentModel.optionUpdated(null, true);\n                        }\n                    }\n\n                    componentsMap.get(mainType)[index] = componentModel;\n                    option[mainType][index] = componentModel.option;\n                }, this);\n\n                // Backup series for filtering.\n                if (mainType === 'series') {\n                    this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n                }\n            }\n        },\n\n        /**\n         * Get option for output (cloned option and inner info removed)\n         * @public\n         * @return {Object}\n         */\n        getOption: function () {\n            var option = zrUtil.clone(this.option);\n\n            each(option, function (opts, mainType) {\n                if (ComponentModel.hasClass(mainType)) {\n                    var opts = modelUtil.normalizeToArray(opts);\n                    for (var i = opts.length - 1; i >= 0; i--) {\n                        // Remove options with inner id.\n                        if (modelUtil.isIdInner(opts[i])) {\n                            opts.splice(i, 1);\n                        }\n                    }\n                    option[mainType] = opts;\n                }\n            });\n\n            delete option[OPTION_INNER_KEY];\n\n            return option;\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        getTheme: function () {\n            return this._theme;\n        },\n\n        /**\n         * @param {string} mainType\n         * @param {number} [idx=0]\n         * @return {module:echarts/model/Component}\n         */\n        getComponent: function (mainType, idx) {\n            var list = this._componentsMap.get(mainType);\n            if (list) {\n                return list[idx || 0];\n            }\n        },\n\n        /**\n         * If none of index and id and name used, return all components with mainType.\n         * @param {Object} condition\n         * @param {string} condition.mainType\n         * @param {string} [condition.subType] If ignore, only query by mainType\n         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        queryComponents: function (condition) {\n            var mainType = condition.mainType;\n            if (!mainType) {\n                return [];\n            }\n\n            var index = condition.index;\n            var id = condition.id;\n            var name = condition.name;\n\n            var cpts = this._componentsMap.get(mainType);\n\n            if (!cpts || !cpts.length) {\n                return [];\n            }\n\n            var result;\n\n            if (index != null) {\n                if (!isArray(index)) {\n                    index = [index];\n                }\n                result = filter(map(index, function (idx) {\n                    return cpts[idx];\n                }), function (val) {\n                    return !!val;\n                });\n            }\n            else if (id != null) {\n                var isIdArray = isArray(id);\n                result = filter(cpts, function (cpt) {\n                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n                        || (!isIdArray && cpt.id === id);\n                });\n            }\n            else if (name != null) {\n                var isNameArray = isArray(name);\n                result = filter(cpts, function (cpt) {\n                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n                        || (!isNameArray && cpt.name === name);\n                });\n            }\n            else {\n                // Return all components with mainType\n                result = cpts.slice();\n            }\n\n            return filterBySubType(result, condition);\n        },\n\n        /**\n         * The interface is different from queryComponents,\n         * which is convenient for inner usage.\n         *\n         * @usage\n         * var result = findComponents(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series'},\n         *     function (model, index) {...}\n         * );\n         * // result like [component0, componnet1, ...]\n         *\n         * @param {Object} condition\n         * @param {string} condition.mainType Mandatory.\n         * @param {string} [condition.subType] Optional.\n         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n         *        where xxx is mainType.\n         *        If query attribute is null/undefined or has no index/id/name,\n         *        do not filtering by query conditions, which is convenient for\n         *        no-payload situations or when target of action is global.\n         * @param {Function} [condition.filter] parameter: component, return boolean.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        findComponents: function (condition) {\n            var query = condition.query;\n            var mainType = condition.mainType;\n\n            var queryCond = getQueryCond(query);\n            var result = queryCond\n                ? this.queryComponents(queryCond)\n                : this._componentsMap.get(mainType);\n\n            return doFilter(filterBySubType(result, condition));\n\n            function getQueryCond(q) {\n                var indexAttr = mainType + 'Index';\n                var idAttr = mainType + 'Id';\n                var nameAttr = mainType + 'Name';\n                return q && (\n                        q[indexAttr] != null\n                        || q[idAttr] != null\n                        || q[nameAttr] != null\n                    )\n                    ? {\n                        mainType: mainType,\n                        // subType will be filtered finally.\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    }\n                    : null;\n            }\n\n            function doFilter(res) {\n                return condition.filter\n                     ? filter(res, condition.filter)\n                     : res;\n            }\n        },\n\n        /**\n         * @usage\n         * eachComponent('legend', function (legendModel, index) {\n         *     ...\n         * });\n         * eachComponent(function (componentType, model, index) {\n         *     // componentType does not include subType\n         *     // (componentType is 'xxx' but not 'xxx.aa')\n         * });\n         * eachComponent(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n         *     function (model, index) {...}\n         * );\n         * eachComponent(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n         *     function (model, index) {...}\n         * );\n         *\n         * @param {string|Object=} mainType When mainType is object, the definition\n         *                                  is the same as the method 'findComponents'.\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachComponent: function (mainType, cb, context) {\n            var componentsMap = this._componentsMap;\n\n            if (typeof mainType === 'function') {\n                context = cb;\n                cb = mainType;\n                componentsMap.each(function (components, componentType) {\n                    each(components, function (component, index) {\n                        cb.call(context, componentType, component, index);\n                    });\n                });\n            }\n            else if (zrUtil.isString(mainType)) {\n                each(componentsMap.get(mainType), cb, context);\n            }\n            else if (isObject(mainType)) {\n                var queryResult = this.findComponents(mainType);\n                each(queryResult, cb, context);\n            }\n        },\n\n        /**\n         * @param {string} name\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByName: function (name) {\n            var series = this._componentsMap.get('series');\n            return filter(series, function (oneSeries) {\n                return oneSeries.name === name;\n            });\n        },\n\n        /**\n         * @param {number} seriesIndex\n         * @return {module:echarts/model/Series}\n         */\n        getSeriesByIndex: function (seriesIndex) {\n            return this._componentsMap.get('series')[seriesIndex];\n        },\n\n        /**\n         * @param {string} subType\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByType: function (subType) {\n            var series = this._componentsMap.get('series');\n            return filter(series, function (oneSeries) {\n                return oneSeries.subType === subType;\n            });\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeries: function () {\n            return this._componentsMap.get('series').slice();\n        },\n\n        /**\n         * After filtering, series may be different\n         * frome raw series.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.get('series')[rawSeriesIndex];\n                cb.call(context, series, rawSeriesIndex);\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeries: function (cb, context) {\n            each(this._componentsMap.get('series'), cb, context);\n        },\n\n        /**\n         * After filtering, series may be different.\n         * frome raw series.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeriesByType: function (subType, cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.get('series')[rawSeriesIndex];\n                if (series.subType === subType) {\n                    cb.call(context, series, rawSeriesIndex);\n                }\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered of given type.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeriesByType: function (subType, cb, context) {\n            return each(this.getSeriesByType(subType), cb, context);\n        },\n\n        /**\n         * @param {module:echarts/model/Series} seriesModel\n         */\n        isSeriesFiltered: function (seriesModel) {\n            assertSeriesInitialized(this);\n            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getCurrentSeriesIndices: function () {\n            return (this._seriesIndices || []).slice();\n        },\n\n        /**\n         * @param {Function} cb\n         * @param {*} context\n         */\n        filterSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            var filteredSeries = filter(\n                this._componentsMap.get('series'), cb, context\n            );\n            this._seriesIndices = createSeriesIndices(filteredSeries);\n        },\n\n        restoreData: function () {\n            var componentsMap = this._componentsMap;\n\n            this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n\n            var componentTypes = [];\n            componentsMap.each(function (components, componentType) {\n                componentTypes.push(componentType);\n            });\n\n            ComponentModel.topologicalTravel(\n                componentTypes,\n                ComponentModel.getAllClassMainTypes(),\n                function (componentType, dependencies) {\n                    each(componentsMap.get(componentType), function (component) {\n                        component.restoreData();\n                    });\n                }\n            );\n        }\n\n    });\n\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        zrUtil.each(theme, function (themeItem, name) {\n            //  component model  merge  model \n            if (!ComponentModel.hasClass(name)) {\n                if (typeof themeItem === 'object') {\n                    option[name] = !option[name]\n                        ? zrUtil.clone(themeItem)\n                        : zrUtil.merge(option[name], themeItem, false);\n                }\n                else {\n                    if (option[name] == null) {\n                        option[name] = themeItem;\n                    }\n                }\n            }\n        });\n    }\n\n    function initBase(baseOption) {\n        baseOption = baseOption;\n\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n\n        /**\n         * Init with series: [], in case of calling findSeries method\n         * before series initialized.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = zrUtil.createHashMap({series: []});\n\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n\n        mergeTheme(baseOption, this._theme.option);\n\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n\n        this.mergeOption(baseOption);\n    }\n\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap.get(type) || []).slice();\n        });\n\n        return ret;\n    }\n\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type\n            ? newCptOption.type\n            : existComponent\n            ? existComponent.subType\n            // Use determineSubType only when there is no existComponent.\n            : ComponentModel.determineSubType(mainType, newCptOption);\n\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType')\n            ? filter(components, function (cpt) {\n                return cpt.subType === condition.subType;\n            })\n            : components;\n    }\n\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (__DEV__) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Option should contains series.');\n            }\n        }\n    }\n\n    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n\n    module.exports = GlobalModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Global.js\n// module id = 270\n// module chunks = 0 1 2 3 4 5 6","/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n    OptionManager.prototype = {\n\n        constructor: OptionManager,\n\n        /**\n         * @public\n         * @param {Object} rawOption Raw option.\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Array.<Function>} optionPreprocessorFuncs\n         * @return {Object} Init option\n         */\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n\n            // FIXME\n            //  timeline options  media baseOption\n\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(\n                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n            );\n            this._newBaseOption = newParsedOption.baseOption;\n\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            }\n            else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n\n        /**\n         * @param {boolean} isRecreate\n         * @return {Object}\n         */\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n\n            // TODO\n            // resetclone\n\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n\n            return clone(isRecreate\n                // this._optionBackup.baseOption, which is created at the first `setOption`\n                // called, and is merged into every new option by inner method `mergeOption`\n                // each time `setOption` called, can be only used in `isRecreate`, because\n                // its reliability is under suspicion. In other cases option merge is\n                // performed by `model.mergeOption`.\n                ? optionBackup.baseOption : this._newBaseOption\n            );\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object}\n         */\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(\n                        timelineOptions[timelineModel.getCurrentIndex()],\n                        true\n                    );\n                }\n            }\n\n            return option;\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Array.<Object>}\n         */\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n\n            // FIXME\n            // mediaDefault\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(\n                        index === -1 ? mediaDefault.option : mediaList[index].option\n                    );\n                });\n            }\n            // Otherwise return nothing.\n\n            this._currentMediaIndices = indices;\n\n            return result;\n        }\n    };\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    }\n                    else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n\n        // Preprocess.\n        each([baseOption].concat(timelineOptions)\n            .concat(zrUtil.map(mediaList, function (media) {\n                return media.option;\n            })),\n            function (option) {\n                each(optionPreprocessorFuncs, function (preProcess) {\n                    preProcess(option, isNew);\n                });\n            }\n        );\n\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n            width: ecWidth,\n            height: ecHeight,\n            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n        };\n\n        var applicatable = true;\n\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n\n        return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        }\n        else if (operator === 'max') {\n            return real <= expect;\n        }\n        else { // Equals\n            return real === expect;\n        }\n    }\n\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n\n            var oldCptOpt = oldOption[mainType];\n\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            }\n            else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return (item.option && item.exist)\n                        ? merge(item.exist, item.option, true)\n                        : (item.exist || item.option);\n                });\n            }\n        });\n    }\n\n    module.exports = OptionManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/OptionManager.js\n// module id = 271\n// module chunks = 0 1 2 3 4 5 6","\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    module.exports = {\n        // \n        // backgroundColor: 'rgba(0,0,0,0)',\n\n        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n        // \n        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n        // \n        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n        //  Grid \n        // grid: {},\n        // \n        textStyle: {\n            // color: '#000',\n            // decoration: 'none',\n            // PENDING\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            // fontFamily: 'Arial, Verdana, sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n\n        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n        // Default is source-over\n        blendMode: null,\n\n        animation: 'auto',\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n\n        animationThreshold: 2000,\n        // Configuration for progressive/incremental rendering\n        progressiveThreshold: 3000,\n        progressive: 400,\n\n        // Threshold of if use single hover layer to optimize.\n        // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n        // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n        // which is unexpected.\n        // see example <echarts/test/heatmap-large.html>.\n        hoverLayerThreshold: 3000,\n\n        // See: module:echarts/scale/Time\n        useUTC: false\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/globalDefault.js\n// module id = 272\n// module chunks = 0 1 2 3 4 5 6","\n    module.exports = {\n        getAreaStyle: require('./makeStyleMapper')(\n            [\n                ['fill', 'color'],\n                ['shadowBlur'],\n                ['shadowOffsetX'],\n                ['shadowOffsetY'],\n                ['opacity'],\n                ['shadowColor']\n            ]\n        )\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/areaStyle.js\n// module id = 273\n// module chunks = 0 1 2 3 4 5 6","\n\n    module.exports = {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/boxLayout.js\n// module id = 274\n// module chunks = 0 1 2 3 4 5 6","\n    var getItemStyle = require('./makeStyleMapper')(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor'],\n            ['textPosition'],\n            ['textAlign']\n        ]\n    );\n    module.exports = {\n        getItemStyle: function (excludes, includes) {\n            var style = getItemStyle.call(this, excludes, includes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/itemStyle.js\n// module id = 275\n// module chunks = 0 1 2 3 4 5 6","\n    var getLineStyle = require('./makeStyleMapper')(\n        [\n            ['lineWidth', 'width'],\n            ['stroke', 'color'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash(style.lineWidth);\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getLineDash: function (lineWidth) {\n            if (lineWidth == null) {\n                lineWidth = 1;\n            }\n            var lineType = this.get('type');\n            var dotSize = Math.max(lineWidth, 2);\n            var dashSize = lineWidth * 4;\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/lineStyle.js\n// module id = 276\n// module chunks = 0 1 2 3 4 5 6","\n\n    var textContain = require('zrender/lib/contain/text');\n    var graphicUtil = require('../../util/graphic');\n\n    module.exports = {\n        /**\n         * Get color property or get color from option.textStyle.color\n         * @return {string}\n         */\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color')\n                || (ecModel && ecModel.get('textStyle.color'));\n        },\n\n        /**\n         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n         * @return {string}\n         */\n        getFont: function () {\n            return graphicUtil.getFont({\n                fontStyle: this.getShallow('fontStyle'),\n                fontWeight: this.getShallow('fontWeight'),\n                fontSize: this.getShallow('fontSize'),\n                fontFamily: this.getShallow('fontFamily')\n            }, this.ecModel);\n        },\n\n        getTextRect: function (text) {\n            return textContain.getBoundingRect(\n                text,\n                this.getFont(),\n                this.getShallow('align'),\n                this.getShallow('baseline')\n            );\n        },\n\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(\n                text, containerWidth, this.getFont(), ellipsis, options\n            );\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/textStyle.js\n// module id = 277\n// module chunks = 0 1 2 3 4 5 6","// Compatitable with 2.0\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var compatStyle = require('./helper/compatStyle');\n\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n\n    var LAYOUT_PROPERTIES = [\n        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n    ];\n\n    var COMPATITABLE_COMPONENTS = [\n        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n    ];\n\n    var COMPATITABLE_SERIES = [\n        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n    ];\n\n    var each = zrUtil.each;\n\n    module.exports = function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n\n            var seriesType = seriesOpt.type;\n\n            compatStyle(seriesOpt);\n\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null\n                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/preprocessor/backwardCompat.js\n// module id = 278\n// module chunks = 0 1 2 3 4 5 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var POSSIBLE_STYLES = [\n        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n        'chordStyle', 'label', 'labelLine'\n    ];\n\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n\n    module.exports = function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    }\n                    else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/preprocessor/helper/compatStyle.js\n// module id = 279\n// module chunks = 0 1 2 3 4 5 6","/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n    var numberUtil = require('../util/number');\n\n    // Use some method of IntervalScale\n    var IntervalScale = require('./Interval');\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n\n    var mathLog = Math.log;\n\n    var LogScale = Scale.extend({\n\n        type: 'log',\n\n        base: 10,\n\n        $constructor: function () {\n            Scale.apply(this, arguments);\n            this._originalScale = new IntervalScale();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            var originalScale = this._originalScale;\n            var extent = this._extent;\n            var originalExtent = originalScale.getExtent();\n\n            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                var powVal = numberUtil.round(mathPow(this.base, val));\n\n                // Fix #4158\n                powVal = (val === extent[0] && originalScale.__fixMin)\n                    ? fixRoundingError(powVal, originalExtent[0])\n                    : powVal;\n                powVal = (val === extent[1] && originalScale.__fixMax)\n                    ? fixRoundingError(powVal, originalExtent[1])\n                    : powVal;\n\n                return powVal;\n            }, this);\n        },\n\n        /**\n         * @param {number} val\n         * @return {string}\n         */\n        getLabel: intervalScaleProto.getLabel,\n\n        /**\n         * @param  {number} val\n         * @return {number}\n         */\n        scale: function (val) {\n            val = scaleProto.scale.call(this, val);\n            return mathPow(this.base, val);\n        },\n\n        /**\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var base = this.base;\n            start = mathLog(start) / mathLog(base);\n            end = mathLog(end) / mathLog(base);\n            intervalScaleProto.setExtent.call(this, start, end);\n        },\n\n        /**\n         * @return {number} end\n         */\n        getExtent: function () {\n            var base = this.base;\n            var extent = scaleProto.getExtent.call(this);\n            extent[0] = mathPow(base, extent[0]);\n            extent[1] = mathPow(base, extent[1]);\n\n            // Fix #4158\n            var originalScale = this._originalScale;\n            var originalExtent = originalScale.getExtent();\n            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n            return extent;\n        },\n\n        /**\n         * @param  {Array.<number>} extent\n         */\n        unionExtent: function (extent) {\n            this._originalScale.unionExtent(extent);\n\n            var base = this.base;\n            extent[0] = mathLog(extent[0]) / mathLog(base);\n            extent[1] = mathLog(extent[1]) / mathLog(base);\n            scaleProto.unionExtent.call(this, extent);\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, true, function (val) {\n                return val > 0;\n            }));\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         * @param  {number} [approxTickNum = 10] Given approx tick number\n         */\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (span === Infinity || span <= 0) {\n                return;\n            }\n\n            var interval = numberUtil.quantity(span);\n            var err = approxTickNum / span * interval;\n\n            // Filter ticks to get closer to the desired count.\n            if (err <= 0.5) {\n                interval *= 10;\n            }\n\n            // Interval should be integer\n            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                interval *= 10;\n            }\n\n            var niceExtent = [\n                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n            ];\n\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @override\n         */\n        niceExtent: function (opt) {\n            intervalScaleProto.niceExtent.call(this, opt);\n\n            var originalScale = this._originalScale;\n            originalScale.__fixMin = opt.fixMin;\n            originalScale.__fixMax = opt.fixMax;\n        }\n\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n\n    LogScale.create = function () {\n        return new LogScale();\n    };\n\n    function fixRoundingError(val, originalVal) {\n        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n    }\n\n    module.exports = LogScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Log.js\n// module id = 280\n// module chunks = 0 1 2 3 4 5 6","/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n\n    var scaleProto = Scale.prototype;\n\n    var OrdinalScale = Scale.extend({\n\n        type: 'ordinal',\n\n        init: function (data, extent) {\n            this._data = data;\n            this._extent = extent || [0, data.length - 1];\n        },\n\n        parse: function (val) {\n            return typeof val === 'string'\n                ? zrUtil.indexOf(this._data, val)\n                // val might be float.\n                : Math.round(val);\n        },\n\n        contain: function (rank) {\n            rank = this.parse(rank);\n            return scaleProto.contain.call(this, rank)\n                && this._data[rank] != null;\n        },\n\n        /**\n         * Normalize given rank or name to linear [0, 1]\n         * @param {number|string} [val]\n         * @return {number}\n         */\n        normalize: function (val) {\n            return scaleProto.normalize.call(this, this.parse(val));\n        },\n\n        scale: function (val) {\n            return Math.round(scaleProto.scale.call(this, val));\n        },\n\n        /**\n         * @return {Array}\n         */\n        getTicks: function () {\n            var ticks = [];\n            var extent = this._extent;\n            var rank = extent[0];\n\n            while (rank <= extent[1]) {\n                ticks.push(rank);\n                rank++;\n            }\n\n            return ticks;\n        },\n\n        /**\n         * Get item on rank n\n         * @param {number} n\n         * @return {string}\n         */\n        getLabel: function (n) {\n            return this._data[n];\n        },\n\n        /**\n         * @return {number}\n         */\n        count: function () {\n            return this._extent[1] - this._extent[0] + 1;\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, false));\n        },\n\n        niceTicks: zrUtil.noop,\n        niceExtent: zrUtil.noop\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n\n    module.exports = OrdinalScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Ordinal.js\n// module id = 281\n// module chunks = 0 1 2 3 4 5 6","/**\n * Interval scale\n * @module echarts/coord/scale/Time\n */\n\n\n\n    // [About UTC and local time zone]:\n    // In most cases, `number.parseDate` will treat input data string as local time\n    // (except time zone is specified in time string). And `format.formateTime` returns\n    // local time by default. option.useUTC is false by default. This design have\n    // concidered these common case:\n    // (1) Time that is persistent in server is in UTC, but it is needed to be diplayed\n    // in local time by default.\n    // (2) By default, the input data string (e.g., '2011-01-02') should be displayed\n    // as its original time, without any time difference.\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var scaleHelper = require('./helper');\n\n    var IntervalScale = require('./Interval');\n\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n\n    // FIXME \n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            }\n            else {\n                hi  = mid;\n            }\n        }\n        return lo;\n    };\n\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n        type: 'time',\n\n        /**\n         * @override\n         */\n        getLabel: function (val) {\n            var stepLvl = this._stepLvl;\n\n            var date = new Date(val);\n\n            return formatUtil.formatTime(stepLvl[0], date, this.getSetting('useUTC'));\n        },\n\n        /**\n         * @override\n         */\n        niceExtent: function (opt) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                // Expand extent\n                extent[0] -= ONE_DAY;\n                extent[1] += ONE_DAY;\n            }\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (extent[1] === -Infinity && extent[0] === Infinity) {\n                var d = new Date();\n                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                extent[0] = extent[1] - ONE_DAY;\n            }\n\n            this.niceTicks(opt.splitNumber);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!opt.fixMin) {\n                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!opt.fixMax) {\n                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n            }\n        },\n\n        /**\n         * @override\n         */\n        niceTicks: function (approxTickNum) {\n            var timezoneOffset = this.getSetting('useUTC')\n                ? 0 : numberUtil.getTimezoneOffset() * 60 * 1000;\n            approxTickNum = approxTickNum || 10;\n\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            var approxInterval = span / approxTickNum;\n            var scaleLevelsLen = scaleLevels.length;\n            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n            var interval = level[2];\n            // Same with interval scale if span is much larger than 1 year\n            if (level[0] === 'year') {\n                var yearSpan = span / interval;\n\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\n                interval *= yearStep;\n            }\n\n            var niceExtent = [\n                Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset),\n                Math.round(mathFloor((extent[1] - timezoneOffset)/ interval) * interval + timezoneOffset)\n            ];\n\n            scaleHelper.fixExtent(niceExtent, extent);\n\n            this._stepLvl = level;\n            // Interval will be used in getTicks\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        parse: function (val) {\n            // val might be float.\n            return +numberUtil.parseDate(val);\n        }\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n\n    // Steps from d3\n    var scaleLevels = [\n        // Format       step    interval\n        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n        ['week',        7,      ONE_DAY * 7],        // 7d\n        ['month',       1,      ONE_DAY * 31],       // 1M\n        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n        ['year',        1,      ONE_DAY * 380]       // 1Y\n    ];\n\n    /**\n     * @param {module:echarts/model/Model}\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function (model) {\n        return new TimeScale({useUTC: model.ecModel.get('useUTC')});\n    };\n\n    module.exports = TimeScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Time.js\n// module id = 282\n// module chunks = 0 1 2 3 4 5 6","\n    var Gradient = require('zrender/lib/graphic/Gradient');\n    module.exports = function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(\n                            idx, 'color', color(seriesModel.getDataParams(idx))\n                        );\n                    });\n                }\n\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/visual/seriesColor.js\n// module id = 283\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n\n    var Eventful = require('./mixin/Eventful');\n\n    var SILENT = 'silent';\n\n    function makeEventPacket(eveType, targetInfo, event) {\n        return {\n            type: eveType,\n            event: event,\n            // target can only be an element that is not silent.\n            target: targetInfo.target,\n            // topTarget can be a silent element.\n            topTarget: targetInfo.topTarget,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * {target, topTarget}\n         * @private\n         * @type {Object}\n         */\n        this._hovered = {};\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var lastHovered = this._hovered;\n            var hovered = this._hovered = this.findHover(x, y);\n            var hoveredTarget = hovered.target;\n            var lastHoveredTarget = lastHovered.target;\n\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget && lastHoveredTarget.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = {};\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * cursor style\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * \n         *\n         * @private\n         * @param {Object} targetInfo {target, topTarget} \n         * @param {string} eventName \n         * @param {Object} event \n         */\n        dispatchToElement: function (targetInfo, eventName, event) {\n            targetInfo = targetInfo || {};\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n            var el = targetInfo.target;\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                //  zrender \n                this.trigger(eventName, eventPacket);\n                // \n                //  click  dispose painter \n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @return {model:zrender/Element}\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            var out = {};\n\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                var hoverCheckResult;\n                if (list[i] !== exclude\n                    // getDisplayList may include ignored item in VML mode\n                    && !list[i].ignore\n                    && (hoverCheckResult = isHover(list[i], x, y))\n                ) {\n                    !out.topTarget && (out.topTarget = list[i]);\n                    if (hoverCheckResult !== SILENT) {\n                        out.target = list[i];\n                        break;\n                    }\n                }\n            }\n\n            return out;\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY);\n            var hoveredTarget = hovered.target;\n\n            if (name === 'mousedown') {\n                this._downel = hoveredTarget;\n                // In case click triggered before mouseup\n                this._upel = hoveredTarget;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hoveredTarget;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            var isSilent;\n            while (el) {\n                // If clipped by ancestor.\n                // FIXME: If clipPath has neither stroke nor fill,\n                // el.clipPath.contain(x, y) will always return false.\n                if (el.clipPath && !el.clipPath.contain(x, y))  {\n                    return false;\n                }\n                if (el.silent) {\n                    isSilent = true;\n                }\n                el = el.parent;\n            }\n            return isSilent ? SILENT : true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Handler.js\n// module id = 284\n// module chunks = 0 1 2 3 4 5 6","/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * dom\n     *\n     * @inner\n     * @param {string} id dom id \n     * @param {string} type dom typesuch as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // append~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // \n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * \n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * \n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * alpha\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Layer.js\n// module id = 285\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n\n    var Layer = require('./Layer');\n\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.__builtin__) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n\n            clipPath.setTransform(ctx);\n            ctx.beginPath();\n            clipPath.buildPath(ctx, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // \n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root \n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * \n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            if (opts.width != null) {\n                root.width = opts.width;\n            }\n            if (opts.height != null) {\n                root.height = opts.height;\n            }\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n\n            this._domRoot = root;\n        }\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._domRoot;\n        },\n\n        /**\n         * \n         * @param {boolean} [paintAll=false] displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.__builtin__ && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuiltinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuiltinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.__builtin__) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         *  zlevel \n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.__builtin__ = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            layersMap[zlevel] = layer;\n\n            // Vitual layer will not directly show on the screen.\n            // (It can be a WebGL layer and assigned to a ZImage element)\n            // But it still under management of zrender.\n            if (!layer.virtual) {\n                if (prevLayer) {\n                    var prevDom = prevLayer.dom;\n                    if (prevDom.nextSibling) {\n                        domRoot.insertBefore(\n                            layer.dom,\n                            prevDom.nextSibling\n                        );\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n                else {\n                    if (domRoot.firstChild) {\n                        domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n            }\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuiltinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (!layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuiltinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // \n            this.eachBuiltinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * hover\n         */\n        clear: function () {\n            this.eachBuiltinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * zlevel\n         *\n         * @param {string} zlevel\n         * @param {Object} config \n         * @param {string} [config.clearColor=0] \n         * @param {string} [config.motionBlur=false] \n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 alpha\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {number} zlevel zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * \n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * \n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            var zlevel;\n\n            var self = this;\n            function findAndDrawOtherLayer(smaller, larger) {\n                var zlevelList = self._zlevelList;\n                if (smaller == null) {\n                    smaller = -Infinity;\n                }\n                var intermediateLayer;\n                for (var i = 0; i < zlevelList.length; i++) {\n                    var z = zlevelList[i];\n                    var layer = self._layers[z];\n                    if (!layer.__builtin__ && z > smaller && z < larger) {\n                        intermediateLayer = layer;\n                        break;\n                    }\n                }\n                if (intermediateLayer && intermediateLayer.renderToCanvas) {\n                    imageLayer.ctx.save();\n                    intermediateLayer.renderToCanvas(imageLayer.ctx);\n                    imageLayer.ctx.restore();\n                }\n            }\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n\n                if (el.zlevel !== zlevel) {\n                    findAndDrawOtherLayer(zlevel, el.zlevel);\n                    zlevel = el.zlevel;\n                }\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            findAndDrawOtherLayer(zlevel, Infinity);\n\n            return imageLayer.dom;\n        },\n        /**\n         * \n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * \n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        pathToImage: function (path, dpr) {\n            dpr = dpr || this.dpr;\n\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            var rect = path.getBoundingRect();\n            var style = path.style;\n            var shadowBlurSize = style.shadowBlur;\n            var shadowOffsetX = style.shadowOffsetX;\n            var shadowOffsetY = style.shadowOffsetY;\n            var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\n            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n            var width = rect.width + leftMargin + rightMargin;\n            var height = rect.height + topMargin + bottomMargin;\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.scale(dpr, dpr);\n            ctx.clearRect(0, 0, width, height);\n            ctx.dpr = dpr;\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [leftMargin - rect.x, topMargin - rect.y];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            path.updateTransform();\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Painter.js\n// module id = 286\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = require('./core/util');\n    var env = require('./core/env');\n\n    var Group = require('./container/Group');\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     *  (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} [update=false] \n         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n         *\n         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * \n         * GroupShapeShape\n         * zlevel > z > \n         * @param {boolean} [includeIgnore=false]  ignore \n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var userSetClipPath = el.clipPath;\n            if (userSetClipPath) {\n\n                // FIXME \n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                // Recursively add clip path\n                while (currentClipPath) {\n                    // clipPath  clipPath \n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n\n                    clipPaths.push(currentClipPath);\n\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.clipPath;\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            if (el.__storage === this) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToStorage(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {string|Array.<string>} [el] Storage\n         */\n        delRoot: function (el) {\n            if (el == null) {\n                // el\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (el instanceof Array) {\n                for (var i = 0, l = el.length; i < l; i++) {\n                    this.delRoot(el[i]);\n                }\n                return;\n            }\n\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromStorage(el);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToStorage: function (el) {\n            el.__storage = this;\n            el.dirty(false);\n\n            return this;\n        },\n\n        delFromStorage: function (el) {\n            if (el) {\n                el.__storage = null;\n            }\n\n            return this;\n        },\n\n        /**\n         * Storage\n         */\n        dispose: function () {\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Storage.js\n// module id = 287\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n\n    var requestAnimationFrame = require('./requestAnimationFrame');\n\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         *  clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         *  animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * \n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * \n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time, delta);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * \n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * \n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * \n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * animator\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] \n         * @param  {Function} [options.getter=null]\n         *         gettergetter\n         * @param  {Function} [options.setter=null]\n         *         settersetter\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            this.addAnimator(animator);\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animation.js\n// module id = 288\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = require('./easing');\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // \n        this._life = options.life || 1000;\n        // \n        this._delay = options.delay || 0;\n        // \n        // this._startTime = new Date().getTime() + this._delay;// \n        this._initialized = false;\n\n        // \n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n\n        this._pausedTime = 0;\n        this._paused = false;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime, deltaTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            if (this._paused) {\n                this._pausedTime += deltaTime;\n                return;\n            }\n\n            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n\n            // \n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // \n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // \n                    //  stage.update \n                    return 'restart';\n                }\n\n                // \n                // Animation.update\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._pausedTime = 0;\n\n            this._needsRemove = false;\n        },\n\n        fire: function (eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        },\n\n        pause: function () {\n            this._paused = true;\n        },\n\n        resume: function () {\n            this._paused = false;\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Clip.js\n// module id = 289\n// module chunks = 0 1 2 3 4 5 6","/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // t^3\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // t^4\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // t^5\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // sin(t)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 2^t\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // sqrt(1-t^2)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/easing.js\n// module id = 290\n// module chunks = 0 1 2 3 4 5 6","\n\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/arc.js\n// module id = 291\n// module chunks = 0 1 2 3 4 5 6","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/cubic.js\n// module id = 292\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n\n    var windingLine = require('./windingLine');\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // \n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc \n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                //  subpath \n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE  L, C, Q  NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    //  arc \n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // \n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr scale, x\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        //  subpath \n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/path.js\n// module id = 293\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = require('./event');\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/GestureMgr.js\n// module id = 294\n// module chunks = 0 1 2 3 4 5 6","\n\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerEventNames = {\n        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n    };\n\n    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n        var nm = name.replace('mouse', 'pointer');\n        return pointerEventNames[nm] ? nm : name;\n    });\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null).target,\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        // Do not do any preventDefault here. Upper application do that if necessary.\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement({target: gestureInfo.target}, type, gestureInfo.event);\n        }\n    }\n\n    // function onMSGestureChange(proxy, event) {\n    //     if (event.translationX || event.translationY) {\n    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n    //     }\n    //     if (event.scale !== 1) {\n    //         event.pinchX = event.offsetX;\n    //         event.pinchY = event.offsetY;\n    //         event.pinchScale = event.scale;\n    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n    //     }\n    // }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // rootdommouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered, and must before `mousedown` triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        },\n\n        pointerdown: function (event) {\n            domHandlers.mousedown.call(this, event);\n\n            // if (useMSGuesture(this, event)) {\n            //     this._msGesture.addPointer(event.pointerId);\n            // }\n        },\n\n        pointermove: function (event) {\n            // FIXME\n            // pointermove is so sensitive that it always triggered when\n            // tap(click) on touch screen, which affect some judgement in\n            // upper application. So, we dont support mousemove on MS touch\n            // device yet.\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mousemove.call(this, event);\n            }\n        },\n\n        pointerup: function (event) {\n            domHandlers.mouseup.call(this, event);\n        },\n\n        pointerout: function (event) {\n            // pointerout will be triggered when tap on touch screen\n            // (IE11+/Edge on MS Surface) after click event triggered,\n            // which is inconsistent with the mousout behavior we defined\n            // in touchend. So we unify them.\n            // (check domHandlers.touchend for detailed explanation)\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n\n    // function useMSGuesture(handlerProxy, event) {\n    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n    // }\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * dom \n     *\n     * @inner\n     * @param {module:zrender/Handler} instance \n     */\n    function initDomHandler(instance) {\n        zrUtil.each(touchHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(pointerHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(mouseHandlerNames, function (name) {\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        });\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (env.pointerEventsSupported) { // Only IE11+/Edge\n            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n            // at the same time.\n            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n            // screen, which do not occurs in pointer event.\n            // So we use pointer event to both detect touch gesture and mouse behavior.\n            mountHandlers(pointerHandlerNames, this);\n\n            // FIXME\n            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n            // which does not prevent defuault behavior occasionally (which may cause view port\n            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n            // touch screen. And we only support click behavior on MS touch screen now.\n\n            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n            // We dont support touch on IE on win7.\n            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n            // if (typeof MSGesture === 'function') {\n            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n            // }\n        }\n        else {\n            if (env.touchEventsSupported) {\n                mountHandlers(touchHandlerNames, this);\n                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n            }\n\n            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n            // mouse event can not be handle in those devices.\n            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n            // mouseevent after touch event triggered, see `setTouchTimer`.\n            mountHandlers(mouseHandlerNames, this);\n        }\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/dom/HandlerProxy.js\n// module id = 295\n// module chunks = 0 1 2 3 4 5 6","// CompoundPath to improve performance\n\n\n    var Path = require('./Path');\n\n    module.exports = Path.extend({\n\n        type: 'compound',\n\n        shape: {\n\n            paths: null\n        },\n\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                if (!paths[i].path) {\n                    paths[i].createPathProxy();\n                }\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/CompoundPath.js\n// module id = 296\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'radial', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/RadialGradient.js\n// module id = 297\n// module chunks = 0 1 2 3 4 5 6","\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/roundRect.js\n// module id = 298\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * \n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points \n     * @param {number} smooth , 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint \n     *                            [[0, 0], [100, 100]], \n     *                           \n     * @param {Array} \n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // \n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothBezier.js\n// module id = 299\n// module chunks = 0 1 2 3 4 5 6","/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = require('../../core/vector');\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points \n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothSpline.js\n// module id = 300\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = require('../Path').extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Arc.js\n// module id = 301\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * \n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = require('../Path').extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/BezierCurve.js\n// module id = 302\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * \n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // else {\n            //     if (ctx.allocate && !ctx.data.length) {\n            //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n            //     }\n            // }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Circle.js\n// module id = 303\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = require('../Path').extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Line.js\n// module id = 304\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polygon.js\n// module id = 305\n// module chunks = 0 1 2 3 4 5 6","/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polyline.js\n// module id = 306\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = require('../helper/roundRect');\n\n    module.exports = require('../Path').extend({\n\n        type: 'rect',\n\n        shape: {\n            // r1r2r3r4\n            // r1          [1, 1, 1, 1]\n            // r[1]        [1, 1, 1, 1]\n            // r[1, 2]     [1, 2, 1, 2]\n            // r[1, 2, 3]  [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Rect.js\n// module id = 307\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Ring.js\n// module id = 308\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    var env = require('../../core/env');\n    var Path = require('../Path');\n\n    var shadowTemp = [\n        ['shadowBlur', 0],\n        ['shadowColor', '#000'],\n        ['shadowOffsetX', 0],\n        ['shadowOffsetY', 0]\n    ];\n\n    module.exports = Path.extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\n            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\n            // where exception \"unexpected call to method or property access\"\n            // might be thrown when calling ctx.fill after a path whose area size\n            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\n            // (e.g.,\n            //  ctx.moveTo(10, 10);\n            //  ctx.lineTo(20, 10);\n            //  ctx.closePath();\n            //  ctx.clip();\n            //  ctx.shadowBlur = 10;\n            //  ...\n            //  ctx.fill();\n            // )\n            ? function () {\n                var clipPaths = this.__clipPaths;\n                var style = this.style;\n                var modified;\n\n                if (clipPaths) {\n                    for (var i = 0; i < clipPaths.length; i++) {\n                        var shape = clipPaths[i] && clipPaths[i].shape;\n                        if (shape && shape.startAngle === shape.endAngle) {\n                            for (var j = 0; j < shadowTemp.length; j++) {\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n                            }\n                            modified = true;\n                            break;\n                        }\n                    }\n                }\n\n                Path.prototype.brush.apply(this, arguments);\n\n                if (modified) {\n                    for (var j = 0; j < shadowTemp.length; j++) {\n                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n                    }\n                }\n            }\n            : Path.prototype.brush,\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Sector.js\n// module id = 309\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * \n         *\n         * @param {string} path a.b.c\n         * @param {boolean} [loop] \n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Animatable.js\n// module id = 310\n// module chunks = 0 1 2 3 4 5 6","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget).target;\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    function param(target, e) {\n        return {target: target, topTarget: e && e.topTarget};\n    }\n\n    module.exports = Draggable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Draggable.js\n// module id = 311\n// module chunks = 0 1 2 3 4 5 6","\n\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            if (path.setData) {\n                path.setData(pathProxy.data);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            }\n            else {\n                var ctx = path;\n                pathProxy.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            transformPath(pathProxy, m);\n\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (!pathEl.path) {\n                    pathEl.createPathProxy();\n                }\n                if (pathEl.__dirtyPath) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            // Need path proxy.\n            pathBundle.createPathProxy();\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/path.js\n// module id = 312\n// module chunks = 0 1 2 3 4 5 6","\n\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i] *= sx;\n                    data[i++] += x;\n                    // cy\n                    data[i] *= sy;\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/transformPath.js\n// module id = 313\n// module chunks = 0 1 2 3 4 5 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var defaultOption = {\n        show: true,\n        zlevel: 0,                  // \n        z: 0,                       // \n        // \n        inverse: false,\n\n        // \n        name: '',\n        // 'start' | 'middle' | 'end'\n        nameLocation: 'end',\n        // degree\n        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n        nameTruncate: {\n            maxWidth: null,\n            ellipsis: '...',\n            placeholder: '.'\n        },\n        // \n        nameTextStyle: {},\n        // \n        nameGap: 15,\n\n        silent: false, // Default false to support tooltip.\n        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\n        tooltip: {\n            show: false\n        },\n\n        axisPointer: {},\n\n        // \n        axisLine: {\n            // show\n            show: true,\n            onZero: true,\n            // lineStyle\n            lineStyle: {\n                color: '#333',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        axisTick: {\n            // show\n            show: true,\n            // grid\n            inside: false,\n            // length\n            length: 5,\n            // lineStyle\n            lineStyle: {\n                width: 1\n            }\n        },\n        // axis.axisLabel\n        axisLabel: {\n            show: true,\n            // grid\n            inside: false,\n            rotate: 0,\n            showMinLabel: null, // true | false | null (auto)\n            showMaxLabel: null, // true | false | null (auto)\n            margin: 8,\n            // formatter: null,\n            // TEXTSTYLE\n            textStyle: {\n                fontSize: 12\n            }\n        },\n        // \n        splitLine: {\n            // show\n            show: true,\n            // lineStylelineStyle\n            lineStyle: {\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        splitArea: {\n            // show\n            show: false,\n            // areaStyleareaStyle\n            areaStyle: {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    };\n\n    var categoryAxis = zrUtil.merge({\n        // \n        boundaryGap: true,\n        // splitArea: {\n            // show: false\n        // },\n        splitLine: {\n            show: false\n        },\n        // \n        axisTick: {\n            // If tick is align with label when boundaryGap is true\n            alignWithLabel: false,\n            interval: 'auto'\n        },\n        // axis.axisLabel\n        axisLabel: {\n            interval: 'auto'\n        }\n    }, defaultOption);\n\n    var valueAxis = zrUtil.merge({\n        // \n        boundaryGap: [0, 0],\n        // ,  'dataMin' \n        // min: null,\n        //  'dataMax' \n        // max: null,\n        // Readonly prop, specifies start value of the range when using data zoom.\n        // rangeStart: null\n        // Readonly prop, specifies end value of the range when using data zoom.\n        // rangeEnd: null\n        // 0_min_max\n        // scale: false,\n        // 5\n        splitNumber: 5\n        // Minimum interval\n        // minInterval: null\n    }, defaultOption);\n\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n        scale: true,\n        min: 'dataMin',\n        max: 'dataMax'\n    }, valueAxis);\n\n    var logAxis = zrUtil.defaults({\n        scale: true,\n        logBase: 10\n    }, valueAxis);\n\n    module.exports = {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisDefault.js\n// module id = 315\n// module chunks = 0 1 2 3 4 6","\n\n    module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n\n        // Encoding visual for all series include which is filtered for legend drawing\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n\n            var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n            var symbolSize = seriesModel.get('symbolSize');\n\n            data.setVisual({\n                legendSymbol: legendSymbol || symbolType,\n                symbol: symbolType,\n                symbolSize: symbolSize\n            });\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof symbolSize === 'function') {\n                    data.each(function (idx) {\n                        var rawValue = seriesModel.getRawValue(idx);\n                        // FIXME\n                        var params = seriesModel.getDataParams(idx);\n                        data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n                    });\n                }\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var itemSymbolType = itemModel.getShallow('symbol', true);\n                    var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n                    // If has item symbol\n                    if (itemSymbolType != null) {\n                        data.setItemVisual(idx, 'symbol', itemSymbolType);\n                    }\n                    if (itemSymbolSize != null) {\n                        // PENDING Transform symbolSize ?\n                        data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n                    }\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/visual/symbol.js\n// module id = 318\n// module chunks = 0 2 3 6","\n    module.exports = function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/processor/dataFilter.js\n// module id = 337\n// module chunks = 0 5 6","// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\n\n\n    module.exports = function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    var filteredIdx = idxMap[rawIdx];\n\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null\n                        && data.getItemVisual(filteredIdx, 'color', true);\n\n                    if (!singleDataColor) {\n                        // FIXME Performance\n                        var itemModel = dataAll.getItemModel(rawIdx);\n                        var color = itemModel.get('itemStyle.normal.color')\n                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    }\n                    else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/visual/dataColor.js\n// module id = 345\n// module chunks = 0 5 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    // Must use radar component\n    require('../component/radar');\n\n    require('./radar/RadarSeries');\n    require('./radar/RadarView');\n\n    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'radar'));\n    echarts.registerVisual(zrUtil.curry(\n        require('../visual/symbol'), 'radar', 'circle', null\n    ));\n    echarts.registerLayout(require('./radar/radarLayout'));\n\n    echarts.registerProcessor(\n        zrUtil.curry(require('../processor/dataFilter'), 'radar')\n    );\n\n    echarts.registerPreprocessor(require('./radar/backwardCompat'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/radar.js\n// module id = 387\n// module chunks = 0 6","'use strict';\n\n\n    var SeriesModel = require('../../model/Series');\n    var List = require('../../data/List');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var zrUtil = require('zrender/lib/core/util');\n    var encodeHTML = require('../../util/format').encodeHTML;\n\n    var RadarSeries = SeriesModel.extend({\n\n        type: 'series.radar',\n\n        dependencies: ['radar'],\n\n\n        // Overwrite\n        init: function (option) {\n            RadarSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n        },\n\n        getInitialData: function (option, ecModel) {\n            var data = option.data || [];\n            var dimensions = completeDimensions(\n                [], data, {extraPrefix: 'indicator_', extraFromZero: true}\n            );\n            var list = new List(dimensions, this);\n            list.initData(data);\n            return list;\n        },\n\n        formatTooltip: function (dataIndex) {\n            var value = this.getRawValue(dataIndex);\n            var coordSys = this.coordinateSystem;\n            var indicatorAxes = coordSys.getIndicatorAxes();\n            var name = this.getData().getName(dataIndex);\n            return encodeHTML(name === '' ? this.name : name) + '<br/>'\n                + zrUtil.map(indicatorAxes, function (axis, idx) {\n                    return encodeHTML(axis.name + ' : ' + value[idx]);\n                }).join('<br />');\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            coordinateSystem: 'radar',\n            legendHoverLink: true,\n            radarIndex: 0,\n            lineStyle: {\n                normal: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            label: {\n                normal: {\n                    position: 'top'\n                }\n            },\n            // areaStyle: {\n            // },\n            // itemStyle: {}\n            symbol: 'emptyCircle',\n            symbolSize: 4\n            // symbolRotate: null\n        }\n    });\n\n    module.exports = RadarSeries;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/radar/RadarSeries.js\n// module id = 388\n// module chunks = 0 6","\n\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var symbolUtil = require('../../util/symbol');\n\n    function normalizeSymbolSize(symbolSize) {\n        if (!zrUtil.isArray(symbolSize)) {\n            symbolSize = [+symbolSize, +symbolSize];\n        }\n        return symbolSize;\n    }\n    module.exports = require('../../echarts').extendChartView({\n        type: 'radar',\n\n        render: function (seriesModel, ecModel, api) {\n            var polar = seriesModel.coordinateSystem;\n            var group = this.group;\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            function createSymbol(data, idx) {\n                var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n                var color = data.getItemVisual(idx, 'color');\n                if (symbolType === 'none') {\n                    return;\n                }\n                var symbolPath = symbolUtil.createSymbol(\n                    symbolType, -0.5, -0.5, 1, 1, color\n                );\n                symbolPath.attr({\n                    style: {\n                        strokeNoScale: true\n                    },\n                    z2: 100,\n                    scale: normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'))\n                });\n                return symbolPath;\n            }\n\n            function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {\n                // Simply rerender all\n                symbolGroup.removeAll();\n                for (var i = 0; i < newPoints.length - 1; i++) {\n                    var symbolPath = createSymbol(data, idx);\n                    if (symbolPath) {\n                        symbolPath.__dimIdx = i;\n                        if (oldPoints[i]) {\n                            symbolPath.attr('position', oldPoints[i]);\n                            graphic[isInit ? 'initProps' : 'updateProps'](\n                                symbolPath, {\n                                    position: newPoints[i]\n                                }, seriesModel, idx\n                            );\n                        }\n                        else {\n                            symbolPath.attr('position', newPoints[i]);\n                        }\n                        symbolGroup.add(symbolPath);\n                    }\n                }\n            }\n\n            function getInitialPoints(points) {\n                return zrUtil.map(points, function (pt) {\n                    return [polar.cx, polar.cy];\n                });\n            }\n            data.diff(oldData)\n                .add(function (idx) {\n                    var points = data.getItemLayout(idx);\n                    if (!points) {\n                        return;\n                    }\n                    var polygon = new graphic.Polygon();\n                    var polyline = new graphic.Polyline();\n                    var target = {\n                        shape: {\n                            points: points\n                        }\n                    };\n                    polygon.shape.points = getInitialPoints(points);\n                    polyline.shape.points = getInitialPoints(points);\n                    graphic.initProps(polygon, target, seriesModel, idx);\n                    graphic.initProps(polyline, target, seriesModel, idx);\n\n                    var itemGroup = new graphic.Group();\n                    var symbolGroup = new graphic.Group();\n                    itemGroup.add(polyline);\n                    itemGroup.add(polygon);\n                    itemGroup.add(symbolGroup);\n\n                    updateSymbols(\n                        polyline.shape.points, points, symbolGroup, data, idx, true\n                    );\n\n                    data.setItemGraphicEl(idx, itemGroup);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var itemGroup = oldData.getItemGraphicEl(oldIdx);\n                    var polyline = itemGroup.childAt(0);\n                    var polygon = itemGroup.childAt(1);\n                    var symbolGroup = itemGroup.childAt(2);\n                    var target = {\n                        shape: {\n                            points: data.getItemLayout(newIdx)\n                        }\n                    };\n                    if (!target.shape.points) {\n                        return;\n                    }\n                    updateSymbols(\n                        polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false\n                    );\n\n                    graphic.updateProps(polyline, target, seriesModel);\n                    graphic.updateProps(polygon, target, seriesModel);\n\n                    data.setItemGraphicEl(newIdx, itemGroup);\n                })\n                .remove(function (idx) {\n                    group.remove(oldData.getItemGraphicEl(idx));\n                })\n                .execute();\n\n            data.eachItemGraphicEl(function (itemGroup, idx) {\n                var itemModel = data.getItemModel(idx);\n                var polyline = itemGroup.childAt(0);\n                var polygon = itemGroup.childAt(1);\n                var symbolGroup = itemGroup.childAt(2);\n                var color = data.getItemVisual(idx, 'color');\n\n                group.add(itemGroup);\n\n                polyline.useStyle(\n                    zrUtil.defaults(\n                        itemModel.getModel('lineStyle.normal').getLineStyle(),\n                        {\n                            fill: 'none',\n                            stroke: color\n                        }\n                    )\n                );\n                polyline.hoverStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();\n\n                var areaStyleModel = itemModel.getModel('areaStyle.normal');\n                var hoverAreaStyleModel = itemModel.getModel('areaStyle.emphasis');\n                var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();\n                var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();\n\n                hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;\n                polygon.ignore = polygonIgnore;\n\n                polygon.useStyle(\n                    zrUtil.defaults(\n                        areaStyleModel.getAreaStyle(),\n                        {\n                            fill: color,\n                            opacity: 0.7\n                        }\n                    )\n                );\n                polygon.hoverStyle = hoverAreaStyleModel.getAreaStyle();\n\n                var itemStyle = itemModel.getModel('itemStyle.normal').getItemStyle(['color']);\n                var itemHoverStyle = itemModel.getModel('itemStyle.emphasis').getItemStyle();\n                var labelModel = itemModel.getModel('label.normal');\n                var labelHoverModel = itemModel.getModel('label.emphasis');\n                symbolGroup.eachChild(function (symbolPath) {\n                    symbolPath.setStyle(itemStyle);\n                    symbolPath.hoverStyle = zrUtil.clone(itemHoverStyle);\n\n                    var defaultText = data.get(data.dimensions[symbolPath.__dimIdx], idx);\n                    graphic.setText(symbolPath.style, labelModel, color);\n                    symbolPath.setStyle({\n                        text: labelModel.get('show') ? zrUtil.retrieve(\n                            seriesModel.getFormattedLabel(\n                                idx, 'normal', null, symbolPath.__dimIdx\n                            ),\n                            defaultText\n                        ) : ''\n                    });\n\n                    graphic.setText(symbolPath.hoverStyle, labelHoverModel, color);\n                    symbolPath.hoverStyle.text = labelHoverModel.get('show') ? zrUtil.retrieve(\n                        seriesModel.getFormattedLabel(\n                            idx, 'emphasis', null, symbolPath.__dimIdx\n                        ),\n                        defaultText\n                    ) : '';\n                });\n\n                function onEmphasis() {\n                    polygon.attr('ignore', hoverPolygonIgnore);\n                }\n\n                function onNormal() {\n                    polygon.attr('ignore', polygonIgnore);\n                }\n\n                itemGroup.off('mouseover').off('mouseout').off('normal').off('emphasis');\n                itemGroup.on('emphasis', onEmphasis)\n                    .on('mouseover', onEmphasis)\n                    .on('normal', onNormal)\n                    .on('mouseout', onNormal);\n\n                graphic.setHoverStyle(itemGroup);\n            });\n\n            this._data = data;\n        },\n\n        remove: function () {\n            this.group.removeAll();\n            this._data = null;\n        },\n\n        dispose: function () {}\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/radar/RadarView.js\n// module id = 389\n// module chunks = 0 6","// Backward compat for radar chart in 2\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = function (option) {\n        var polarOptArr = option.polar;\n        if (polarOptArr) {\n            if (!zrUtil.isArray(polarOptArr)) {\n                polarOptArr = [polarOptArr];\n            }\n            var polarNotRadar = [];\n            zrUtil.each(polarOptArr, function (polarOpt, idx) {\n                if (polarOpt.indicator) {\n                    if (polarOpt.type && !polarOpt.shape) {\n                        polarOpt.shape = polarOpt.type;\n                    }\n                    option.radar = option.radar || [];\n                    if (!zrUtil.isArray(option.radar)) {\n                        option.radar = [option.radar];\n                    }\n                    option.radar.push(polarOpt);\n                }\n                else {\n                    polarNotRadar.push(polarOpt);\n                }\n            });\n            option.polar = polarNotRadar;\n        }\n        zrUtil.each(option.series, function (seriesOpt) {\n            if (seriesOpt.type === 'radar' && seriesOpt.polarIndex) {\n                seriesOpt.radarIndex = seriesOpt.polarIndex;\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/radar/backwardCompat.js\n// module id = 390\n// module chunks = 0 6","\n\n    module.exports = function (ecModel) {\n        ecModel.eachSeriesByType('radar', function (seriesModel) {\n            var data = seriesModel.getData();\n            var points = [];\n            var coordSys = seriesModel.coordinateSystem;\n            if (!coordSys) {\n                return;\n            }\n\n            function pointsConverter(val, idx) {\n                points[idx] = points[idx] || [];\n                points[idx][i] = coordSys.dataToPoint(val, i);\n            }\n            for (var i = 0; i < coordSys.getIndicatorAxes().length; i++) {\n                var dim = data.dimensions[i];\n                data.each(dim, pointsConverter);\n            }\n\n            data.each(function (idx) {\n                // Close polygon\n                points[idx][0] && points[idx].push(points[idx][0].slice());\n                data.setItemLayout(idx, points[idx]);\n            });\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/radar/radarLayout.js\n// module id = 391\n// module chunks = 0 6","\n\n    require('../coord/radar/Radar');\n    require('../coord/radar/RadarModel');\n\n    require('./radar/RadarView');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/radar.js\n// module id = 401\n// module chunks = 0 6","\n\n    var AxisBuilder = require('../axis/AxisBuilder');\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n\n    module.exports = require('../../echarts').extendComponentView({\n\n        type: 'radar',\n\n        render: function (radarModel, ecModel, api) {\n            var group = this.group;\n            group.removeAll();\n\n            this._buildAxes(radarModel);\n            this._buildSplitLineAndArea(radarModel);\n        },\n\n        _buildAxes: function (radarModel) {\n            var radar = radarModel.coordinateSystem;\n            var indicatorAxes = radar.getIndicatorAxes();\n            var axisBuilders = zrUtil.map(indicatorAxes, function (indicatorAxis) {\n                var axisBuilder = new AxisBuilder(indicatorAxis.model, {\n                    position: [radar.cx, radar.cy],\n                    rotation: indicatorAxis.angle,\n                    labelDirection: -1,\n                    tickDirection: -1,\n                    nameDirection: 1\n                });\n                return axisBuilder;\n            });\n\n            zrUtil.each(axisBuilders, function (axisBuilder) {\n                zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n                this.group.add(axisBuilder.getGroup());\n            }, this);\n        },\n\n        _buildSplitLineAndArea: function (radarModel) {\n            var radar = radarModel.coordinateSystem;\n            var indicatorAxes = radar.getIndicatorAxes();\n            if (!indicatorAxes.length) {\n                return;\n            }\n            var shape = radarModel.get('shape');\n            var splitLineModel = radarModel.getModel('splitLine');\n            var splitAreaModel = radarModel.getModel('splitArea');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n\n            var showSplitLine = splitLineModel.get('show');\n            var showSplitArea = splitAreaModel.get('show');\n            var splitLineColors = lineStyleModel.get('color');\n            var splitAreaColors = areaStyleModel.get('color');\n\n            splitLineColors = zrUtil.isArray(splitLineColors) ? splitLineColors : [splitLineColors];\n            splitAreaColors = zrUtil.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];\n\n            var splitLines = [];\n            var splitAreas = [];\n\n            function getColorIndex(areaOrLine, areaOrLineColorList, idx) {\n                var colorIndex = idx % areaOrLineColorList.length;\n                areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];\n                return colorIndex;\n            }\n\n            if (shape === 'circle') {\n                var ticksRadius = indicatorAxes[0].getTicksCoords();\n                var cx = radar.cx;\n                var cy = radar.cy;\n                for (var i = 0; i < ticksRadius.length; i++) {\n                    if (showSplitLine) {\n                        var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n                        splitLines[colorIndex].push(new graphic.Circle({\n                            shape: {\n                                cx: cx,\n                                cy: cy,\n                                r: ticksRadius[i]\n                            }\n                        }));\n                    }\n                    if (showSplitArea && i < ticksRadius.length - 1) {\n                        var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);\n                        splitAreas[colorIndex].push(new graphic.Ring({\n                            shape: {\n                                cx: cx,\n                                cy: cy,\n                                r0: ticksRadius[i],\n                                r: ticksRadius[i + 1]\n                            }\n                        }));\n                    }\n                }\n            }\n            // Polyyon\n            else {\n                var realSplitNumber;\n                var axesTicksPoints = zrUtil.map(indicatorAxes, function (indicatorAxis, idx) {\n                    var ticksCoords = indicatorAxis.getTicksCoords();\n                    realSplitNumber = realSplitNumber == null\n                        ? ticksCoords.length - 1\n                        : Math.min(ticksCoords.length - 1, realSplitNumber);\n                    return zrUtil.map(ticksCoords, function (tickCoord) {\n                        return radar.coordToPoint(tickCoord, idx);\n                    });\n                });\n\n                var prevPoints = [];\n                for (var i = 0; i <= realSplitNumber; i++) {\n                    var points = [];\n                    for (var j = 0; j < indicatorAxes.length; j++) {\n                        points.push(axesTicksPoints[j][i]);\n                    }\n                    // Close\n                    if (points[0]) {\n                        points.push(points[0].slice());\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.error('Can\\'t draw value axis ' + i);\n                        }\n                    }\n\n                    if (showSplitLine) {\n                        var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n                        splitLines[colorIndex].push(new graphic.Polyline({\n                            shape: {\n                                points: points\n                            }\n                        }));\n                    }\n                    if (showSplitArea && prevPoints) {\n                        var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);\n                        splitAreas[colorIndex].push(new graphic.Polygon({\n                            shape: {\n                                points: points.concat(prevPoints)\n                            }\n                        }));\n                    }\n                    prevPoints = points.slice().reverse();\n                }\n            }\n\n            var lineStyle = lineStyleModel.getLineStyle();\n            var areaStyle = areaStyleModel.getAreaStyle();\n            // Add splitArea before splitLine\n            zrUtil.each(splitAreas, function (splitAreas, idx) {\n                this.group.add(graphic.mergePath(\n                    splitAreas, {\n                        style: zrUtil.defaults({\n                            stroke: 'none',\n                            fill: splitAreaColors[idx % splitAreaColors.length]\n                        }, areaStyle),\n                        silent: true\n                    }\n                ));\n            }, this);\n\n            zrUtil.each(splitLines, function (splitLines, idx) {\n                this.group.add(graphic.mergePath(\n                    splitLines, {\n                        style: zrUtil.defaults({\n                            fill: 'none',\n                            stroke: splitLineColors[idx % splitLineColors.length]\n                        }, lineStyle),\n                        silent: true\n                    }\n                ));\n            }, this);\n\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/radar/RadarView.js\n// module id = 402\n// module chunks = 0 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Axis = require('../Axis');\n\n    function IndicatorAxis(dim, scale, radiusExtent) {\n        Axis.call(this, dim, scale, radiusExtent);\n\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = 'value';\n\n        this.angle = 0;\n\n        /**\n         * Indicator name\n         * @type {string}\n         */\n        this.name = '';\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.model;\n    }\n\n    zrUtil.inherits(IndicatorAxis, Axis);\n\n    module.exports = IndicatorAxis;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/radar/IndicatorAxis.js\n// module id = 405\n// module chunks = 0 6","// TODO clockwise\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var IndicatorAxis = require('./IndicatorAxis');\n    var IntervalScale = require('../../scale/Interval');\n    var numberUtil = require('../../util/number');\n    var axisHelper = require('../axisHelper');\n\n    function Radar(radarModel, ecModel, api) {\n\n        this._model = radarModel;\n        /**\n         * Radar dimensions\n         * @type {Array.<string>}\n         */\n        this.dimensions = [];\n\n        this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {\n            var dim = 'indicator_' + idx;\n            var indicatorAxis = new IndicatorAxis(dim, new IntervalScale());\n            indicatorAxis.name = indicatorModel.get('name');\n            // Inject model and axis\n            indicatorAxis.model = indicatorModel;\n            indicatorModel.axis = indicatorAxis;\n            this.dimensions.push(dim);\n            return indicatorAxis;\n        }, this);\n\n        this.resize(radarModel, api);\n\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.cx;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.cy;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.r;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.startAngle;\n    }\n\n    Radar.prototype.getIndicatorAxes = function () {\n        return this._indicatorAxes;\n    };\n\n    Radar.prototype.dataToPoint = function (value, indicatorIndex) {\n        var indicatorAxis = this._indicatorAxes[indicatorIndex];\n\n        return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);\n    };\n\n    Radar.prototype.coordToPoint = function (coord, indicatorIndex) {\n        var indicatorAxis = this._indicatorAxes[indicatorIndex];\n        var angle = indicatorAxis.angle;\n        var x = this.cx + coord * Math.cos(angle);\n        var y = this.cy - coord * Math.sin(angle);\n        return [x, y];\n    };\n\n    Radar.prototype.pointToData = function (pt) {\n        var dx = pt[0] - this.cx;\n        var dy = pt[1] - this.cy;\n        var radius = Math.sqrt(dx * dx + dy * dy);\n        dx /= radius;\n        dy /= radius;\n\n        var radian = Math.atan2(-dy, dx);\n\n        // Find the closest angle\n        // FIXME index can calculated directly\n        var minRadianDiff = Infinity;\n        var closestAxis;\n        var closestAxisIdx = -1;\n        for (var i = 0; i < this._indicatorAxes.length; i++) {\n            var indicatorAxis = this._indicatorAxes[i];\n            var diff = Math.abs(radian - indicatorAxis.angle);\n            if (diff < minRadianDiff) {\n                closestAxis = indicatorAxis;\n                closestAxisIdx = i;\n                minRadianDiff = diff;\n            }\n        }\n\n        return [closestAxisIdx, +(closestAxis && closestAxis.coodToData(radius))];\n    };\n\n    Radar.prototype.resize = function (radarModel, api) {\n        var center = radarModel.get('center');\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n        var viewSize = Math.min(viewWidth, viewHeight) / 2;\n        this.cx = numberUtil.parsePercent(center[0], viewWidth);\n        this.cy = numberUtil.parsePercent(center[1], viewHeight);\n\n        this.startAngle = radarModel.get('startAngle') * Math.PI / 180;\n\n        this.r = numberUtil.parsePercent(radarModel.get('radius'), viewSize);\n\n        zrUtil.each(this._indicatorAxes, function (indicatorAxis, idx) {\n            indicatorAxis.setExtent(0, this.r);\n            var angle = (this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length);\n            // Normalize to [-PI, PI]\n            angle = Math.atan2(Math.sin(angle), Math.cos(angle));\n            indicatorAxis.angle = angle;\n        }, this);\n    };\n\n    Radar.prototype.update = function (ecModel, api) {\n        var indicatorAxes = this._indicatorAxes;\n        var radarModel = this._model;\n        zrUtil.each(indicatorAxes, function (indicatorAxis) {\n            indicatorAxis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeriesByType('radar', function (radarSeries, idx) {\n            if (radarSeries.get('coordinateSystem') !== 'radar'\n                || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel\n            ) {\n                return;\n            }\n            var data = radarSeries.getData();\n            zrUtil.each(indicatorAxes, function (indicatorAxis) {\n                indicatorAxis.scale.unionExtentFromData(data, indicatorAxis.dim);\n            });\n        }, this);\n\n        var splitNumber = radarModel.get('splitNumber');\n\n        function increaseInterval(interval) {\n            var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10));\n            // Increase interval\n            var f = interval / exp10;\n            if (f === 2) {\n                f = 5;\n            }\n            else { // f is 2 or 5\n                f *= 2;\n            }\n            return f * exp10;\n        }\n        // Force all the axis fixing the maxSplitNumber.\n        zrUtil.each(indicatorAxes, function (indicatorAxis, idx) {\n            var rawExtent = axisHelper.getScaleExtent(indicatorAxis.scale, indicatorAxis.model);\n            axisHelper.niceScaleExtent(indicatorAxis.scale, indicatorAxis.model);\n\n            var axisModel = indicatorAxis.model;\n            var scale = indicatorAxis.scale;\n            var fixedMin = axisModel.getMin();\n            var fixedMax = axisModel.getMax();\n            var interval = scale.getInterval();\n\n            if (fixedMin != null && fixedMax != null) {\n                // User set min, max, divide to get new interval\n                scale.setExtent(+fixedMin, +fixedMax);\n                scale.setInterval(\n                    (fixedMax - fixedMin) / splitNumber\n                );\n            }\n            else if (fixedMin != null) {\n                var max;\n                // User set min, expand extent on the other side\n                do {\n                    max = fixedMin + interval * splitNumber;\n                    scale.setExtent(+fixedMin, max);\n                    // Interval must been set after extent\n                    // FIXME\n                    scale.setInterval(interval);\n\n                    interval = increaseInterval(interval);\n                } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));\n            }\n            else if (fixedMax != null) {\n                var min;\n                // User set min, expand extent on the other side\n                do {\n                    min = fixedMax - interval * splitNumber;\n                    scale.setExtent(min, +fixedMax);\n                    scale.setInterval(interval);\n                    interval = increaseInterval(interval);\n                } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));\n            }\n            else {\n                var nicedSplitNumber = scale.getTicks().length - 1;\n                if (nicedSplitNumber > splitNumber) {\n                    interval = increaseInterval(interval);\n                }\n                // PENDING\n                var center = Math.round((rawExtent[0] + rawExtent[1]) / 2 / interval) * interval;\n                var halfSplitNumber = Math.round(splitNumber / 2);\n                scale.setExtent(\n                    numberUtil.round(center - halfSplitNumber * interval),\n                    numberUtil.round(center + (splitNumber - halfSplitNumber) * interval)\n                );\n                scale.setInterval(interval);\n            }\n        });\n    };\n\n    /**\n     * Radar dimensions is based on the data\n     * @type {Array}\n     */\n    Radar.dimensions = [];\n\n    Radar.create = function (ecModel, api) {\n        var radarList = [];\n        ecModel.eachComponent('radar', function (radarModel) {\n            var radar = new Radar(radarModel, ecModel, api);\n            radarList.push(radar);\n            radarModel.coordinateSystem = radar;\n        });\n        ecModel.eachSeriesByType('radar', function (radarSeries) {\n            if (radarSeries.get('coordinateSystem') === 'radar') {\n                // Inject coordinate system\n                radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];\n            }\n        });\n        return radarList;\n    };\n\n    require('../../CoordinateSystem').register('radar', Radar);\n    module.exports = Radar;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/radar/Radar.js\n// module id = 406\n// module chunks = 0 6","\n\n\n    var axisDefault = require('../axisDefault');\n    var valueAxisDefault = axisDefault.valueAxis;\n    var Model = require('../../model/Model');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var axisModelCommonMixin = require('../axisModelCommonMixin');\n\n    function defaultsShow(opt, show) {\n        return zrUtil.defaults({\n            show: show\n        }, opt);\n    }\n\n    var RadarModel = require('../../echarts').extendComponentModel({\n\n        type: 'radar',\n\n        optionUpdated: function () {\n            var boundaryGap = this.get('boundaryGap');\n            var splitNumber = this.get('splitNumber');\n            var scale = this.get('scale');\n            var axisLine = this.get('axisLine');\n            var axisTick = this.get('axisTick');\n            var axisLabel = this.get('axisLabel');\n            var nameTextStyle = this.get('name.textStyle');\n            var showName = this.get('name.show');\n            var nameFormatter = this.get('name.formatter');\n            var nameGap = this.get('nameGap');\n            var triggerEvent = this.get('triggerEvent');\n\n            var indicatorModels = zrUtil.map(this.get('indicator') || [], function (indicatorOpt) {\n                // PENDING\n                if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {\n                    indicatorOpt.min = 0;\n                }\n                else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {\n                    indicatorOpt.max = 0;\n                }\n                // Use same configuration\n                indicatorOpt = zrUtil.merge(zrUtil.clone(indicatorOpt), {\n                    boundaryGap: boundaryGap,\n                    splitNumber: splitNumber,\n                    scale: scale,\n                    axisLine: axisLine,\n                    axisTick: axisTick,\n                    axisLabel: axisLabel,\n                    // Competitable with 2 and use text\n                    name: indicatorOpt.text,\n                    nameLocation: 'end',\n                    nameGap: nameGap,\n                    // min: 0,\n                    nameTextStyle: nameTextStyle,\n                    triggerEvent: triggerEvent\n                }, false);\n                if (!showName) {\n                    indicatorOpt.name = '';\n                }\n                if (typeof nameFormatter === 'string') {\n                    var indName = indicatorOpt.name;\n                    indicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : '');\n                }\n                else if (typeof nameFormatter === 'function') {\n                    indicatorOpt.name = nameFormatter(\n                        indicatorOpt.name, indicatorOpt\n                    );\n                }\n                var model = zrUtil.extend(\n                    new Model(indicatorOpt, null, this.ecModel),\n                    axisModelCommonMixin\n                );\n\n                // For triggerEvent.\n                model.mainType = 'radar';\n                model.componentIndex = this.componentIndex;\n\n                return model;\n            }, this);\n\n            this.getIndicatorModels = function () {\n                return indicatorModels;\n            };\n        },\n\n        defaultOption: {\n\n            zlevel: 0,\n\n            z: 0,\n\n            center: ['50%', '50%'],\n\n            radius: '75%',\n\n            startAngle: 90,\n\n            name: {\n                show: true\n                // formatter: null\n                // textStyle: {}\n            },\n\n            boundaryGap: [0, 0],\n\n            splitNumber: 5,\n\n            nameGap: 15,\n\n            scale: false,\n\n            // Polygon or circle\n            shape: 'polygon',\n\n            axisLine: zrUtil.merge(\n                {\n                    lineStyle: {\n                        color: '#bbb'\n                    }\n                },\n                valueAxisDefault.axisLine\n            ),\n            axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),\n            axisTick: defaultsShow(valueAxisDefault.axisTick, false),\n            splitLine: defaultsShow(valueAxisDefault.splitLine, true),\n            splitArea: defaultsShow(valueAxisDefault.splitArea, true),\n\n            // {text, min, max}\n            indicator: []\n        }\n    });\n\n    module.exports = RadarModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/radar/RadarModel.js\n// module id = 407\n// module chunks = 0 6"],"sourceRoot":""}