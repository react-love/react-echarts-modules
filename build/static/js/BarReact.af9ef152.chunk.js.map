{"version":3,"sources":["../static/js/BarReact.af9ef152.chunk.js","EchartsDemo/BarReact.js","webpack:///./~/zrender/lib/core/util.js?10f4***","webpack:///./~/echarts/lib/echarts.js?68a2***","webpack:///./~/echarts/lib/util/graphic.js?e267***","webpack:///./~/echarts/lib/util/number.js?43e3***","webpack:///./~/echarts/lib/util/model.js?e2bd***","webpack:///./~/zrender/lib/core/vector.js?6654***","webpack:///./~/zrender/lib/graphic/Path.js?c119***","webpack:///./~/echarts/lib/util/format.js?7f72***","webpack:///./~/zrender/lib/core/env.js?9ccc***","webpack:///./~/echarts/lib/model/Model.js?f4df***","webpack:///./~/zrender/lib/core/BoundingRect.js?76f6***","webpack:///./~/echarts/lib/util/clazz.js?3e66***","webpack:///./~/echarts/lib/model/Component.js?0e02***","webpack:///./~/echarts/lib/util/layout.js?2b1e***","webpack:///./~/zrender/lib/core/matrix.js?97a2***","webpack:///./~/echarts/lib/coord/axisHelper.js?4730***","webpack:///./~/zrender/lib/contain/text.js?3a43***","webpack:///./~/zrender/lib/core/curve.js?9511***","webpack:///./~/zrender/lib/tool/color.js?284f***","webpack:///./~/zrender/lib/core/event.js?24ff***","webpack:///./~/zrender/lib/mixin/Eventful.js?223b***","webpack:///./~/echarts/lib/data/List.js?b096***","webpack:///./~/zrender/lib/core/PathProxy.js?69e9***","webpack:///./~/echarts/lib/scale/Scale.js?c922***","webpack:///./~/zrender/lib/config.js?2861***","webpack:///./~/zrender/lib/container/Group.js?8d57***","webpack:///./~/echarts/lib/CoordinateSystem.js?2b30***","webpack:///./~/echarts/lib/model/Series.js?186c***","webpack:///./~/echarts/lib/data/helper/completeDimensions.js?9c9e***","webpack:///./~/echarts/lib/util/symbol.js?be2c***","webpack:///./~/echarts/lib/model/mixin/makeStyleMapper.js?e2b1***","webpack:///./~/echarts/lib/component/axisPointer/modelHelper.js?ba01***","webpack:///./~/echarts/lib/scale/Interval.js?08e9***","webpack:///./~/zrender/lib/graphic/Displayable.js?5c45***","webpack:///./~/zrender/lib/graphic/Gradient.js?5165***","webpack:///./~/echarts/lib/util/component.js?cc72***","webpack:///./~/zrender/lib/core/timsort.js?0a74***","webpack:///./~/echarts/lib/coord/Axis.js?736c***","webpack:///./~/echarts/lib/chart/helper/createListFromArray.js?e3fc***","webpack:///./~/echarts/lib/component/axis/AxisBuilder.js?6417***","webpack:///./~/echarts/lib/coord/axisModelCommonMixin.js?a8d0***","webpack:///./~/echarts/lib/util/throttle.js?56b3***","webpack:///./~/echarts/lib/view/Chart.js?72f3***","webpack:///./~/echarts/lib/component/axis/AxisView.js?f854***","webpack:///./~/zrender/lib/core/log.js?26a2***","webpack:///./~/zrender/lib/graphic/Image.js?bf1b***","webpack:///./~/zrender/lib/mixin/Transformable.js?f61b***","webpack:///./~/echarts/lib/model/mixin/colorPalette.js?b454***","webpack:///./~/echarts/lib/scale/helper.js?370b***","webpack:///./~/zrender/lib/Element.js?325b***","webpack:///./~/zrender/lib/animation/Animator.js?d2b9***","webpack:///./~/zrender/lib/animation/requestAnimationFrame.js?6d88***","webpack:///./~/zrender/lib/contain/util.js?0031***","webpack:///./~/zrender/lib/core/LRU.js?018e***","webpack:///./~/zrender/lib/core/guid.js?f0e4***","webpack:///./~/zrender/lib/graphic/Pattern.js?a97e***","webpack:///./~/zrender/lib/graphic/Style.js?22d9***","webpack:///./~/zrender/lib/graphic/helper/poly.js?788c***","webpack:///./~/echarts/lib/component/axisPointer.js?110d***","webpack:///./~/echarts/lib/component/axisPointer/viewHelper.js?35c0***","webpack:///./~/echarts/lib/component/axisPointer/findPointFromSeries.js?2189***","webpack:///./~/echarts/lib/component/axisPointer/globalListener.js?00cf***","webpack:///./~/echarts/lib/data/DataDiffer.js?f330***","webpack:///./~/echarts/lib/component/axis/cartesianAxisHelper.js?ce88***","webpack:///./~/echarts/lib/component/axisPointer/CartesianAxisPointer.js?ab1e***","webpack:///./~/echarts/lib/component/gridSimple.js?eec5***","webpack:///./~/echarts/lib/view/Component.js?415a***","webpack:///./~/zrender/lib/core/bbox.js?1b56***","webpack:///./~/echarts/lib/coord/cartesian/AxisModel.js?0573***","webpack:///./~/zrender/lib/contain/line.js?4326***","webpack:///./~/zrender/lib/contain/quadratic.js?f589***","webpack:///./~/zrender/lib/contain/windingLine.js?625a***","webpack:///./~/zrender/lib/graphic/LinearGradient.js?4250***","webpack:///./~/zrender/lib/graphic/Text.js?3244***","webpack:///./~/zrender/lib/graphic/mixin/RectText.js?94ea***","webpack:///./~/zrender/lib/zrender.js?5dcd***","webpack:///./~/echarts/lib/ExtensionAPI.js?e283***","webpack:///./~/echarts/lib/component/axisPointer/BaseAxisPointer.js?027a***","webpack:///./~/echarts/lib/helper.js?5794***","webpack:///./~/echarts/lib/loading/default.js?8a5f***","webpack:///./~/echarts/lib/model/Global.js?b9d3***","webpack:///./~/echarts/lib/model/OptionManager.js?a7a5***","webpack:///./~/echarts/lib/model/globalDefault.js?fd54***","webpack:///./~/echarts/lib/model/mixin/areaStyle.js?4e41***","webpack:///./~/echarts/lib/model/mixin/boxLayout.js?92d7***","webpack:///./~/echarts/lib/model/mixin/itemStyle.js?9011***","webpack:///./~/echarts/lib/model/mixin/lineStyle.js?3579***","webpack:///./~/echarts/lib/model/mixin/textStyle.js?e4c8***","webpack:///./~/echarts/lib/preprocessor/backwardCompat.js?f171***","webpack:///./~/echarts/lib/preprocessor/helper/compatStyle.js?aff6***","webpack:///./~/echarts/lib/scale/Log.js?0ad0***","webpack:///./~/echarts/lib/scale/Ordinal.js?3a6b***","webpack:///./~/echarts/lib/scale/Time.js?6fdf***","webpack:///./~/echarts/lib/visual/seriesColor.js?4b6a***","webpack:///./~/zrender/lib/Handler.js?fbeb***","webpack:///./~/zrender/lib/Layer.js?f586***","webpack:///./~/zrender/lib/Painter.js?ee99***","webpack:///./~/zrender/lib/Storage.js?7e93***","webpack:///./~/zrender/lib/animation/Animation.js?8743***","webpack:///./~/zrender/lib/animation/Clip.js?fef9***","webpack:///./~/zrender/lib/animation/easing.js?64b6***","webpack:///./~/zrender/lib/contain/arc.js?7367***","webpack:///./~/zrender/lib/contain/cubic.js?b90e***","webpack:///./~/zrender/lib/contain/path.js?2e7f***","webpack:///./~/zrender/lib/core/GestureMgr.js?00fd***","webpack:///./~/zrender/lib/dom/HandlerProxy.js?2fc7***","webpack:///./~/zrender/lib/graphic/CompoundPath.js?8636***","webpack:///./~/zrender/lib/graphic/RadialGradient.js?895e***","webpack:///./~/zrender/lib/graphic/helper/roundRect.js?418d***","webpack:///./~/zrender/lib/graphic/helper/smoothBezier.js?2713***","webpack:///./~/zrender/lib/graphic/helper/smoothSpline.js?a17c***","webpack:///./~/zrender/lib/graphic/shape/Arc.js?2994***","webpack:///./~/zrender/lib/graphic/shape/BezierCurve.js?f5c4***","webpack:///./~/zrender/lib/graphic/shape/Circle.js?076e***","webpack:///./~/zrender/lib/graphic/shape/Line.js?7728***","webpack:///./~/zrender/lib/graphic/shape/Polygon.js?d37d***","webpack:///./~/zrender/lib/graphic/shape/Polyline.js?3cdb***","webpack:///./~/zrender/lib/graphic/shape/Rect.js?3b3d***","webpack:///./~/zrender/lib/graphic/shape/Ring.js?b71c***","webpack:///./~/zrender/lib/graphic/shape/Sector.js?9767***","webpack:///./~/zrender/lib/mixin/Animatable.js?35cb***","webpack:///./~/zrender/lib/mixin/Draggable.js?fbca***","webpack:///./~/zrender/lib/tool/path.js?dc4b***","webpack:///./~/zrender/lib/tool/transformPath.js?ddb2***","webpack:///./~/echarts/lib/component/tooltip.js?b491***","webpack:///./~/echarts/lib/coord/axisDefault.js?4492***","webpack:///./~/echarts/lib/coord/axisModelCreator.js?34e4***","webpack:///./~/echarts/lib/coord/cartesian/Grid.js?f167***","webpack:///./~/echarts/lib/component/axisPointer/AxisPointerModel.js?e99a***","webpack:///./~/echarts/lib/component/axisPointer/AxisPointerView.js?4293***","webpack:///./~/echarts/lib/component/axisPointer/axisTrigger.js?86e8***","webpack:///./~/echarts/lib/component/tooltip/TooltipContent.js?2c54***","webpack:///./~/echarts/lib/component/tooltip/TooltipModel.js?19ac***","webpack:///./~/echarts/lib/component/tooltip/TooltipView.js?ae52***","webpack:///./~/echarts/lib/component/axis.js?8a87***","webpack:///./~/echarts/lib/component/axis/CartesianAxisView.js?076a***","webpack:///./~/echarts/lib/component/grid.js?5897***","webpack:///./~/echarts/lib/coord/cartesian/Axis2D.js?9345***","webpack:///./~/echarts/lib/coord/cartesian/Cartesian.js?9246***","webpack:///./~/echarts/lib/coord/cartesian/Cartesian2D.js?103b***","webpack:///./~/echarts/lib/coord/cartesian/GridModel.js?1817***","webpack:///./~/echarts/lib/layout/barGrid.js?d23e","webpack:///./~/echarts/lib/chart/bar/BaseBarSeries.js?72f5","webpack:///./~/echarts/lib/chart/bar/helper.js?25d2","webpack:///./~/echarts/lib/chart/bar.js?931c","webpack:///./~/echarts/lib/chart/bar/BarSeries.js?61cd","webpack:///./~/echarts/lib/chart/bar/BarView.js?20fc","webpack:///./~/echarts/lib/chart/bar/barItemStyle.js?15d9"],"names":["webpackJsonp","Array","concat","module","__webpack_exports__","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","n","__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__","__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default","__WEBPACK_IMPORTED_MODULE_2_echarts_lib_component_tooltip__","__WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_grid__","__WEBPACK_IMPORTED_MODULE_4_echarts_lib_chart_bar__","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","BarReact","_React$Component","this","_this","getPrototypeOf","initPie","bind","_props$option","option","undefined","myChart","a","init","ID","setOption","window","onresize","resize","_this2","_props","_props$width","width","_props$height","height","createElement","ref","style","Component","exports","clone","source","result","typeStr","objToString","len","TYPED_ARRAY","from","BUILTIN_OBJECT","isPrimitive","isDom","hasOwnProperty","merge","overwrite","isObject","targetProp","sourceProp","isArray","isBuiltInObject","mergeAll","targetAndSources","extend","defaults","overlay","createCanvas","document","getContext","_ctx","util","indexOf","array","inherits","clazz","baseClazz","F","clazzPrototype","prop","mixin","isArrayLike","data","each","obj","cb","context","forEach","nativeForEach","map","nativeMap","push","reduce","memo","nativeReduce","filter","nativeFilter","find","func","args","nativeSlice","arguments","apply","curry","isFunction","isString","type","nodeType","ownerDocument","eqNaN","retrieve","values","slice","Function","assert","condition","message","Error","setAsPrimitive","primitiveKey","HashMap","set","createHashMap","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","toString","arrayProto","get","prefixedKey","removeKey","noop","global","createRegisterEventWithLowercaseName","method","eventName","handler","toLowerCase","Eventful","MessageCenter","ECharts","dom","theme","opts","prioritySortFunc","b","prio","themeStorage","id","group","_dom","zr","_zr","zrender","renderer","devicePixelRatio","_throttledZrFlush","throttle","zrUtil","flush","_theme","_chartsViews","_chartsMap","_componentsViews","_componentsMap","_coordSysMgr","CoordinateSystemManager","_api","createExtensionAPI","_messageCenter","_initEvents","_pendingActions","timsort","visualFuncs","dataProcessorFuncs","animation","on","_onframe","doConvertPixel","methodName","finder","ecModel","_model","coordSysList","getCoordinateSystems","modelUtil","parseFinder","coordSys","__DEV__","console","warn","updateDirectly","ecIns","payload","mainType","subType","callView","view","__alive","__model","query","eachComponent","model","index","__viewId","doDispatchAction","silent","payloadType","escapeConnect","actionWrap","actions","actionInfo","cptType","update","split","updateMethod","pop","parseClassType","IN_MAIN_PROCESS","payloads","batched","batch","item","eventObj","eventObjBatch","isHighDown","batchItem","action","event","main","sub","OPTION_UPDATED","updateMethods","prepareAndUpdate","trigger","flushPendingActions","pendingActions","shift","triggerUpdatedEvent","invokeUpdateMethod","api","component","componentModel","updateZ","eachSeries","seriesModel","idx","chart","updateProgressiveAndBlend","updateHoverLayerStatus","postUpdateFuncs","prepareView","isComponent","viewList","viewMap","componentType","viewId","classType","Clazz","ComponentView","getClass","ChartView","add","__id","__ecComponentInfo","componentIndex","remove","dispose","splice","processData","process","stackSeriesData","stackedDataMap","series","stack","getData","previousStack","stackedOn","doLayout","visual","isLayout","doVisualEncoding","excludesLayout","clearColorPalette","doRender","componentView","render","chartView","storage","elCount","traverse","el","isGroup","env","node","useHoverLayer","ignore","frameDrawNum","needProgressive","progressive","Math","floor","stopAnimation","blendMode","canvasSupported","setStyle","z","zlevel","ecInstance","coordSysMgr","ExtensionAPI","getComponentByElement","modelInfo","getComponent","parent","enableConnect","updateConnectedChartsStatus","charts","status","STATUS_KEY","eventActionMap","actionType","eventType","connectedGroups","makeActionFromEvent","otherCharts","instances","otherChart","dispatchAction","GlobalModel","OptionManager","ComponentModel","SeriesModel","graphic","colorTool","ACTION_REG","off","one","echartsProto","getDom","getZr","notMerge","lazyUpdate","optionManager","optionPreprocessorFuncs","setTheme","log","getModel","getOption","getWidth","getHeight","getDevicePixelRatio","painter","dpr","getRenderedCanvas","pixelRatio","backgroundColor","list","getDisplayList","getDataURL","excludeComponents","excludesComponentViews","url","toDataURL","getConnectedDataURL","groupId","mathMin","min","mathMax","max","left","Infinity","top","right","bottom","canvasList","canvas","boundingRect","getBoundingClientRect","targetCanvas","img","Image","x","y","image","refreshImmediately","convertToPixel","convertFromPixel","containPixel","models","coordinateSystem","containPoint","getVisual","visualType","defaultMainType","dataIndexInside","indexOfRawIndex","dataIndex","getItemVisual","getViewOfComponentModel","getViewOfSeriesModel","restoreData","isSingleCanvas","configLayer","clearColor","colorArr","parse","stringify","colorStops","background","updateView","clearAllVisual","updateVisual","updateLayout","optionChanged","resetOption","_loadingFX","showLoading","name","cfg","hideLoading","loadingEffects","opt","browser","weChat","MOUSE_EVENT_NAMES","eveName","e","params","dataModel","getSeriesByIndex","seriesIndex","getDataParams","dataType","eventData","isDisposed","_disposed","clear","idBase","Date","groupIdBase","echarts","version","dependencies","replace","existInstance","getInstanceByDom","nodeName","toUpperCase","clientWidth","clientHeight","setAttribute","connect","disConnect","disconnect","getAttribute","getInstanceById","registerTheme","registerPreprocessor","preprocessorFunc","registerProcessor","priority","processorFunc","isNaN","registerPostUpdate","postUpdateFunc","registerAction","test","registerCoordinateSystem","CoordinateSystem","register","getCoordinateSystemDimensions","coordSysCreator","getDimensionsInfo","dimensions","registerLayout","layoutFunc","registerVisual","visualFunc","registerLoading","loadingFx","extendComponentModel","extendComponentView","extendSeriesModel","extendChartView","setCanvasCreator","creator","List","Model","Axis","number","format","matrix","vector","color","helper","PRIORITY","PROCESSOR","FILTER","STATISTIC","VISUAL","LAYOUT","GLOBAL","CHART","COMPONENT","BRUSH","hasFillOrStroke","fillOrStroke","liftColor","lift","cacheElementStl","__hoverStlDirty","stroke","fill","hoverStyle","__hoverStl","normalStyle","__normalStl","doSingleEnterHover","__isHover","__zr","addHover","z2","doSingleLeaveHover","normalStl","removeHover","doEnterHover","child","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__hoverSilentOnTouch","zrByTouch","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","animatableModel","isAnimationEnabled","postfix","duration","getShallow","animationEasing","animationDelay","getAnimationDelayParams","animateTo","attr","pathTool","Path","Transformable","BoundingRect","round","Group","Text","Circle","Sector","Ring","Polygon","Polyline","Rect","Line","BezierCurve","Arc","CompoundPath","LinearGradient","RadialGradient","extendShape","extendPath","pathData","extendFromString","makePath","rect","layout","path","createFromString","getBoundingRect","aspect","cx","cy","resizePath","mergePath","applyTransform","pathRect","m","calculateTransform","subPixelOptimizeLine","param","subPixelOptimize","shape","lineWidth","x1","x2","y1","y2","subPixelOptimizeRect","originX","originY","originWidth","originHeight","position","positiveOrNegative","doubledPosition","setHoverStyle","hoverSilentOnTouch","setText","textStyle","labelModel","labelPosition","labelOffset","labelColor","textStyleModel","textDistance","textFont","getFont","textPosition","textOffset","textFill","getTextColor","gTextStyleModel","fontStyle","fontWeight","fontSize","fontFamily","join","updateProps","initProps","getTransform","ancestor","mat","identity","mul","getLocalTransform","transform","invert","transformDirection","direction","hBase","abs","vBase","vertex","groupTransition","g1","g2","getAnimatableProps","rotation","elMap1","g","elMap","anid","oldEl","newProp","clipPointsByRect","points","point","clipRectByRect","targetRect","_trim","str","quantityExponent","val","LN10","linearMap","domain","range","clamp","subDomain","subRange","parsePercent","percent","all","match","parseFloat","NaN","precision","returnStr","toFixed","asc","arr","sort","getPrecision","count","getPrecisionSafe","eIndex","dotIndex","getPixelPrecision","dataExtent","pixelExtent","dataQuantity","sizeQuantity","isFinite","getPercentWithPrecision","valueList","sum","acc","digits","pow","votesPerQuota","targetSeats","seats","votes","currentSum","remainder","Number","NEGATIVE_INFINITY","maxId","MAX_SAFE_INTEGER","remRadian","radian","pi2","PI","isRadianAroundZero","TIME_REG","getTimezoneOffset","parseDate","exec","timezoneOffset","timeOffset","quantity","nice","nf","exponent","exp10","f","reformIntervals","littleThan","lg","interval","close","curr","currClose","isNumeric","v","has","formatUtil","nubmerUtil","normalizeToArray","defaultEmphasis","subOpts","emphasisOpt","emphasis","normalOpt","normal","subOptName","LABEL_OPTIONS","getDataItemValue","dataItem","isDataItemOption","converDataValue","dimInfo","dimType","createDataFormatModel","dataFormatMixin","rawValue","getRawValue","rawDataIndex","getRawIndex","getName","itemOpt","getRawDataItem","componentSubType","seriesType","seriesId","seriesName","marker","getTooltipMarker","$vars","getFormattedLabel","dimIndex","labelProp","itemModel","getItemModel","formatter","formatTpl","formatTooltip","mappingToExists","exists","newCptOptions","exist","cptOption","isIdInner","makeIdAndName","mapResult","idMap","existCpt","keyInfo","idNum","compressBatches","batchA","batchB","makeMap","sourceBatch","otherMap","dataIndices","otherDataIndices","j","lenj","mapToArray","isData","mapA","mapB","queryDataIndex","indexOfName","makeGetter","hostObj","parsedKey","queryType","includeMainTypes","queryParam","queryComponents","dataDimToCoordDim","dataDim","getDimension","dimItem","getDimensionInfo","coordDim","coordDimToDataDim","dimName","coordDimIndex","otherDimToDataDim","otherDim","otherDims","ArrayCtor","Float32Array","out","copy","v1","v2","scaleAndAdd","sqrt","lenSquare","div","dot","scale","s","normalize","d","distance","distanceSquare","negate","lerp","t","lengthSquare","dist","distSquare","Displayable","PathProxy","pathContain","Pattern","getCanvasPattern","pathProxyForDraw","__dirtyPath","strokeContainThreshold","brush","ctx","prevEl","hasStroke","hasFill","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","__dirty","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","getGlobalScale","setScale","beginPath","setLineDashOffset","buildPath","rebuildPath","restoreTransform","text","drawRectText","shapeCfg","inBundle","createPathProxy","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","w","lineScale","strokeNoScale","getLineScale","contain","localPos","transformCoordToLocal","containStroke","dirty","dirtyPath","refresh","__clipTarget","animateShape","loop","animate","attrKV","setShape","Sub","extendFrom","defaultShape","thisShape","numberUtil","textContain","addCommas","toCamelCase","upperCaseFirst","group1","charAt","normalizeCssArray","encodeHTML","String","TPL_VAR_ALIAS","wrapVar","varName","seriesIdx","tpl","paramsList","encode","seriesLen","alias","k","formatTplSimple","extraCssText","s2d","formatTime","isUTC","date","utc","M","h","capitalFirst","substr","truncateText","navigator","os","ua","firefox","ie","edge","touchEventsSupported","pointerEventsSupported","userAgent","parentModel","doGet","pathArr","getParent","getParentMethod","clazzUtil","mergeOption","ignoreParent","parsePath","thisParentModel","isEmpty","Ctor","setReadOnly","properties","customizeGetParent","enableClassExtend","vec2","v2ApplyTransform","union","other","lt","rb","lb","rt","maxX","maxY","sx","sy","translate","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","checkClassType","superCall","superApply","IS_CONTAINER","host","hasOwn","ret","RootClass","mandatoryMethods","$constructor","proto","ExtendedClass","enableClassManagement","entity","options","makeContainer","container","registerClass","componentMainType","throwWhenNotFound","getClassesByMainType","o","hasClass","getAllClassMainTypes","types","hasSubTypes","registerWhenExtend","originalExtend","getDependencies","deps","arrayPush","componentUtil","defaultOption","dependentModels","uid","layoutMode","extraOpt","getUID","mergeDefaultAndTheme","inputPositionParams","getLayoutParams","themeModel","getTheme","getDefaultOption","mergeLayoutParam","optionUpdated","newCptOption","isInit","optList","Class","getReferringComponents","enableSubTypeDefaulter","enableTopologicalTravel","boxLayout","orient","gap","maxWidth","maxHeight","currentLineMaxSize","eachChild","nextX","nextY","nextChild","childAt","nextChildRect","moveX","newline","moveY","LOCATION_PARAMS","HV_NAMES","box","vbox","hbox","getAvailableSize","positionInfo","containerRect","margin","containerWidth","containerHeight","getLayoutRect","verticalMargin","horizontalMargin","positionElement","hv","boundingMode","needLocalTransform","elPos","dx","dy","sizeCalculable","hvIdx","targetOption","newOption","names","newParams","newValueCount","merged","mergedValueCount","hasProp","hasValue","ignoreSize","hResult","vResult","copyLayoutParams","m1","m2","out0","out1","out2","out3","out4","out5","rotate","rad","aa","ac","atx","ab","ad","aty","st","sin","ct","cos","vx","vy","det","OrdinalScale","IntervalScale","Scale","axisHelper","getScaleExtent","axisDataLen","boundaryGap","span","scaleType","getMin","getMax","fixMin","fixMax","originalExtent","getExtent","setBlank","getNeedCrossZero","niceScaleExtent","extent","splitNumber","base","setExtent","niceExtent","minInterval","setInterval","createScaleByModel","axisType","getCategories","ifAxisCrossZero","axis","getAxisLabelInterval","tickCoords","labels","font","isAxisHorizontal","textSpaceTakenRect","autoLabelInterval","accumulatedLabelInterval","step","tickCoord","getFormattedLabels","labelFormatter","getTicksLabels","ticks","getTicks","tick","getAxisRawValue","getLabel","getTextWidth","textWidthCache","textLines","l","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getTextRect","textAlign","textBaseline","textLineLen","lineHeight","adjustTextPositionOnRect","textRect","textHeight","halfHeight","ellipsis","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","isAroundZero","EPSILON","isNotAroundZero","cubicAt","p0","p1","p2","p3","onet","cubicDerivativeAt","cubicRootAt","roots","c","A","B","C","t1","disc","K","t2","discSqrt","mathSqrt","Y1","Y2","mathPow","ONE_THIRD","T","theta","acos","ASqrt","tmp","THREE_SQRT","t3","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","x0","y0","x3","y3","prev","next","d1","d2","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","v2Create","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseInt","parseCssFloat","cssHueToRgb","p","setRgba","r","copyRgba","putToCache","colorStr","rgbaArr","lastRemovedArr","colorCache","put","cached","kCSSColorTable","op","ep","fname","alpha","hsla2rgba","iv","hsla","rgba","rgba2hsla","H","S","R","G","vMin","vMax","delta","L","deltaR","deltaG","deltaB","level","toHex","fastMapToColor","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","LRU","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","clientToLocal","calculate","defaultGetZrXY","layerX","offsetX","zrX","zrY","layerY","offsetY","clientX","clientY","normalizeEvent","touch","targetTouches","changedTouches","zrDelta","wheelDelta","detail","addEventListener","isDomLevel2","attachEvent","removeEventListener","detachEvent","stop","preventDefault","stopPropagation","cancelBubble","returnValue","Dispatcher","arrySlice","_$handlers","_h","isSilent","newList","argLen","triggerWithContext","transferProperties","TRANSFERABLE_PROPERTIES","__wrappedMethods","propName","DefaultDataProvider","dataArray","_array","normalizeDimensions","cloneListForMapAndSample","original","excludeDimensions","allDimensions","hostModel","_storage","originalStorage","dim","dimStore","globalObj","Float64Array","Int32Array","dataCtors","float","int","ordinal","time","DataDiffer","pure","getItem","dimensionInfos","dimensionNames","dimensionName","dimensionInfo","stackable","_dimensionInfos","indices","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawData","_extent","listProto","hasItemOption","initData","nameList","dimValueGetter","isDataArray","nameDimIdx","dimensionInfoMap","size","idList","nameRepeatCount","itemName","DataCtor","stackedValue","getValues","getDataExtent","dimData","dimExtent","getSum","rawIndex","mid","indicesOfNearest","maxDistance","nearestIndices","minDist","MAX_VALUE","minDiff","diff","rawIdx","getId","dims","dimSize","filterSelf","newIndices","keep","mapArray","tmpRetValue","retValue","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","originalIndices","frameValues","frameIndices","frameSize","otherList","otherIdList","setVisual","setLayout","getLayout","getItemLayout","setItemLayout","clearItemLayouts","itemVisual","setItemVisual","setItemDataAndSeriesIndex","setItemGraphicEl","getItemGraphicEl","eachItemGraphicEl","cloneShallow","dimensionInfoList","wrapMethod","injectFunction","originalMethod","res","TRANSFERABLE_METHODS","CHANGABLE_METHODS","curve","bbox","CMD","Q","Z","min2","max2","mathCos","mathSin","mathAbs","hasTypedArray","notSaveData","_saveData","_xi","_yi","_x0","_y0","_ux","_uy","_len","_lineDash","_dashOffset","_dashIdx","_dashSum","moveTo","addData","lineTo","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","_dashedBezierTo","quadraticCurveTo","_dashedQuadraticTo","arc","startAngle","endAngle","anticlockwise","arcTo","radius","closePath","toStatic","lineDashSum","offset","setData","appendPath","appendSize","appendPathData","cmd","_expandData","_prevCmd","newData","dash","dashSum","nDash","bezierLen","tmpLen","xi","yi","fromLine","fromCubic","fromQuadratic","rx","ry","fromArc","ux","uy","dTheta","psi","fs","scaleX","scaleY","isEllipse","setting","_setting","_interval","scaleProto","getSetting","unionExtent","unionExtentFromData","start","end","thisExtent","isBlank","_isBlank","config","debugMode","Element","_children","__storage","children","childOfName","childCount","_doAdd","addBefore","nextSibling","addToStorage","addChildrenToStorage","delFromStorage","delChildrenFromStorage","removeAll","includeChildren","tmpRect","tmpMat","invisible","childRect","_coordinateSystems","coordinateSystemCreators","coordinateSystems","creater","coordinateSystemCreator","classUtil","colorPaletteMixin","legendDataProvider","visualColorAccessPath","getInitialData","label","fillDataTextStyle","newSeriesOption","getLinkedData","getRawData","getBaseAxis","multipleSeries","formattedValue","setEachItem","dimIdx","tooltip","valStr","vertially","tooltipName","tooltipDims","colorEl","animationEnabled","getColorFromPalette","scope","getAxisTooltipData","getTooltipPosition","completeDimensions","sysDims","applyDim","resultItem","OTHER_DIMS","coordDimNameMap","genName","fromZero","dimsDef","encodeDef","dataDimNameMap","dimCount","value0","retrieveValue","sysDimItem","sysDimItemDimsDef","dimDefItem","userDimName","dataDims","resultDimIdx","availDimIdx","sysDimIndex","sysDimItemOtherDims","extra","extraPrefix","extraFromZero","isExtraCoord","guessOrdinal","Triangle","Diamond","Pin","angle","asin","tanX","tanY","cpLen","cpLen2","Arrow","symbolCtors","line","roundRect","square","circle","diamond","pin","arrow","triangle","symbolShapeMakers","symbolBuildProxies","Symbol","symbolType","beforeBrush","textVerticalAlign","proxySymbol","symbolPathSetColor","symbolStyle","symbolShape","__isEmptyBrush","symbolUtil","createSymbol","symbolPath","setColor","excludes","includes","collectAxesInfo","globalTooltipModel","globalAxisPointerModel","linksOption","linkGroups","saveTooltipAxisInfo","fromTooltip","triggerTooltip","axisPointerModel","axisPointerShow","isHandleTrigger","makeAxisPointerModel","baseTooltipModel","snap","makeKey","involveSeries","axisInfo","axesInfo","useHandle","seriesModels","axesInfoInCoordSys","seriesInvolved","groupIndex","getLinkGroupIndex","linkGroup","mapper","axisPointerEnabled","coordSysKey","coordSysAxesInfo","coordSysMap","coordSysModel","getAxes","getTooltipAxes","triggerAxis","cross","tooltipAxes","baseAxes","otherAxes","tooltipAxisPointerModel","volatileOption","field","labelOption","show","crossStyle","lineStyle","collectSeriesInfo","seriesTooltipTrigger","seriesTooltipShow","getAxis","seriesDataCount","axisModel","linkOption","checkPropInLink","linkPropValue","axisPropValue","collect","fixValue","getAxisInfo","reverse","getAxisPointerModel","roundNumber","_intervalPrecision","getInterval","_niceExtent","getIntervalPrecision","intervalScaleGetTicks","niceTicks","intervalScaleNiceTicks","intervalPrecision","niceTickExtent","expandSize","Style","__clipPaths","RectText","draggable","dragging","culling","cursor","rectHover","afterBrush","rectContain","coord","animateStyle","useStyle","Gradient","addColorStop","random","subTypeDefaulters","registerSubTypeDefaulter","defaulter","determineSubType","componentTypeMain","dependencyGetter","makeDepndencyGraph","fullNameList","graph","noEntryList","thisItem","createDependencyGraphItem","originalDeps","availableDeps","getAvailableDependencies","entryCount","dependentName","predecessor","thatItem","successor","dep","topologicalTravel","targetNameList","callback","removeEdge","succComponentType","removeEdgeAndAdd","targetNameSet","currComponentType","currVertex","isInTargetNameSet","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","pivot","gallopLeft","hint","lastOffset","maxOffset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","remaining","ts","minRun","force","fixExtentWithBands","nTick","normalizedExtent","inverse","onBand","_labelInterval","containData","dataToCoord","coordToData","pointToData","getTicksCoords","alignWithLabel","bands","getBands","coords","getLabelsCoords","getBandWidth","axisExtent","getLabelInterval","labelInterval","isHorizontal","firstDataNotNull","ifNeedCompleteOrdinalData","sampleItem","createListFromArray","coordSysName","creators","registeredCoordSys","completeDimOpt","categoryIndex","createNameList","categories","categoryAxesModels","isStackable","getDimTypeByAxis","categoryAxisModel","categoryDim","dataLen","cartesian2d","axesModels","xAxisModel","yAxisModel","xAxisType","yAxisType","isXAxisCateogry","isYAxisCategory","singleAxis","singleAxisModel","singleAxisType","isCategory","single","polar","polarModel","angleAxisModel","findAxisModel","radiusAxisModel","radiusAxisType","angleAxisType","isAngleAxisCateogry","isRadiusAxisCateogry","geo","makeAxisEventDataBase","endTextLayout","textRotate","rotationDiff","onLeft","tooltipOpt","fixMinMaxLabelShow","textEls","showMinLabel","showMaxLabel","firstLabel","nextLabel","lastLabel","prevLabel","isTwoLabelOverlapped","current","labelLayout","firstRect","nextRect","mRotationBack","AxisBuilder","nameDirection","tickDirection","labelDirection","dumbGroup","updateTransform","_transform","_dumbGroup","hasBuilder","builders","getGroup","axisLine","pt1","pt2","lineCap","getLineStyle","axisTick","tickModel","lineStyleModel","tickLen","tickInterval","ticksCoords","ifIgnoreOnTick","axisLabel","axisLabelShow","labelMargin","labelRotation","labelRotate","innerTextLayout","categoryData","triggerEvent","tickVal","itemTextStyleModel","textColor","pos","labelStr","textEl","targetType","decomposeTransform","axisName","nameLocation","gapSignal","nameRotation","axisNameAvailableWidth","truncateOpt","nameTruncateMaxWidth","truncatedText","formatterParams","__fullText","__truncatedText","content","axisRotation","textRotation","rawTick","origin","rangeStart","rangeEnd","getCoordSysModel","setRange","resetRange","lib","ORIGIN_METHOD","RATE","fn","delay","debounce","lastExec","getTime","timer","currCall","debounceNextCall","lastCall","thisDelay","thisDebounce","clearTimeout","setTimeout","debounceDelay","createOrUpdate","fnAttr","throttleType","originFn","lastThrottleType","Chart","elSetState","state","toggleHighlight","dataIdx","highlight","downplay","chartProto","updateAxisPointer","axisView","forceRender","AxisView","getAxisPointerClass","axisPointerClass","axisPointerModelHelper","_axisPointer","disposeAxisPointer","axisPointer","axisPointerClazz","registerAxisPointerClass","ZImage","globalImageCache","src","_image","cachedImgObj","onload","pending","sWidth","sHeight","drawImage","mIdentity","transformableProto","parentHasTransform","invTransform","tmpTransform","atan2","transformCoordToGlobal","colorIdx","colorNameMap","colorPalette","fixExtent","guid","Animatable","clipPath","drift","beforeUpdate","afterUpdate","hide","setClipPath","addSelfToZr","removeClipPath","removeSelfFromZr","animators","addAnimator","removeAnimator","defaultGetter","defaultSetter","interpolateNumber","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","arraySlice","isArraySame","catmullRomInterpolateArray","catmullRomInterpolate","v0","cloneValue","rgba2String","getArrayDim","keyframes","lastValue","createTrackClip","animator","easing","oneTrackDone","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","_target","lastFrame","lastFramePercent","onframe","frame","clip","Clip","life","_loop","_delay","ondestroy","Animator","_tracks","_clipCount","_doneList","_onframeList","_clipList","when","tracks","during","pause","_paused","resume","isPaused","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","forwardToLast","clipList","removeClip","done","getClips","requestAnimationFrame","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","PI2","normalizeRadian","LinkedList","head","tail","linkedListProto","insert","entry","Entry","insertEntry","maxSize","_list","_map","_maxSize","_lastRemovedEntry","LRUProto","removed","leastUsedEntry","idStart","repeat","createPattern","createLinearGradient","createRadialGradient","STYLE_COMMON_PROPS","opacity","shadowBlur","shadowOffsetX","shadowOffsetY","textStroke","textPositionRect","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","blend","prevStyle","firstDraw","styleName","globalAlpha","globalCompositeOperation","otherStyle","newStyle","canvasGradient","styleProto","smoothSpline","smoothBezier","smooth","controlPoints","smoothConstraint","cp1","cp2","axisTrigger","link","confineInContainer","viewWidth","viewHeight","buildElStyle","axisPointerType","styleModel","getAreaStyle","buildLabelElOption","elOption","labelPos","getValueLabel","paddings","align","verticalAlign","bgColor","shadowColor","seriesDataIndices","seriesData","idxItem","dataParams","getTransformedPosition","layoutInfo","buildCartesianSingleLabelElOption","textLayout","makeLineShape","xDimIndex","makeRectShape","xy","wh","makeSectorShape","r0","clockwise","dataToPoint","initGlobalListeners","useHandler","dis","makeDispatchAction","records","record","dispatchTooltipFinally","pendings","initialized","doEnter","onLeave","actuallyPayload","showLen","showTip","hideLen","hideTip","currTrigger","pendingList","globalListener","unregister","defaultKeyGetter","oldArr","newArr","oldKeyGetter","newKeyGetter","_old","_new","_oldKeyGetter","_newKeyGetter","initIndexMap","keyArr","keyGetter","existence","_add","_update","_remove","execute","oldDataIndexMap","newDataIndexMap","oldDataKeyArr","newDataKeyArr","unshift","gridModel","getZero","theAxis","grid","toGlobalCoord","rawAxisPosition","axisPosition","onZero","axisDim","getRect","rectBound","axisOffset","posMap","dirMap","labelInside","getCartesian","getAxisDimIndex","BaseAxisPointer","viewHelper","cartesianAxisHelper","CartesianAxisPointer","makeElOption","otherExtent","getOtherAxis","getGlobalExtent","pixelValue","elStyle","pointerOption","pointerShapeBuilder","graphicKey","pointer","getHandleTransform","updateHandleTransform","currPosition","cursorOtherValue","cursorPoint","tooltipOptions","tooltipOption","targetShape","shadow","bandWidth","getItemStyle","xAxis","yAxis","componentProto","extremity","fromPoints","xDim","yDim","tx","ty","vec2Min","vec2Max","getAxisType","axisModelCreator","AxisModel","gridIndex","gridId","extraOption","_l","_a","_b","dir","globalCoord","strokeText","fillText","maxValue","lastIndexOf","save","baseline","textShadowColor","restore","delInstance","Handler","Storage","Animation","HandlerProxy","useVML","painterCtors","ZRender","getInstance","registerPainter","rendererType","vml","handerProxy","getViewportRoot","root","stage","_needsRefresh","oldDelFromStorage","oldAddToStorage","addRoot","delRoot","zLevel","_needsRefreshHover","refreshHoverImmediately","refreshHover","clearHover","clearAnimation","pathToImage","setCursorStyle","cursorStyle","findHover","eventHandler","chartInstance","echartsAPIList","animationModel","moveAnimation","propsEqual","lastProp","lastProps","newProps","equals","updateLabelShowHide","labelEl","getHandleTransProps","trans","createIcon","handleModel","handlers","iconStr","updateMandatoryProps","eventTool","_group","_lastGraphicKey","_handle","_dragging","_lastValue","_lastStatus","_payloadInfo","animationThreshold","_axisModel","_axisPointerModel","handle","_moveAnimation","determineAnimation","doUpdateProps","updatePointerEl","updateLabelEl","createPointerEl","createLabelEl","_renderHandle","isCategoryAxis","useSnap","pointerEl","onmousemove","onmousedown","_onHandleDragMove","ondragend","_onHandleDragEnd","includeStyles","handleSize","_moveHandleToValue","_doDispatchAxisPointer","payloadInfo","axisIndex","doClear","buildLabel","axisModelCommonMixin","createList","createScale","mixinAxisModelCommonMethods","maskColor","mask","labelRect","mergeTheme","themeItem","initBase","baseOption","OPTION_INNER_KEY","_seriesIndices","globalDefault","getComponentsByTypes","componentsMap","existComponent","createSeriesIndices","filterBySubType","components","cpt","assertSeriesInitialized","_optionManager","mountOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","mediaOption","visitComponent","newCptOptionList","ComponentModelClass","newCptTypes","componentOption","cpts","isIdArray","isNameArray","findComponents","queryCond","q","indexAttr","idAttr","nameAttr","queryResult","getSeriesByName","oneSeries","getSeriesByType","getSeries","rawSeriesIndex","eachRawSeries","eachSeriesByType","eachRawSeriesByType","isSeriesFiltered","getCurrentSeriesIndices","filterSeries","filteredSeries","componentTypes","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","parseRawOption","rawOption","isNew","mediaDefault","timelineOptions","mediaList","timelineOpt","timeline","media","singleMedia","preProcess","applyMediaQuery","ecWidth","ecHeight","realMap","aspectratio","applicatable","matched","QUERY_REG","operator","realAttr","real","expect","indicesEquals","indices1","indices2","oldOption","newCptOpt","oldCptOpt","oldOptionBackup","newParsedOption","isRecreate","optionBackup","timelineModel","getCurrentIndex","platform","animationDuration","animationDurationUpdate","animationEasingUpdate","progressiveThreshold","hoverLayerThreshold","useUTC","getBoxLayoutParams","getBorderLineDash","lineType","getLineDash","dotSize","dashSize","graphicUtil","compatLayoutProperties","LAYOUT_PROPERTIES","compatStyle","COMPATITABLE_COMPONENTS","COMPATITABLE_SERIES","seriesOpt","clockWise","pointerColor","dataRange","visualMap","componentName","compatItemStyle","itemStyleOpt","itemStyle","POSSIBLE_STYLES","normalItemStyleOpt","emphasisItemStyleOpt","markPoint","markLine","mpData","mlData","fixRoundingError","originalVal","roundingErrorFix","intervalScaleProto","mathFloor","mathCeil","mathLog","LogScale","_originalScale","originalScale","powVal","__fixMin","__fixMax","approxTickNum","err","_data","rank","scaleHelper","bisect","TimeScale","stepLvl","_stepLvl","ONE_HOUR","getFullYear","getMonth","getDate","approxInterval","scaleLevelsLen","scaleLevels","yearSpan","ONE_SECOND","ONE_MINUTE","ONE_DAY","encodeColor","colorAccessPath","makeEventPacket","eveType","targetInfo","topTarget","gestureEvent","pinchX","pinchY","pinchScale","EmptyProxy","isHover","displayable","SILENT","Draggable","handlerNames","proxy","painterRoot","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","lastHovered","hovered","hoveredTarget","lastHoveredTarget","setCursor","dispatchToElement","mouseout","innerDom","element","toElement","relatedTarget","parentNode","dispatch","eventArgs","eventPacket","eachOtherLayer","layer","exclude","hoverCheckResult","_downel","_upel","returnFalse","createDom","newDom","newDomStyle","Layer","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","initContext","createBackBuffer","clearAll","haveMotionBLur","clearRect","clearColorGradientOrPattern","__canvasGradient","fillRect","parseInt10","isLayerValid","__builtin__","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","clipPaths","prevClipPaths","doClip","createRoot","domRoot","cssText","Painter","singleCanvas","_opts","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","_domRoot","_getSize","appendChild","_progressiveLayers","_hoverlayer","_hoverElements","paintAll","_paintList","_startProgessive","__hoverMir","elMirror","__from","hoverElements","hoverLayer","displayableSortFunc","getLayer","originalEl","_doPaintEl","token","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuiltinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","MAX_PROGRESSIVE_LAYER_NUMBER","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","virtual","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","removeChild","display","clearLayer","findAndDrawOtherLayer","smaller","larger","intermediateLayer","renderToCanvas","imageLayer","displayList","whIdx","cwh","plt","prb","stl","defaultView","getComputedStyle","shadowBlurSize","leftMargin","rightMargin","topMargin","bottomMargin","pathTransform","ImageShape","imgShape","shapeCompareFunc","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","_updateAndAddDisplayable","userSetClipPath","currentClipPath","parentClipPath","_renderList","_clips","_running","_time","_pausedTime","_pauseStart","clips","deferredEvents","deferredClips","_needsRemove","fire","_startLoop","_life","_initialized","onrestart","easingFuncs","globalTime","deltaTime","_startTime","easingFunc","schedule","restart","arg","linear","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","windingQuadratic","y_","x_","windingArc","containPath","isStroke","windingLine","cubic","quadratic","_x","pointPair","center","eventUtil","GestureMgr","_track","recognize","_doTrack","_recognize","touches","trackItem","recognizers","gestureInfo","pinch","track","pinchEnd","pinchPre","pinchCenter","eventNameFix","processGesture","gestureMgr","_gestureMgr","setTouchTimer","_touching","_touchTimer","isPointerFromTouch","pointerType","initDomHandler","makeMouseHandler","touchHandlerNames","_handlers","domHandlers","pointerHandlerNames","mouseHandlerNames","HandlerDomProxy","mountHandlers","pointerEventNames","pointerdown","pointerup","pointermove","pointerout","nm","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","paths","_updatePathDirty","r1","r2","r3","r4","total","v2Min","v2Max","v2Scale","v2Distance","v2Add","isLoop","constraint","prevPoint","nextPoint","cps","d0","cp0","interpolate","segs","w2","w3","unitX","unitY","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","curveTool","pointAt","tangentAt","polyHelper","roundRectHelper","shadowTemp","modified","animatingShape","pathSplitted","_animateToShallow","objShallow","propertyCount","_dragStart","_drag","_dragEnd","draggingTarget","_draggingTarget","_y","dropTarget","lastDropTarget","_dropTarget","processArc","fa","psiDeg","xp","yp","lambda","cxp","cyp","vAngle","u","vRatio","createPathProxyFromString","cs","cc","RegExp","prevCmd","cpx","cpy","ctlPtx","ctlPty","createPathOptions","pathProxy","transformPath","vMag","pathEls","pathList","pathEl","pathBundle","nPoint","mathAtan2","nameRotate","nameTruncate","nameTextStyle","nameGap","inside","splitLine","splitArea","areaStyle","categoryAxis","valueAxis","timeAxis","logAxis","logBase","axisDefault","AXIS_TYPES","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","isAxisUsedInTheGrid","getLabelUnionRect","labelCount","isLabelIgnored","singleRect","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","updateAxisTransfrom","coordBase","axisExtentSum","toLocalCoord","findAxesModels","axesTypes","isCartesian2D","Cartesian2D","Axis2D","gridProto","ifAxisCanNotOnZero","otherAxisDim","axes","axesMap","_updateScale","ignoreContainLabel","adjustAxes","axesList","gridRect","labelUnionRect","axesMapOnDim","xAxisIndex","yAxisIndex","coordList","getCartesians","_findConvertTarget","cartesian","coordsList","createAxisCreator","axisPositionUsed","axesCount","addAxis","baseAxis","otherAxis","grids","AxisPointerModel","triggerOn","shadowStyle","padding","borderColor","borderWidth","icon","AxisPonterView","disopse","illegalPoint","findPointFromSeries","isIllegalPoint","inputAxesInfo","shouldHide","outputFinder","showValueMap","dataByCoordSys","updaters","showPointer","showTooltip","coordSysContainsPoint","inputAxisInfo","findInputAxisInfo","processOnAxis","linkTriggers","tarAxisInfo","tarKey","srcAxisInfo","srcKey","srcValItem","makeMapperParam","updateModelActually","dispatchTooltipActually","dispatchHighDownActually","newValue","dontSnap","buildPayloadsBySeries","payloadBatch","snapToValue","seriesNestestValue","nestestValue","modelHelper","coordSysItem","coordSysId","coordSysIndex","coordSysType","coordSysMainType","dataByAxis","axisId","valueLabelOpt","outputAxesInfo","valItem","lastHighlights","newHighlights","toHighlight","toDownplay","assembleTransition","transitionText","vendors","vendorPrefix","assembleFont","assembleCssText","tooltipModel","transitionDuration","zrColor","borderName","camelCase","TooltipContent","_container","_show","_hideTimeout","onmouseenter","_enterable","_inContent","onmouseleave","hideLater","_hideDelay","currentStyle","setContent","setEnterable","enterable","getSize","viewportRoot","offsetLeft","offsetTop","isShow","showContent","alwaysShowContent","displayMode","confine","showDelay","hideDelay","borderRadius","buildTooltipModel","modelCascade","resultModel","refixTooltipPosition","gapH","gapV","confineTooltipPosition","calcTooltipPosition","contentSize","domWidth","domHeight","rectWidth","rectHeight","isCenterAlign","layoutUtil","axisPointerViewHelper","proxyRect","tooltipContent","_tooltipContent","_tooltipModel","_ecModel","_lastDataByCoordSys","_alwaysShowContent","_initGlobalListener","_keepShow","_tryShow","_hide","_refreshUpdateTimeout","manuallyShowTip","_ticket","_manuallyAxisShowTip","pointInfo","manuallyHideTip","_showAxisTooltip","_showSeriesItemTooltip","_showComponentItemTooltip","_showOrMove","_showTimout","singleDefaultHTML","singleParamsList","singleTooltipModel","itemCoordSys","axisValue","seriesDefaultHTML","valueLabel","axisValueLabel","firstLine","positionExpr","_updateContentNotChangedOnAxis","_updatePosition","_showTooltipContent","tooltipTrigger","defaultHtml","asyncTicket","subTooltipModel","html","cbTicket","vAlign","viewSize","layoutRect","lastCoordSys","contentNotChanged","lastItemCoordSys","indexCoordSys","lastDataByAxis","thisItemCoordSys","thisDataByAxis","lastItem","indexAxis","lastIndices","lastIdxItem","newIdxItem","axisBuilderAttrs","selfBuilderAttrs","CartesianAxisView","oldAxisGroup","_axisGroup","axisBuilder","_splitLine","splitLineModel","lineColors","lineInterval","lineCount","colorIndex","_splitArea","splitAreaModel","areaStyleModel","areaColors","prevX","prevY","areaInterval","coordExtent","dimAxisMapper","_axes","Cartesian","_dimList","getAxesByScale","_dataCoordConvert","input","dimList","output","axisX","axisY","dataToPoints","containLabel","getSeriesStackId","STACK_PREFIX","getAxisKey","getLayoutOnAxis","axisKey","stackId","widthAndOffsets","doCalBarWidthAndOffset","offsetCenter","calBarWidthAndOffset","barSeries","barWidth","barMaxWidth","barGap","barCategoryGap","seriesInfoList","columnsMap","seriesInfo","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","stacks","barGapPercent","autoWidth","column","lastColumn","widthSum","barLayoutGrid","barWidthAndOffset","lastStackCoords","lastStackCoordsOrigin","columnLayoutInfo","columnOffset","columnWidth","barMinHeight","valueAxisStart","sign","lastCoord","lastCoordOrigin","getMarkerPosition","pt","legendHoverLink","barMinAngle","setLabel","labelText","labelPositionOutside","hoverLabelModel","brushSelector","removeRect","removeSector","updateStyle","isPolar","itemStyleModel","getBarItemStyle","getLineWidth","rawLayout","BAR_BORDER_WIDTH_QUERY","BarView","coordinateSystemType","_render","isHorizontalOrRadial","oldData","elementCreator","newIndex","oldIndex","rectShape","animateProperty","animateTarget","isRadial","sector","sectorShape","fixedLineWidth","signX","signY"],"mappings":"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","file":"static/js/BarReact.af9ef152.chunk.js","sourcesContent":["webpackJsonp([4],Array(183).concat([\n/* 183 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(28);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__ = __webpack_require__(191);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_echarts_lib_component_tooltip__ = __webpack_require__(314);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_echarts_lib_component_tooltip___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_echarts_lib_component_tooltip__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_grid__ = __webpack_require__(328);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_grid___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_grid__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_echarts_lib_chart_bar__ = __webpack_require__(365);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_echarts_lib_chart_bar___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_echarts_lib_chart_bar__);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**\n * Created by yongyuehuang on 2017/8/5.\n *///\nvar BarReact=function(_React$Component){_inherits(BarReact,_React$Component);function BarReact(props){_classCallCheck(this,BarReact);var _this=_possibleConstructorReturn(this,(BarReact.__proto__||Object.getPrototypeOf(BarReact)).call(this,props));_this.initPie=_this.initPie.bind(_this);return _this;}_createClass(BarReact,[{key:'initPie',value:function initPie(){var _props$option=this.props.option,option=_props$option===undefined?{}:_props$option;//data\nvar myChart=__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default.a.init(this.ID);//echarts\n//options\nmyChart.setOption(option);window.onresize=function(){myChart.resize();};}},{key:'componentDidMount',value:function componentDidMount(){this.initPie();}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initPie();}},{key:'render',value:function render(){var _this2=this;var _props=this.props,_props$width=_props.width,width=_props$width===undefined?\"100%\":_props$width,_props$height=_props.height,height=_props$height===undefined?\"200px\":_props$height;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div',{ref:function ref(ID){return _this2.ID=ID;},style:{width:width,height:height}});}}]);return BarReact;}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);/* harmony default export */ __webpack_exports__[\"default\"] = (BarReact);\n\n/***/ }),\n/* 184 */,\n/* 185 */,\n/* 186 */,\n/* 187 */,\n/* 188 */,\n/* 189 */,\n/* 190 */\n/***/ (function(module, exports) {\n\n/**\n * @module zrender/core/util\n */\n\n\n    // mergeDate\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuiltInObject(sourceProp)\n                    && !isBuiltInObject(targetProp)\n                    && !isPrimitive(sourceProp)\n                    && !isPrimitive(targetProp)\n                ) {\n                    // merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // overwritetrue\n                    // NOTE target[key] \n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * \n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz \n     * @param {Function} baseClazz \n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * Consider typed array.\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuiltInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * Whether is exactly NaN. Notice isNaN('a') returns true.\n     * @param {*} value\n     * @return {boolean}\n     */\n    function eqNaN(value) {\n        return value !== value;\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var primitiveKey = '__ec_primitive__';\n    /**\n     * Set an object as primitive to be ignored traversing children in clone or merge\n     */\n    function setAsPrimitive(obj) {\n        obj[primitiveKey] = true;\n    }\n\n    function isPrimitive(obj) {\n        return obj[primitiveKey];\n    }\n\n    /**\n     * @constructor\n     * @param {Object} obj Only apply `ownProperty`.\n     */\n    function HashMap(obj) {\n        obj && each(obj, function (value, key) {\n            this.set(key, value);\n        }, this);\n    }\n\n    // Add prefix to avoid conflict with Object.prototype.\n    var HASH_MAP_PREFIX = '_ec_';\n    var HASH_MAP_PREFIX_LENGTH = 4;\n\n    HashMap.prototype = {\n        constructor: HashMap,\n        // Do not provide `has` method to avoid defining what is `has`.\n        // (We usually treat `null` and `undefined` as the same, different\n        // from ES6 Map).\n        get: function (key) {\n            return this[HASH_MAP_PREFIX + key];\n        },\n        set: function (key, value) {\n            this[HASH_MAP_PREFIX + key] = value;\n            // Comparing with invocation chaining, `return value` is more commonly\n            // used in this case: `var someVal = map.set('a', genVal());`\n            return value;\n        },\n        // Although util.each can be performed on this hashMap directly, user\n        // should not use the exposed keys, who are prefixed.\n        each: function (cb, context) {\n            context !== void 0 && (cb = bind(cb, context));\n            for (var prefixedKey in this) {\n                this.hasOwnProperty(prefixedKey)\n                    && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n            }\n        },\n        // Do not use this method if performance sensitive.\n        removeKey: function (key) {\n            delete this[key];\n        }\n    };\n\n    function createHashMap(obj) {\n        return new HashMap(obj);\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuiltInObject: isBuiltInObject,\n        isDom: isDom,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        assert: assert,\n        setAsPrimitive: setAsPrimitive,\n        createHashMap: createHashMap,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n/***/ }),\n/* 191 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {// Enable DEV mode when using source code without build. which has no __DEV__ variable\n// In build process 'typeof __DEV__' will be replace with 'boolean'\n// So this code will be removed or disabled anyway after built.\nif (typeof __DEV__ === 'undefined') {\n    // In browser\n    if (typeof window !== 'undefined') {\n        window.__DEV__ = true;\n    }\n    // In node\n    else if (typeof global !== 'undefined') {\n        global.__DEV__ = true;\n    }\n}\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\n/**\n * @module echarts\n */\n\n\n    var env = __webpack_require__(198);\n\n    var GlobalModel = __webpack_require__(270);\n    var ExtensionAPI = __webpack_require__(266);\n    var CoordinateSystemManager = __webpack_require__(216);\n    var OptionManager = __webpack_require__(271);\n\n    var ComponentModel = __webpack_require__(202);\n    var SeriesModel = __webpack_require__(217);\n\n    var ComponentView = __webpack_require__(256);\n    var ChartView = __webpack_require__(232);\n    var graphic = __webpack_require__(192);\n    var modelUtil = __webpack_require__(194);\n    var throttle = __webpack_require__(231);\n\n    var zrender = __webpack_require__(265);\n    var zrUtil = __webpack_require__(190);\n    var colorTool = __webpack_require__(208);\n    var Eventful = __webpack_require__(210);\n    var timsort = __webpack_require__(226);\n\n    var each = zrUtil.each;\n    var parseClassType = ComponentModel.parseClassType;\n\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\n\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    // FIXME\n    // necessary?\n    var PRIORITY_VISUAL_BRUSH = 5000;\n\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flagInMainProcess';\n    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\n    var OPTION_UPDATED = '__optionUpdated';\n    var ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts(dom, theme, opts) {\n        opts = opts || {};\n\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        var zr = this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height\n        });\n\n        /**\n         * Expect 60 pfs.\n         * @type {Function}\n         * @private\n         */\n        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = createExtensionAPI(this);\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n\n        // Init mouse events\n        this._initEvents();\n\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n\n        zr.animation.on('frame', this._onframe, this);\n\n        // ECharts instance can be used as value.\n        zrUtil.setAsPrimitive(this);\n    }\n\n    var echartsProto = ECharts.prototype;\n\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            var silent = this[OPTION_UPDATED].silent;\n\n            this[IN_MAIN_PROCESS] = true;\n\n            updateMethods.prepareAndUpdate.call(this);\n\n            this[IN_MAIN_PROCESS] = false;\n\n            this[OPTION_UPDATED] = false;\n\n            flushPendingActions.call(this, silent);\n\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n\n    /**\n     * Usage:\n     * chart.setOption(option, notMerge, lazyUpdate);\n     * chart.setOption(option, {\n     *     notMerge: ...,\n     *     lazyUpdate: ...,\n     *     silent: ...\n     * });\n     *\n     * @param {Object} option\n     * @param {Object|boolean} [opts] opts or notMerge.\n     * @param {boolean} [opts.notMerge=false]\n     * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n\n        var silent;\n        if (zrUtil.isObject(notMerge)) {\n            lazyUpdate = notMerge.lazyUpdate;\n            silent = notMerge.silent;\n            notMerge = notMerge.notMerge;\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n\n        this._model.setOption(option, optionPreprocessorFuncs);\n\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = {silent: silent};\n            this[IN_MAIN_PROCESS] = false;\n        }\n        else {\n            updateMethods.prepareAndUpdate.call(this);\n            // Ensure zr refresh sychronously, and then pixel in canvas can be\n            // fetched after `setOption`.\n            this._zr.flush();\n\n            this[OPTION_UPDATED] = false;\n            this[IN_MAIN_PROCESS] = false;\n\n            flushPendingActions.call(this, silent);\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getDevicePixelRatio = function () {\n        return this._zr.painter.dpr || window.devicePixelRatio || 1;\n    };\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     * @param {string} [opts.excludeComponents]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({\n                mainType: componentType\n            }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n\n        var url = this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n\n\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = (opts && opts.pixelRatio) || 1;\n\n            zrUtil.each(instances, function (chart, id) {\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(\n                        zrUtil.clone(opts)\n                    );\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            });\n\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                    style: {\n                        x: item.left * dpr - left,\n                        y: item.top * dpr - top,\n                        image: item.dom\n                    }\n                });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        }\n        else {\n            return this.getDataURL(opts);\n        }\n    };\n\n    /**\n     * Convert from logical coordinate system to pixel coordinate system.\n     * See CoordinateSystem#convertToPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId, geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\n    /**\n     * Convert from pixel coordinate system to logical coordinate system.\n     * See CoordinateSystem#convertFromPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\n    function doConvertPixel(methodName, finder, value) {\n        var ecModel = this._model;\n        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n            if (coordSys[methodName]\n                && (result = coordSys[methodName](ecModel, finder, value)) != null\n            ) {\n                return result;\n            }\n        }\n\n        if (__DEV__) {\n            console.warn(\n                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n            );\n        }\n    }\n\n    /**\n     * Is the specified coordinate systems or components contain the given pixel point.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {boolean} result\n     */\n    echartsProto.containPixel = function (finder, value) {\n        var ecModel = this._model;\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        zrUtil.each(finder, function (models, key) {\n            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n                var coordSys = model.coordinateSystem;\n                if (coordSys && coordSys.containPoint) {\n                    result |= !!coordSys.containPoint(value);\n                }\n                else if (key === 'seriesModels') {\n                    var view = this._chartsMap[model.__viewId];\n                    if (view && view.containPoint) {\n                        result |= view.containPoint(value, model);\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.warn(key + ': ' + (view\n                                ? 'The found component do not support containPoint.'\n                                : 'No view mapping to the found component.'\n                            ));\n                        }\n                    }\n                }\n                else {\n                    if (__DEV__) {\n                        console.warn(key + ': containPoint is not supported');\n                    }\n                }\n            }, this);\n        }, this);\n\n        return !!result;\n    };\n\n    /**\n     * Get visual from series or data.\n     * @param {string|Object} finder\n     *        If string, e.g., 'series', means {seriesIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            dataIndex / dataIndexInside\n     *        }\n     *        If dataIndex is not specified, series visual will be fetched,\n     *        but not data item visual.\n     *        If all of seriesIndex, seriesId, seriesName are not specified,\n     *        visual will be fetched from first series.\n     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n     */\n    echartsProto.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n\n        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n        var seriesModel = finder.seriesModel;\n\n        if (__DEV__) {\n            if (!seriesModel) {\n                console.warn('There is no specified seires model');\n            }\n        }\n\n        var data = seriesModel.getData();\n\n        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n            ? finder.dataIndexInside\n            : finder.hasOwnProperty('dataIndex')\n            ? data.indexOfRawIndex(finder.dataIndex)\n            : null;\n\n        return dataIndexInside != null\n            ? data.getItemVisual(dataIndexInside, visualType)\n            : data.getVisual(visualType);\n    };\n\n    /**\n     * Get view of corresponding component model\n     * @param  {module:echarts/model/Component} componentModel\n     * @return {module:echarts/view/Component}\n     */\n    echartsProto.getViewOfComponentModel = function (componentModel) {\n        return this._componentsMap[componentModel.__viewId];\n    };\n\n    /**\n     * Get view of corresponding series model\n     * @param  {module:echarts/model/Series} seriesModel\n     * @return {module:echarts/view/Chart}\n     */\n    echartsProto.getViewOfSeriesModel = function (seriesModel) {\n        return this._chartsMap[seriesModel.__viewId];\n    };\n\n\n    var updateMethods = {\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        update: function (payload) {\n            // console.profile && console.profile('update');\n\n            var ecModel = this._model;\n            var api = this._api;\n            var coordSysMgr = this._coordSysMgr;\n            var zr = this._zr;\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            // Fixme First time update ?\n            ecModel.restoreData();\n\n            // TODO\n            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n            // Create new coordinate system each update\n            // In LineView may save the old coordinate system and use it to get the orignal point\n            coordSysMgr.create(this._model, this._api);\n\n            processData.call(this, ecModel, api);\n\n            stackSeriesData.call(this, ecModel);\n\n            coordSysMgr.update(ecModel, api);\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            doRender.call(this, ecModel, payload);\n\n            // Set background\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n            var painter = zr.painter;\n            // TODO all use clearColor ?\n            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n            }\n            else {\n                // In IE8\n                if (!env.canvasSupported) {\n                    var colorArr = colorTool.parse(backgroundColor);\n                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                    if (colorArr[3] === 0) {\n                        backgroundColor = 'transparent';\n                    }\n                }\n                if (backgroundColor.colorStops || backgroundColor.image) {\n                    // Gradient background\n                    // FIXME Fixed layer\n                    zr.configLayer(0, {\n                        clearColor: backgroundColor\n                    });\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                    this._dom.style.background = 'transparent';\n                }\n                else {\n                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                        zr.configLayer(0, {\n                            clearColor: null\n                        });\n                    }\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                    this._dom.style.background = backgroundColor;\n                }\n            }\n\n            each(postUpdateFuncs, function (func) {\n                func(ecModel, api);\n            });\n\n            // console.profile && console.profileEnd('update');\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateView: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateVisual: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload, true);\n\n            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateLayout: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            doLayout.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        prepareAndUpdate: function (payload) {\n            var ecModel = this._model;\n\n            prepareView.call(this, 'component', ecModel);\n\n            prepareView.call(this, 'chart', ecModel);\n\n            updateMethods.update.call(this, payload);\n        }\n    };\n\n    /**\n     * @private\n     */\n    function updateDirectly(ecIns, method, payload, mainType, subType) {\n        var ecModel = ecIns._model;\n\n        // broadcast\n        if (!mainType) {\n            each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);\n            return;\n        }\n\n        var query = {};\n        query[mainType + 'Id'] = payload[mainType + 'Id'];\n        query[mainType + 'Index'] = payload[mainType + 'Index'];\n        query[mainType + 'Name'] = payload[mainType + 'Name'];\n\n        var condition = {mainType: mainType, query: query};\n        subType && (condition.subType = subType); // subType may be '' by parseClassType;\n\n        // If dispatchAction before setOption, do nothing.\n        ecModel && ecModel.eachComponent(condition, function (model, index) {\n            callView(ecIns[\n                mainType === 'series' ? '_chartsMap' : '_componentsMap'\n            ][model.__viewId]);\n        }, ecIns);\n\n        function callView(view) {\n            view && view.__alive && view[method] && view[method](\n                view.__model, ecModel, ecIns._api, payload\n            );\n        }\n    }\n\n    /**\n     * Resize the chart\n     * @param {Object} opts\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @param {boolean} [opts.silent=false]\n     */\n    echartsProto.resize = function (opts) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        this._zr.resize(opts);\n\n        var optionChanged = this._model && this._model.resetOption('media');\n        var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n\n        updateMethods[updateMethod].call(this);\n\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n\n        this[IN_MAIN_PROCESS] = false;\n\n        var silent = opts && opts.silent;\n\n        flushPendingActions.call(this, silent);\n\n        triggerUpdatedEvent.call(this, silent);\n    };\n\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (__DEV__) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n\n        zr.add(el);\n    };\n\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n     * @param {boolean} [opt.silent=false] Whether trigger events.\n     * @param {boolean} [opt.flush=undefined]\n     *                  true: Flush immediately, and then pixel in canvas can be fetched\n     *                      immediately. Caution: it might affect performance.\n     *                  false: Not not flush.\n     *                  undefined: Auto decide whether perform flush.\n     */\n    echartsProto.dispatchAction = function (payload, opt) {\n        if (!zrUtil.isObject(opt)) {\n            opt = {silent: !!opt};\n        }\n\n        if (!actions[payload.type]) {\n            return;\n        }\n\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n\n        doDispatchAction.call(this, payload, opt.silent);\n\n        if (opt.flush) {\n            this._zr.flush(true);\n        }\n        else if (opt.flush !== false && env.browser.weChat) {\n            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n            // hang when sliding page (on touch event), which cause that zr does not\n            // refresh util user interaction finished, which is not expected.\n            // But `dispatchAction` may be called too frequently when pan on touch\n            // screen, which impacts performance if do not throttle them.\n            this._throttledZrFlush();\n        }\n\n        flushPendingActions.call(this, opt.silent);\n\n        triggerUpdatedEvent.call(this, opt.silent);\n    };\n\n    function doDispatchAction(payload, silent) {\n        var payloadType = payload.type;\n        var escapeConnect = payload.escapeConnect;\n        var actionWrap = actions[payloadType];\n        var actionInfo = actionWrap.actionInfo;\n\n        var cptType = (actionInfo.update || 'update').split(':');\n        var updateMethod = cptType.pop();\n        cptType = cptType[0] != null && parseClassType(cptType[0]);\n\n        this[IN_MAIN_PROCESS] = true;\n\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n\n        each(payloads, function (batchItem) {\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model, this._api);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            // light update does not perform data process, layout and visual.\n            if (isHighDown) {\n                // method, payload, mainType, subType\n                updateDirectly(this, updateMethod, batchItem, 'series');\n            }\n            else if (cptType) {\n                updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n            }\n        }, this);\n\n        if (updateMethod !== 'none' && !isHighDown && !cptType) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            }\n            else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payloadType,\n                escapeConnect: escapeConnect,\n                batch: eventObjBatch\n            };\n        }\n        else {\n            eventObj = eventObjBatch[0];\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n    }\n\n    function flushPendingActions(silent) {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            doDispatchAction.call(this, payload, silent);\n        }\n    }\n\n    function triggerUpdatedEvent(silent) {\n        !silent && this.trigger('updated');\n    }\n\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, component);\n        }, this);\n\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n\n            updateZ(seriesModel, chart);\n\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Post render\n        each(postUpdateFuncs, function (func) {\n            func(ecModel, api);\n        });\n    }\n\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            }\n            else {\n                model = componentType;\n            }\n\n            // Consider: id same and type changed.\n            var viewId = '_ec_' + model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = parseClassType(model.type);\n                var Clazz = isComponent\n                    ? ComponentView.getClass(classType.main, classType.sub)\n                    : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                }\n                else {\n                    // Error\n                    return;\n                }\n            }\n\n            model.__viewId = view.__id = viewId;\n            view.__alive = true;\n            view.__model = model;\n            view.group.__ecComponentInfo = {\n                mainType: model.mainType,\n                index: model.componentIndex\n            };\n        }, this);\n\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n                view.__id = view.group.__ecComponentInfo = null;\n            }\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                // Avoid conflict with Object.prototype\n                if (stackedDataMap.hasOwnProperty(stack) && previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @param {object} layout\n     * @param {boolean} [excludesLayout]\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload, excludesLayout) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            (!excludesLayout || !visual.isLayout)\n                && visual.func(ecModel, api, payload);\n        });\n    }\n\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, componentView);\n        }, this);\n\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n\n            chartView.group.silent = !!seriesModel.get('silent');\n\n            updateZ(seriesModel, chartView);\n\n            updateProgressiveAndBlend(seriesModel, chartView);\n\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n\n    var MOUSE_EVENT_NAMES = [\n        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n    ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                var params;\n\n                // no e.target when 'globalout'.\n                if (eveName === 'globalout') {\n                    params = {};\n                }\n                else if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                }\n                // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    params = zrUtil.extend({}, el.eventData);\n                }\n\n                if (params) {\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }\n\n            }, this);\n        }, this);\n\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (__DEV__) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n\n        var api = this._api;\n        var ecModel = this._model;\n\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n\n        // Dispose after all views disposed\n        this._zr.dispose();\n\n        delete instances[this.id];\n    };\n\n    zrUtil.mixin(ECharts, Eventful);\n\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ?\n                        Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (__DEV__) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n\n    function createExtensionAPI(ecInstance) {\n        var coordSysMgr = ecInstance._coordSysMgr;\n        return zrUtil.extend(new ExtensionAPI(ecInstance), {\n            // Inject methods\n            getCoordinateSystems: zrUtil.bind(\n                coordSysMgr.getCoordinateSystems, coordSysMgr\n            ),\n            getComponentByElement: function (el) {\n                while (el) {\n                    var modelInfo = el.__ecComponentInfo;\n                    if (modelInfo != null) {\n                        return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);\n                    }\n                    el = el.parent;\n                }\n            }\n        });\n    }\n\n    /**\n     * @type {Object} key: actionType.\n     * @inner\n     */\n    var actions = {};\n\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var postUpdateFuncs = [];\n\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n\n\n    var instances = {};\n    var connectedGroups = {};\n\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n        /**\n         * @type {number}\n         */\n        version: '3.6.2',\n        dependencies: {\n            zrender: '3.5.2'\n        }\n    };\n\n    function enableConnect(chart) {\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    if (event && event.escapeConnect) {\n                        return;\n                    }\n\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n\n                    zrUtil.each(instances, function (otherChart) {\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    });\n\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n    }\n\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n     *                              Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n     *                               Can be 'auto' (the same as null/undefined)\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (__DEV__) {\n            // Check version\n            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n                throw new Error(\n                    'ZRender ' + zrender.version\n                    + ' is too old for ECharts ' + echarts.version\n                    + '. Current version need ZRender '\n                    + echarts.dependencies.zrender + '+'\n                );\n            }\n\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n        }\n\n        var existInstance = echarts.getInstanceByDom(dom);\n        if (existInstance) {\n            if (__DEV__) {\n                console.warn('There is a chart instance already initialized on the dom.');\n            }\n            return existInstance;\n        }\n\n        if (__DEV__) {\n            if (zrUtil.isDom(dom)\n                && dom.nodeName.toUpperCase() !== 'CANVAS'\n                && (\n                    (!dom.clientWidth && (!opts || opts.width == null))\n                    || (!dom.clientHeight && (!opts || opts.height == null))\n                )\n            ) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n\n        if (dom.setAttribute) {\n            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n        }\n        else {\n            dom[DOM_ATTRIBUTE_KEY] = chart.id;\n        }\n\n        enableConnect(chart);\n\n        return chart;\n    };\n\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || ('g_' + groupIdBase++);\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n\n    /**\n     * @DEPRECATED\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n\n    /**\n     * @return {string} groupId\n     */\n    echarts.disconnect = echarts.disConnect;\n\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        else if (!(chart instanceof ECharts)){\n            // Try to treat as dom\n            chart = echarts.getInstanceByDom(chart);\n        }\n        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key;\n        if (dom.getAttribute) {\n            key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        }\n        else {\n            key = dom[DOM_ATTRIBUTE_KEY];\n        }\n        return instances[key];\n    };\n\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n\n    /**\n     * Register postUpdater\n     * @param {Function} postUpdateFunc\n     */\n    echarts.registerPostUpdate = function (postUpdateFunc) {\n        postUpdateFuncs.push(postUpdateFunc);\n    };\n\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo)\n            ? actionInfo.type\n            : ([actionInfo, actionInfo = {\n                event: eventName\n            }][0]);\n\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n\n        // Validate action type and event name.\n        zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n        if (!actions[actionType]) {\n            actions[actionType] = {action: action, actionInfo: actionInfo};\n        }\n        eventActionMap[eventName] = actionType;\n    };\n\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n\n    /**\n     * Get dimensions of specified coordinate system.\n     * @param {string} type\n     * @return {Array.<string|Object>}\n     */\n    echarts.getCoordinateSystemDimensions = function (type) {\n        var coordSysCreator = CoordinateSystemManager.get(type);\n        if (coordSysCreator) {\n            return coordSysCreator.getDimensionsInfo\n                    ? coordSysCreator.getDimensionsInfo()\n                    : coordSysCreator.dimensions.slice();\n        }\n    };\n\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts/*, superClass*/) {\n        // var Clazz = ComponentModel;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts/*, superClass*/) {\n        // var Clazz = ComponentView;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentView.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts/*, superClass*/) {\n        // var Clazz = SeriesModel;\n        // if (superClass) {\n        //     superClass = 'series.' + superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return SeriesModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts/*, superClass*/) {\n        // var Clazz = ChartView;\n        // if (superClass) {\n        //     superClass = superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ChartView.getClass(classType.main, true);\n        // }\n        return ChartView.extend(opts);\n    };\n\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, __webpack_require__(283));\n    echarts.registerPreprocessor(__webpack_require__(278));\n    echarts.registerLoading('default', __webpack_require__(269));\n\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n\n\n    // --------\n    // Exports\n    // --------\n    echarts.zrender = zrender;\n\n    echarts.List = __webpack_require__(211);\n    echarts.Model = __webpack_require__(199);\n\n    echarts.Axis = __webpack_require__(227);\n\n    echarts.graphic = __webpack_require__(192);\n    echarts.number = __webpack_require__(193);\n    echarts.format = __webpack_require__(197);\n    echarts.throttle = throttle.throttle;\n    echarts.matrix = __webpack_require__(204);\n    echarts.vector = __webpack_require__(195);\n    echarts.color = __webpack_require__(208);\n\n    echarts.util = {};\n    each([\n            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n            'extend', 'defaults', 'clone', 'merge'\n        ],\n        function (name) {\n            echarts.util[name] = zrUtil[name];\n        }\n    );\n\n    echarts.helper = __webpack_require__(268);\n\n\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n\n    module.exports = echarts;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(80)))\n\n/***/ }),\n/* 192 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var pathTool = __webpack_require__(312);\n    var Path = __webpack_require__(196);\n    var colorTool = __webpack_require__(208);\n    var matrix = __webpack_require__(204);\n    var vector = __webpack_require__(195);\n    var Transformable = __webpack_require__(236);\n    var BoundingRect = __webpack_require__(200);\n\n    var round = Math.round;\n    var mathMax = Math.max;\n    var mathMin = Math.min;\n\n    var graphic = {};\n\n    graphic.Group = __webpack_require__(215);\n\n    graphic.Image = __webpack_require__(235);\n\n    graphic.Text = __webpack_require__(263);\n\n    graphic.Circle = __webpack_require__(303);\n\n    graphic.Sector = __webpack_require__(309);\n\n    graphic.Ring = __webpack_require__(308);\n\n    graphic.Polygon = __webpack_require__(305);\n\n    graphic.Polyline = __webpack_require__(306);\n\n    graphic.Rect = __webpack_require__(307);\n\n    graphic.Line = __webpack_require__(304);\n\n    graphic.BezierCurve = __webpack_require__(302);\n\n    graphic.Arc = __webpack_require__(301);\n\n    graphic.CompoundPath = __webpack_require__(296);\n\n    graphic.LinearGradient = __webpack_require__(262);\n\n    graphic.RadialGradient = __webpack_require__(297);\n\n    graphic.BoundingRect = BoundingRect;\n\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                }\n                else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n\n            graphic.resizePath(path, rect);\n        }\n        return path;\n    };\n\n    graphic.mergePath = pathTool.mergePath,\n\n    /**\n     * Resize a path to fit the rect\n     * @param {module:zrender/graphic/Path} path\n     * @param {Object} rect\n     */\n    graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n\n        var pathRect = path.getBoundingRect();\n\n        var m = pathRect.calculateTransform(rect);\n\n        path.applyTransform(m);\n    };\n\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n            originWidth === 0 ? 0 : 1\n        );\n        shape.height = Math.max(\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n            originHeight === 0 ? 0 : 1\n        );\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill\n                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke\n                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n\n            el.__normalStl = normalStyle;\n\n            el.__hoverStlDirty = false;\n        }\n    }\n\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n\n        cacheElementStl(el);\n\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        }\n        else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n\n        el.__isHover = true;\n    }\n\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        }\n        else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n\n        el.__isHover = false;\n    }\n\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleEnterHover(child);\n                }\n            })\n            : doSingleEnterHover(el);\n    }\n\n    function doLeaveHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleLeaveHover(child);\n                }\n            })\n            : doSingleLeaveHover(el);\n    }\n\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOver(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOut(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n\n    /**\n     * Set hover style of element.\n     * This method can be called repeatly without side-effects.\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     * @param {Object} [opt]\n     * @param {boolean} [opt.hoverSilentOnTouch=false]\n     *        In touch device, mouseover event will be trigger on touchstart event\n     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n     *        conviniently use hoverStyle when tap on touch screen without additional\n     *        code for compatibility.\n     *        But if the chart/component has select feature, which usually also use\n     *        hoverStyle, there might be conflict between 'select-highlight' and\n     *        'hover-highlight' especially when roam is enabled (see geo for example).\n     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n     *        on touch device.\n     */\n    graphic.setHoverStyle = function (el, hoverStyle, opt) {\n        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    setElementHoverStl(child, hoverStyle);\n                }\n            })\n            : setElementHoverStl(el, hoverStyle);\n\n        // Duplicated function will be auto-ignored, see Eventful.js.\n        el.on('mouseover', onElementMouseOver)\n          .on('mouseout', onElementMouseOut);\n\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis)\n          .on('normal', leaveEmphasis);\n    };\n\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelOffset = labelModel.getShallow('offset');\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textOffset: labelOffset,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n\n    graphic.getFont = function (opt, ecModel) {\n        var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n        return [\n            // FIXME in node-canvas fontWeight is before fontStyle\n            opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '',\n            opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '',\n            (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px',\n            opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'\n        ].join(' ');\n    };\n\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        // Do not check 'animation' property directly here. Consider this case:\n        // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n        // but its parent model (`seriesModel`) does.\n        var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(\n                    dataIndex,\n                    animatableModel.getAnimationDelayParams\n                        ? animatableModel.getAnimationDelayParams(el, dataIndex)\n                        : null\n                );\n            }\n            if (typeof duration === 'function') {\n                duration = duration(dataIndex);\n            }\n\n            duration > 0\n                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n                : (el.stopAnimation(), el.attr(props), cb && cb());\n        }\n        else {\n            el.stopAnimation();\n            el.attr(props);\n            cb && cb();\n        }\n    }\n\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n\n        return mat;\n    };\n\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} target [x, y]\n     * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:\n     *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n     *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (target, transform, invert) {\n        if (transform && !zrUtil.isArrayLike(transform)) {\n            transform = Transformable.getLocalTransform(transform);\n        }\n\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], target, transform);\n    };\n\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n        var vertex = [\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n        ];\n\n        vertex = graphic.applyTransform(vertex, transform, invert);\n\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n            ? (vertex[0] > 0 ? 'right' : 'left')\n            : (vertex[1] > 0 ? 'bottom' : 'top');\n    };\n\n    /**\n     * Apply group transition animation from g1 to g2.\n     * If no animatableModel, no animation.\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                position: vector.clone(el.position),\n                rotation: el.rotation\n            };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }\n                // else {\n                //     if (el.previousProps) {\n                //         graphic.updateProps\n                //     }\n                // }\n            }\n        });\n    };\n\n    /**\n     * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]\n     * @param {Object} rect {x, y, width, height}\n     * @return {Array.<Array.<number>>} A new clipped points.\n     */\n    graphic.clipPointsByRect = function (points, rect) {\n        return zrUtil.map(points, function (point) {\n            var x = point[0];\n            x = mathMax(x, rect.x);\n            x = mathMin(x, rect.x + rect.width);\n            var y = point[1];\n            y = mathMax(y, rect.y);\n            y = mathMin(y, rect.y + rect.height);\n            return [x, y];\n        });\n    };\n\n    /**\n     * @param {Object} targetRect {x, y, width, height}\n     * @param {Object} rect {x, y, width, height}\n     * @return {Object} A new clipped rect. If rect size are negative, return undefined.\n     */\n    graphic.clipRectByRect = function (targetRect, rect) {\n        var x = mathMax(targetRect.x, rect.x);\n        var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n        var y = mathMax(targetRect.y, rect.y);\n        var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);\n\n        if (x2 >= x && y2 >= y) {\n            return {\n                x: x,\n                y: y,\n                width: x2 - x,\n                height: y2 - y\n            };\n        }\n    };\n\n    module.exports = graphic;\n\n\n\n/***/ }),\n/* 193 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module echarts/util/number\n */\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var number = {};\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n\n        if (subDomain === 0) {\n            return subRange === 0\n                ? range[0]\n                : (range[0] + range[1]) / 2;\n        }\n\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                }\n                else if (val >= domain[1]) {\n                    return range[1];\n                }\n            }\n            else {\n                if (val >= domain[0]) {\n                    return range[0];\n                }\n                else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        }\n        else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function(percent, all) {\n        switch (percent) {\n            case 'center':\n            case 'middle':\n                percent = '50%';\n                break;\n            case 'left':\n            case 'top':\n                percent = '0%';\n                break;\n            case 'right':\n            case 'bottom':\n                percent = '100%';\n                break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n\n            return parseFloat(percent);\n        }\n\n        return percent == null ? NaN : +percent;\n    };\n\n    /**\n     * (1) Fix rounding error of float numbers.\n     * (2) Support return string to avoid scientific notation like '3.5e-7'.\n     *\n     * @param {number} x\n     * @param {number} [precision]\n     * @param {boolean} [returnStr]\n     * @return {number|string}\n     */\n    number.round = function (x, precision, returnStr) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // Avoid range error\n        precision = Math.min(Math.max(0, precision), 20);\n        x = (+x).toFixed(precision);\n        return returnStr ? x : +x;\n    };\n\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n\n    /**\n     * @param {string|number} val\n     * @return {number}\n     */\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n\n        // Consider scientific notation: '3.4e-12' '3.4e+12'\n        var eIndex = str.indexOf('e');\n        if (eIndex > 0) {\n            var precision = +str.slice(eIndex + 1);\n            return precision < 0 ? -precision : 0;\n        }\n        else {\n            var dotIndex = str.indexOf('.');\n            return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n        }\n    };\n\n    /**\n     * Minimal dicernible data precisioin according to a single pixel.\n     *\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number} precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        // toFixed() digits argument must be between 0 and 20.\n        var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n        return !isFinite(precision) ? 20 : precision;\n    };\n\n    /**\n     * Get a data of given precision, assuring the sum of percentages\n     * in valueList is 1.\n     * The largest remainer method is used.\n     * https://en.wikipedia.org/wiki/Largest_remainder_method\n     *\n     * @param {Array.<number>} valueList a list of all data\n     * @param {number} idx index of the data to be processed in valueList\n     * @param {number} precision integer number showing digits of precision\n     * @return {number} percent ranging from 0 to 100\n     */\n    number.getPercentWithPrecision = function (valueList, idx, precision) {\n        if (!valueList[idx]) {\n            return 0;\n        }\n\n        var sum = zrUtil.reduce(valueList, function (acc, val) {\n            return acc + (isNaN(val) ? 0 : val);\n        }, 0);\n        if (sum === 0) {\n            return 0;\n        }\n\n        var digits = Math.pow(10, precision);\n        var votesPerQuota = zrUtil.map(valueList, function (val) {\n            return (isNaN(val) ? 0 : val) / sum * digits * 100;\n        });\n        var targetSeats = digits * 100;\n\n        var seats = zrUtil.map(votesPerQuota, function (votes) {\n            // Assign automatic seats.\n            return Math.floor(votes);\n        });\n        var currentSum = zrUtil.reduce(seats, function (acc, val) {\n            return acc + val;\n        }, 0);\n\n        var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {\n            return votes - seats[idx];\n        });\n\n        // Has remainding votes.\n        while (currentSum < targetSeats) {\n            // Find next largest remainder.\n            var max = Number.NEGATIVE_INFINITY;\n            var maxId = null;\n            for (var i = 0, len = remainder.length; i < len; ++i) {\n                if (remainder[i] > max) {\n                    max = remainder[i];\n                    maxId = i;\n                }\n            }\n\n            // Add a vote to max remainder.\n            ++seats[maxId];\n            remainder[maxId] = 0;\n            ++currentSum;\n        }\n\n        return seats[idx] / digits;\n    };\n\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n\n    var TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d\\d)(?::(\\d\\d)(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line\n\n    /**\n     * @return {number} in minutes\n     */\n    number.getTimezoneOffset = function () {\n        return (new Date()).getTimezoneOffset();\n    };\n\n    /**\n     * @param {string|Date|number} value These values can be accepted:\n     *   + An instance of Date, represent a time in its own time zone.\n     *   + Or string in a subset of ISO 8601, only including:\n     *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',\n     *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',\n     *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',\n     *     all of which will be treated as local time if time zone is not specified\n     *     (see <https://momentjs.com/>).\n     *   + Or other string format, including (all of which will be treated as loacal time):\n     *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',\n     *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'\n     *   + a timestamp, which represent a time in UTC.\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            // Different browsers parse date in different way, so we parse it manually.\n            // Some other issues:\n            // new Date('1970-01-01') is UTC,\n            // new Date('1970/01/01') and new Date('1970-1-01') is local.\n            // See issue #3623\n            var match = TIME_REG.exec(value);\n\n            if (!match) {\n                // return Invalid Date.\n                return new Date(NaN);\n            }\n\n            var timezoneOffset = number.getTimezoneOffset();\n            var timeOffset = !match[8]\n                ? 0\n                : match[8].toUpperCase() === 'Z'\n                ? timezoneOffset\n                : +match[8].slice(0, 3) * 60 + timezoneOffset;\n\n            // match[n] can only be string or undefined.\n            // But take care of '12' + 1 => '121'.\n            return new Date(\n                +match[1],\n                +(match[2] || 1) - 1,\n                +match[3] || 1,\n                +match[4] || 0,\n                +(match[5] || 0) - timeOffset,\n                +match[6] || 0,\n                +match[7] || 0\n            );\n        }\n        else if (value == null) {\n            return new Date(NaN);\n        }\n\n        return new Date(Math.round(value));\n    };\n\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     *\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, quantityExponent(val));\n    };\n\n    function quantityExponent(val) {\n        return Math.floor(Math.log(val) / Math.LN10);\n    }\n\n    /**\n     * find a nice number approximately equal to x. Round the number if round = true,\n     * take ceiling if round = false. The primary observation is that the nicest\n     * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     *\n     * See \"Nice Numbers for Graph Labels\" of Graphic Gems.\n     *\n     * @param  {number} val Non-negative value.\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exponent = quantityExponent(val);\n        var exp10 = Math.pow(10, exponent);\n        var f = val / exp10; // 1 <= f < 10\n        var nf;\n        if (round) {\n            if (f < 1.5) { nf = 1; }\n            else if (f < 2.5) { nf = 2; }\n            else if (f < 4) { nf = 3; }\n            else if (f < 7) { nf = 5; }\n            else { nf = 10; }\n        }\n        else {\n            if (f < 1) { nf = 1; }\n            else if (f < 2) { nf = 2; }\n            else if (f < 3) { nf = 3; }\n            else if (f < 5) { nf = 5; }\n            else { nf = 10; }\n        }\n        val = nf * exp10;\n\n        // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).\n        // 20 is the uppper bound of toFixed.\n        return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n    };\n\n    /**\n     * Order intervals asc, and split them when overlap.\n     * expect(numberUtil.reformIntervals([\n     *     {interval: [18, 62], close: [1, 1]},\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [1, 1]},\n     *     {interval: [62, 150], close: [1, 1]},\n     *     {interval: [106, 150], close: [1, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ])).toEqual([\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [0, 1]},\n     *     {interval: [18, 62], close: [0, 1]},\n     *     {interval: [62, 150], close: [0, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ]);\n     * @param {Array.<Object>} list, where `close` mean open or close\n     *        of the interval, and Infinity can be used.\n     * @return {Array.<Object>} The origin list, which has been reformed.\n     */\n    number.reformIntervals = function (list) {\n        list.sort(function (a, b) {\n            return littleThan(a, b, 0) ? -1 : 1;\n        });\n\n        var curr = -Infinity;\n        var currClose = 1;\n        for (var i = 0; i < list.length;) {\n            var interval = list[i].interval;\n            var close = list[i].close;\n\n            for (var lg = 0; lg < 2; lg++) {\n                if (interval[lg] <= curr) {\n                    interval[lg] = curr;\n                    close[lg] = !lg ? 1 - currClose : 1;\n                }\n                curr = interval[lg];\n                currClose = close[lg];\n            }\n\n            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n                list.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n\n        return list;\n\n        function littleThan(a, b, lg) {\n            return a.interval[lg] < b.interval[lg]\n                || (\n                    a.interval[lg] === b.interval[lg]\n                    && (\n                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n                        || (!lg && littleThan(a, b, 1))\n                    )\n                );\n        }\n    };\n\n    /**\n     * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n     * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n     * subtraction forces infinities to NaN\n     *\n     * @param {*} v\n     * @return {boolean}\n     */\n    number.isNumeric = function (v) {\n        return v - parseFloat(v) >= 0;\n    };\n\n    module.exports = number;\n\n\n/***/ }),\n/* 194 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var formatUtil = __webpack_require__(197);\n    var nubmerUtil = __webpack_require__(193);\n    var Model = __webpack_require__(199);\n    var zrUtil = __webpack_require__(190);\n    var each = zrUtil.each;\n    var isObject = zrUtil.isObject;\n\n    var modelUtil = {};\n\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array\n            ? value\n            : value == null\n            ? []\n            : [value];\n    };\n\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n     modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n\n            // Default emphasis option from normal\n            each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n\n    modelUtil.LABEL_OPTIONS = ['position', 'offset', 'show', 'textStyle', 'distance', 'formatter'];\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return isObject(dataItem)\n            && !(dataItem instanceof Array);\n            // // markLine data can be array\n            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n\n        if (dimType === 'time'\n            // spead up when using timestamp\n            && typeof value !== 'number'\n            && value != null\n            && value !== '-'\n        ) {\n            value = +nubmerUtil.parseDate(value);\n        }\n\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return (value == null || value === '')\n            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n    };\n\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        /**\n         * Get params for formatter\n         * @param {number} dataIndex\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n            var color = data.getItemVisual(dataIndex, 'color');\n\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: this.seriesIndex,\n                seriesId: this.id,\n                seriesName: this.name,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: color,\n                marker: formatUtil.getTooltipMarker(color),\n\n                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n                $vars: ['seriesName', 'name', 'value']\n            };\n        },\n\n        /**\n         * Format label\n         * @param {number} dataIndex\n         * @param {string} [status='normal'] 'normal' or 'emphasis'\n         * @param {string} [dataType]\n         * @param {number} [dimIndex]\n         * @param {string} [labelProp='label']\n         * @return {string}\n         */\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && (params.value instanceof Array)) {\n                params.value = params.value[dimIndex];\n            }\n\n            var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);\n\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            }\n            else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n\n        /**\n         * Get raw value in option\n         * @param {number} idx\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return (isObject(dataItem) && !(dataItem instanceof Array))\n                    ? dataItem.value : dataItem;\n            }\n        },\n\n        /**\n         * Should be implemented.\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         * @return {string} tooltip string\n         */\n        formatTooltip: zrUtil.noop\n    };\n\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          index of which is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n\n        var result = zrUtil.map(exists || [], function (obj, index) {\n            return {exist: obj};\n        });\n\n        // Mapping by id or name if specified.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option // Consider name: two map to one.\n                    && cptOption.id != null\n                    && result[i].exist.id === cptOption.id + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option // Consider name: two map to one.\n                    // Can not match when both ids exist but different.\n                    && (exist.id == null || cptOption.id == null)\n                    && cptOption.name != null\n                    && !modelUtil.isIdInner(cptOption)\n                    && !modelUtil.isIdInner(exist)\n                    && exist.name === cptOption.name + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n\n        // Otherwise mapping by index.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option\n                    // Existing model that already has id should be able to\n                    // mapped to (because after mapping performed model may\n                    // be assigned with a id, whish should not affect next\n                    // mapping), except those has inner id.\n                    && !modelUtil.isIdInner(exist)\n                    // Caution:\n                    // Do not overwrite id. But name can be overwritten,\n                    // because axis use name as 'show label text'.\n                    // 'exist' always has id and name and we dont\n                    // need to check it.\n                    && cptOption.id == null\n                ) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n\n            if (i >= result.length) {\n                result.push({option: cptOption});\n            }\n        });\n\n        return result;\n    };\n\n    /**\n     * Make id and name for mapping result (result of mappingToExists)\n     * into `keyInfo` field.\n     *\n     * @public\n     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     * @return {Array.<Object>} The input.\n     */\n    modelUtil.makeIdAndName = function (mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n\n        // Ensure that each id is distinct.\n        var idMap = zrUtil.createHashMap();\n\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && idMap.set(existCpt.id, item);\n        });\n\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n\n            zrUtil.assert(\n                !opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item,\n                'id duplicates: ' + (opt && opt.id)\n            );\n\n            opt && opt.id != null && idMap.set(opt.id, item);\n            !item.keyInfo && (item.keyInfo = {});\n        });\n\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n\n            if (!isObject(opt)) {\n                return;\n            }\n\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null\n                ? opt.name + ''\n                : existCpt\n                ? existCpt.name\n                : '\\0-'; // name may be displayed on screen, so use '-'.\n\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            }\n            else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            }\n            else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n                }\n                while (idMap.get(keyInfo.id));\n            }\n\n            idMap.set(keyInfo.id, item);\n        });\n    };\n\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return isObject(cptOption)\n            && cptOption.id\n            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n    };\n\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n\n        return [mapToArray(mapA), mapToArray(mapB)];\n\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    }\n                    else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    }\n                    else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                    }\n                }\n            }\n            return result;\n        }\n    };\n\n    /**\n     * @param {module:echarts/data/List} data\n     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n     *                         each of which can be Array or primary type.\n     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n     */\n    modelUtil.queryDataIndex = function (data, payload) {\n        if (payload.dataIndexInside != null) {\n            return payload.dataIndexInside;\n        }\n        else if (payload.dataIndex != null) {\n            return zrUtil.isArray(payload.dataIndex)\n                ? zrUtil.map(payload.dataIndex, function (value) {\n                    return data.indexOfRawIndex(value);\n                })\n                : data.indexOfRawIndex(payload.dataIndex);\n        }\n        else if (payload.name != null) {\n            return zrUtil.isArray(payload.name)\n                ? zrUtil.map(payload.name, function (value) {\n                    return data.indexOfName(value);\n                })\n                : data.indexOfName(payload.name);\n        }\n    };\n\n    /**\n     * Enable property storage to any host object.\n     * Notice: Serialization is not supported.\n     *\n     * For example:\n     * var get = modelUitl.makeGetter();\n     *\n     * function some(hostObj) {\n     *      get(hostObj)._someProperty = 1212;\n     *      ...\n     * }\n     *\n     * @return {Function}\n     */\n    modelUtil.makeGetter = (function () {\n        var index = 0;\n        return function () {\n            var key = '\\0__ec_prop_getter_' + index++;\n            return function (hostObj) {\n                return hostObj[key] || (hostObj[key] = {});\n            };\n        };\n    })();\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex, seriesId, seriesName,\n     *            geoIndex, geoId, geoName,\n     *            bmapIndex, bmapId, bmapName,\n     *            xAxisIndex, xAxisId, xAxisName,\n     *            yAxisIndex, yAxisId, yAxisName,\n     *            gridIndex, gridId, gridName,\n     *            ... (can be extended)\n     *        }\n     *        Each properties can be number|string|Array.<number>|Array.<string>\n     *        For example, a finder could be\n     *        {\n     *            seriesIndex: 3,\n     *            geoId: ['aa', 'cc'],\n     *            gridName: ['xx', 'rr']\n     *        }\n     *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)\n     *        If nothing or null/undefined specified, return nothing.\n     * @param {Object} [opt]\n     * @param {string} [opt.defaultMainType]\n     * @param {Array.<string>} [opt.includeMainTypes]\n     * @return {Object} result like:\n     *        {\n     *            seriesModels: [seriesModel1, seriesModel2],\n     *            seriesModel: seriesModel1, // The first model\n     *            geoModels: [geoModel1, geoModel2],\n     *            geoModel: geoModel1, // The first model\n     *            ...\n     *        }\n     */\n    modelUtil.parseFinder = function (ecModel, finder, opt) {\n        if (zrUtil.isString(finder)) {\n            var obj = {};\n            obj[finder + 'Index'] = 0;\n            finder = obj;\n        }\n\n        var defaultMainType = opt && opt.defaultMainType;\n        if (defaultMainType\n            && !has(finder, defaultMainType + 'Index')\n            && !has(finder, defaultMainType + 'Id')\n            && !has(finder, defaultMainType + 'Name')\n        ) {\n            finder[defaultMainType + 'Index'] = 0;\n        }\n\n        var result = {};\n\n        each(finder, function (value, key) {\n            var value = finder[key];\n\n            // Exclude 'dataIndex' and other illgal keys.\n            if (key === 'dataIndex' || key === 'dataIndexInside') {\n                result[key] = value;\n                return;\n            }\n\n            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n            var mainType = parsedKey[1];\n            var queryType = (parsedKey[2] || '').toLowerCase();\n\n            if (!mainType\n                || !queryType\n                || value == null\n                || (queryType === 'index' && value === 'none')\n                || (opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0)\n            ) {\n                return;\n            }\n\n            var queryParam = {mainType: mainType};\n            if (queryType !== 'index' || value !== 'all') {\n                queryParam[queryType] = value;\n            }\n\n            var models = ecModel.queryComponents(queryParam);\n            result[mainType + 'Models'] = models;\n            result[mainType + 'Model'] = models[0];\n        });\n\n        return result;\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string|number} dataDim\n     * @return {string}\n     */\n    modelUtil.dataDimToCoordDim = function (data, dataDim) {\n        var dimensions = data.dimensions;\n        dataDim = data.getDimension(dataDim);\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimItem = data.getDimensionInfo(dimensions[i]);\n            if (dimItem.name === dataDim) {\n                return dimItem.coordDim;\n            }\n        }\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string} coordDim\n     * @return {Array.<string>} data dimensions on the coordDim.\n     */\n    modelUtil.coordDimToDataDim = function (data, coordDim) {\n        var dataDim = [];\n        each(data.dimensions, function (dimName) {\n            var dimItem = data.getDimensionInfo(dimName);\n            if (dimItem.coordDim === coordDim) {\n                dataDim[dimItem.coordDimIndex] = dimItem.name;\n            }\n        });\n        return dataDim;\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string} otherDim Can be `otherDims`\n     *                        like 'label' or 'tooltip'.\n     * @return {Array.<string>} data dimensions on the otherDim.\n     */\n    modelUtil.otherDimToDataDim = function (data, otherDim) {\n        var dataDim = [];\n        each(data.dimensions, function (dimName) {\n            var dimItem = data.getDimensionInfo(dimName);\n            var otherDims = dimItem.otherDims;\n            var dimIndex = otherDims[otherDim];\n            if (dimIndex != null && dimIndex !== false) {\n                dataDim[dimIndex] = dimItem.name;\n            }\n        });\n        return dataDim;\n    };\n\n    function has(obj, prop) {\n        return obj && obj.hasOwnProperty(prop);\n    }\n\n    module.exports = modelUtil;\n\n\n\n/***/ }),\n/* 195 */\n/***/ (function(module, exports) {\n\n\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * \n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * \n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} \n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n/***/ }),\n/* 196 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = __webpack_require__(223);\n    var zrUtil = __webpack_require__(190);\n    var PathProxy = __webpack_require__(212);\n    var pathContain = __webpack_require__(293);\n\n    var Pattern = __webpack_require__(245);\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    var pathProxyForDraw = new PathProxy(true);\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = null;\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path || pathProxyForDraw;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect;\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath\n                || (lineDash && !ctxLineDash && hasStroke)\n            ) {\n                path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                if (this.path) {\n                    this.__dirtyPath = false;\n                }\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        createPathProxy: function () {\n            this.path = new PathProxy();\n        },\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (!path) {\n                    // Create path on demand.\n                    path = this.path = new PathProxy();\n                }\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     *  Path element, \n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME  extend position, rotation \n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n/***/ }),\n/* 197 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var numberUtil = __webpack_require__(193);\n    var textContain = __webpack_require__(206);\n\n    var formatUtil = {};\n\n    /**\n     * ,\n     * @param {string|number} x\n     * @return {string}\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n               + (x.length > 1 ? ('.' + x[1]) : '');\n    };\n\n    /**\n     * @param {string} str\n     * @param {boolean} [upperCaseFirst=false]\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str, upperCaseFirst) {\n        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n            return group1.toUpperCase();\n        });\n\n        if (upperCaseFirst && str) {\n            str = str.charAt(0).toUpperCase() + str.slice(1);\n        }\n\n        return str;\n    };\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        else if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    };\n\n    var encodeHTML = formatUtil.encodeHTML = function (source) {\n        return String(source)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    };\n\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    /**\n     * Template formatter\n     * @param {string} tpl\n     * @param {Array.<Object>|Object} paramsList\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList, encode) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            var val = wrapVar(alias, 0);\n            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                var val = paramsList[seriesIdx][$vars[k]];\n                tpl = tpl.replace(\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                    encode ? encodeHTML(val) : val\n                );\n            }\n        }\n\n        return tpl;\n    };\n\n    /**\n     * simple Template formatter\n     *\n     * @param {string} tpl\n     * @param {Object} param\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTplSimple = function (tpl, param, encode) {\n        zrUtil.each(param, function (value, key) {\n            tpl = tpl.replace(\n                '{' + key + '}',\n                encode ? encodeHTML(value) : value\n            );\n        });\n        return tpl;\n    };\n\n    /**\n     * @param {string} color\n     * @param {string} [extraCssText]\n     * @return {string}\n     */\n    formatUtil.getTooltipMarker = function (color, extraCssText) {\n        return color\n            ? '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:'\n                + formatUtil.encodeHTML(color) + ';' + (extraCssText || '') + '\"></span>'\n            : '';\n    };\n\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? ('0' + str) : str;\n    };\n\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @param {boolean} [isUTC=false] Default in local time.\n     *           see `module:echarts/scale/Time`\n     *           and `module:echarts/util/number#parseDate`.\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value, isUTC) {\n        if (tpl === 'week'\n            || tpl === 'month'\n            || tpl === 'quarter'\n            || tpl === 'half-year'\n            || tpl === 'year'\n        ) {\n            tpl = 'MM-dd\\nyyyy';\n        }\n\n        var date = numberUtil.parseDate(value);\n        var utc = isUTC ? 'UTC' : '';\n        var y = date['get' + utc + 'FullYear']();\n        var M = date['get' + utc + 'Month']() + 1;\n        var d = date['get' + utc + 'Date']();\n        var h = date['get' + utc + 'Hours']();\n        var m = date['get' + utc + 'Minutes']();\n        var s = date['get' + utc + 'Seconds']();\n\n        tpl = tpl.replace('MM', s2d(M))\n            .toLowerCase()\n            .replace('yyyy', y)\n            .replace('yy', y % 100)\n            .replace('dd', s2d(d))\n            .replace('d', d)\n            .replace('hh', s2d(h))\n            .replace('h', h)\n            .replace('mm', s2d(m))\n            .replace('m', m)\n            .replace('ss', s2d(s))\n            .replace('s', s);\n\n        return tpl;\n    };\n\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n\n    formatUtil.truncateText = textContain.truncateText;\n\n    module.exports = formatUtil;\n\n\n\n/***/ }),\n/* 198 */\n/***/ (function(module, exports) {\n\n/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // canvas\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n                // events currently. So we dont use that on other browsers unless tested sufficiently.\n                // Although IE 10 supports pointer event, it use old style and is different from the\n                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n                && (browser.edge || (browser.ie && browser.version >= 11))\n        };\n    }\n\n\n/***/ }),\n/* 199 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module echarts/model/Model\n */\n\n\n    var zrUtil = __webpack_require__(190);\n    var clazzUtil = __webpack_require__(201);\n    var env = __webpack_require__(198);\n\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;\n\n        // Simple optimization\n        // if (this.init) {\n        //     if (arguments.length <= 4) {\n        //         this.init(option, parentModel, ecModel, extraOpt);\n        //     }\n        //     else {\n        //         this.init.apply(this, arguments);\n        //     }\n        // }\n    }\n\n    Model.prototype = {\n\n        constructor: Model,\n\n        /**\n         * Model \n         * @param {Object} option\n         */\n        init: null,\n\n        /**\n         *  Option merge\n         */\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        get: function (path, ignoreParent) {\n            if (path == null) {\n                return this.option;\n            }\n\n            return doGet(\n                this.option,\n                this.parsePath(path),\n                !ignoreParent && getParent(this, path)\n            );\n        },\n\n        /**\n         * @param {string} key\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n\n            var val = option == null ? option : option[key];\n            var parentModel = !ignoreParent && getParent(this, key);\n            if (val == null && parentModel) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n\n        /**\n         * @param {string|Array.<string>} [path]\n         * @param {module:echarts/model/Model} [parentModel]\n         * @return {module:echarts/model/Model}\n         */\n        getModel: function (path, parentModel) {\n            var obj = path == null\n                ? this.option\n                : doGet(this.option, path = this.parsePath(path));\n\n            var thisParentModel;\n            parentModel = parentModel || (\n                (thisParentModel = getParent(this, path))\n                    && thisParentModel.getModel(path)\n            );\n\n            return new Model(obj, parentModel, this.ecModel);\n        },\n\n        /**\n         * If model has option\n         */\n        isEmpty: function () {\n            return this.option == null;\n        },\n\n        restoreData: function () {},\n\n        // Pending\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        },\n\n        // If path is null/undefined, return null/undefined.\n        parsePath: function(path) {\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            return path;\n        },\n\n        /**\n         * @param {Function} getParentMethod\n         *        param {Array.<string>|string} path\n         *        return {module:echarts/model/Model}\n         */\n        customizeGetParent: function (getParentMethod) {\n            clazzUtil.set(this, 'getParent', getParentMethod);\n        },\n\n        isAnimationEnabled: function () {\n            if (!env.node) {\n                if (this.option.animation != null) {\n                    return !!this.option.animation;\n                }\n                else if (this.parentModel) {\n                    return this.parentModel.isAnimationEnabled();\n                }\n            }\n        }\n    };\n\n    function doGet(obj, pathArr, parentModel) {\n        for (var i = 0; i < pathArr.length; i++) {\n            // Ignore empty\n            if (!pathArr[i]) {\n                continue;\n            }\n            // obj could be number/string/... (like 0)\n            obj = (obj && typeof obj === 'object') ? obj[pathArr[i]] : null;\n            if (obj == null) {\n                break;\n            }\n        }\n        if (obj == null && parentModel) {\n            obj = parentModel.get(pathArr);\n        }\n        return obj;\n    }\n\n    // `path` can be null/undefined\n    function getParent(model, path) {\n        var getParentMethod = clazzUtil.get(model, 'getParent');\n        return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n    }\n\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n\n    var mixin = zrUtil.mixin;\n    mixin(Model, __webpack_require__(276));\n    mixin(Model, __webpack_require__(273));\n    mixin(Model, __webpack_require__(277));\n    mixin(Model, __webpack_require__(275));\n\n    module.exports = Model;\n\n\n/***/ }),\n/* 200 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = __webpack_require__(195);\n    var matrix = __webpack_require__(204);\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // \n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n\n/***/ }),\n/* 201 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var clazz = {};\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    var MEMBER_PRIFIX = '\\0ec_\\0';\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name] = value;` (can be right-value)\n     * @public\n     */\n    clazz.set = function (host, name, value) {\n        return (host[MEMBER_PRIFIX + name] = value);\n    };\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name];`\n     * @public\n     */\n    clazz.get = function (host, name) {\n        return host[MEMBER_PRIFIX + name];\n    };\n\n    /**\n     * For hidden private class member.\n     * The same behavior as `host.hasOwnProperty(name);`\n     * @public\n     */\n    clazz.hasOwn = function (host, name) {\n        return host.hasOwnProperty(MEMBER_PRIFIX + name);\n    };\n\n    /**\n     * Notice, parseClassType('') should returns {main: '', sub: ''}\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n        var ret = {main: '', sub: ''};\n        if (componentType) {\n            componentType = componentType.split(TYPE_DELIMITER);\n            ret.main = componentType[0] || '';\n            ret.sub = componentType[1] || '';\n        }\n        return ret;\n    };\n\n    /**\n     * @public\n     */\n    function checkClassType(componentType) {\n        zrUtil.assert(\n            /^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType),\n            'componentType \"' + componentType + '\" illegal'\n        );\n    }\n\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n\n            if (__DEV__) {\n                zrUtil.each(mandatoryMethods, function (method) {\n                    if (!proto[method]) {\n                        console.warn(\n                            'Method `' + method + '` should be implemented'\n                            + (proto.type ? ' in ' + proto.type : '') + '.'\n                        );\n                    }\n                });\n            }\n\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                }\n                else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n\n            zrUtil.extend(ExtendedClass.prototype, proto);\n\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n\n            return ExtendedClass;\n        };\n    };\n\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                checkClassType(componentType);\n                componentType = parseClassType(componentType);\n\n                if (!componentType.sub) {\n                    if (__DEV__) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                }\n                else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n\n        entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n            var Clazz = storage[componentMainType];\n\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error(\n                    !subType\n                        ? componentMainType + '.' + 'type should be specified.'\n                        : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.'\n                );\n            }\n\n            return Clazz;\n        };\n\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n\n            var result = [];\n            var obj = storage[componentType.main];\n\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            }\n            else {\n                result.push(obj);\n            }\n\n            return result;\n        };\n\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n\n        entity.parseClassType = parseClassType;\n\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n\n        return entity;\n    };\n\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n        // FIXME It seems broken in IE8 simulation of IE11\n        // if (!zrUtil.isArray(properties)) {\n        //     properties = properties != null ? [properties] : [];\n        // }\n        // zrUtil.each(properties, function (prop) {\n        //     var value = obj[prop];\n\n        //     Object.defineProperty\n        //         && Object.defineProperty(obj, prop, {\n        //             value: value, writable: false\n        //         });\n        //     zrUtil.isArray(obj[prop])\n        //         && Object.freeze\n        //         && Object.freeze(obj[prop]);\n        // });\n    };\n\n    module.exports = clazz;\n\n\n/***/ }),\n/* 202 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\n\n    var Model = __webpack_require__(199);\n    var zrUtil = __webpack_require__(190);\n    var arrayPush = Array.prototype.push;\n    var componentUtil = __webpack_require__(225);\n    var clazzUtil = __webpack_require__(201);\n    var layout = __webpack_require__(203);\n\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n\n        type: 'component',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        id: '',\n\n        /**\n         * @readOnly\n         */\n        name: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        mainType: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        subType: '',\n\n        /**\n         * @readOnly\n         * @type {number}\n         */\n        componentIndex: 0,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        ecModel: null,\n\n        /**\n         * key: componentType\n         * value:  Component model list, can not be null.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @readOnly\n         */\n        dependentModels: [],\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        uid: null,\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        $constructor: function (option, parentModel, ecModel, extraOpt) {\n            Model.call(this, option, parentModel, ecModel, extraOpt);\n\n            this.uid = componentUtil.getUID('componentModel');\n        },\n\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n            this.mergeDefaultAndTheme(option, ecModel);\n        },\n\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            var themeModel = ecModel.getTheme();\n            zrUtil.merge(option, themeModel.get(this.mainType));\n            zrUtil.merge(option, this.getDefaultOption());\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (option, extraOpt) {\n            zrUtil.merge(this.option, option, true);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, option, layoutMode);\n            }\n        },\n\n        // Hooker after init or mergeOption\n        optionUpdated: function (newCptOption, isInit) {},\n\n        getDefaultOption: function () {\n            if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n                var optList = [];\n                var Class = this.constructor;\n                while (Class) {\n                    var opt = Class.prototype.defaultOption;\n                    opt && optList.push(opt);\n                    Class = Class.superClass;\n                }\n\n                var defaultOption = {};\n                for (var i = optList.length - 1; i >= 0; i--) {\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                }\n                clazzUtil.set(this, '__defaultOption', defaultOption);\n            }\n            return clazzUtil.get(this, '__defaultOption');\n        },\n\n        getReferringComponents: function (mainType) {\n            return this.ecModel.queryComponents({\n                mainType: mainType,\n                index: this.get(mainType + 'Index', true),\n                id: this.get(mainType + 'Id', true)\n            });\n        }\n\n    });\n\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n\n    //         this.uid = componentUtil.getUID('componentModel');\n\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(\n        ComponentModel, {registerWhenExtend: true}\n    );\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n\n    zrUtil.mixin(ComponentModel, __webpack_require__(274));\n\n    module.exports = ComponentModel;\n\n\n/***/ }),\n/* 203 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Layout helpers for each component positioning\n\n\n    var zrUtil = __webpack_require__(190);\n    var BoundingRect = __webpack_require__(200);\n    var numberUtil = __webpack_require__(193);\n    var formatUtil = __webpack_require__(197);\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n\n    var layout = {};\n\n    /**\n     * @public\n     */\n    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [\n        'left', 'right', 'top', 'bottom', 'width', 'height'\n    ];\n\n    /**\n     * @public\n     */\n    var HV_NAMES = layout.HV_NAMES = [\n        ['width', 'left', 'right'],\n        ['height', 'top', 'bottom']\n    ];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            }\n            else {\n                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n\n            if (child.newline) {\n                return;\n            }\n\n            position[0] = x;\n            position[1] = y;\n\n            orient === 'horizontal'\n                ? (x = nextX + gap)\n                : (y = nextY + gap);\n        });\n    }\n\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (\n        positionInfo, containerRect, margin\n    ) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            }\n            else {\n                height = containerHeight * 0.8;\n            }\n        }\n\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n            case 'center':\n                left = containerWidth / 2 - width / 2 - margin[3];\n                break;\n            case 'right':\n                left = containerWidth - width - horizontalMargin;\n                break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n            case 'middle':\n            case 'center':\n                top = containerHeight / 2 - height / 2 - margin[0];\n                break;\n            case 'bottom':\n                top = containerHeight - height - verticalMargin;\n                break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n\n\n    /**\n     * Position a zr element in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * Logic:\n     *     1. Scale (against origin point in parent coord)\n     *     2. Rotate (against origin point in parent coord)\n     *     3. Traslate (with el.position by this method)\n     * So this method only fixes the last step 'Traslate', which does not affect\n     * scaling and rotating.\n     *\n     * If be called repeatly with the same input el, the same result will be gotten.\n     *\n     * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @param {Object} [opt]\n     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n     * @param {Array.<number>} [opt.boundingMode='all']\n     *        Specify how to calculate boundingRect when locating.\n     *        'all': Position the boundingRect that is transformed and uioned\n     *               both itself and its descendants.\n     *               This mode simplies confine the elements in the bounding\n     *               of their container (e.g., using 'right: 0').\n     *        'raw': Position the boundingRect that is not transformed and only itself.\n     *               This mode is useful when you want a element can overflow its\n     *               container. (Consider a rotated circle needs to be located in a corner.)\n     *               In this mode positionInfo.width/height can only be number.\n     */\n    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\n        var h = !opt || !opt.hv || opt.hv[0];\n        var v = !opt || !opt.hv || opt.hv[1];\n        var boundingMode = opt && opt.boundingMode || 'all';\n\n        if (!h && !v) {\n            return;\n        }\n\n        var rect;\n        if (boundingMode === 'raw') {\n            rect = el.type === 'group'\n                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n                : el.getBoundingRect();\n        }\n        else {\n            rect = el.getBoundingRect();\n            if (el.needLocalTransform()) {\n                var transform = el.getLocalTransform();\n                // Notice: raw rect may be inner object of el,\n                // which should not be modified.\n                rect = rect.clone();\n                rect.applyTransform(transform);\n            }\n        }\n\n        positionInfo = layout.getLayoutRect(\n            zrUtil.defaults(\n                {width: rect.width, height: rect.height},\n                positionInfo\n            ),\n            containerRect,\n            margin\n        );\n\n        // Because 'tranlate' is the last step in transform\n        // (see zrender/core/Transformable#getLocalTransfrom),\n        // we can just only modify el.position to get final result.\n        var elPos = el.position;\n        var dx = h ? positionInfo.x - rect.x : 0;\n        var dy = v ? positionInfo.y - rect.y : 0;\n\n        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n    };\n\n    /**\n     * @param {Object} option Contains some of the properties in HV_NAMES.\n     * @param {number} hvIdx 0: horizontal; 1: vertical.\n     */\n    layout.sizeCalculable = function (option, hvIdx) {\n        return option[HV_NAMES[hvIdx][0]] != null\n            || (option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null);\n    };\n\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n\n        var ignoreSize = opt.ignoreSize;\n        !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n\n        var hResult = merge(HV_NAMES[0], 0);\n        var vResult = merge(HV_NAMES[1], 1);\n\n        copy(HV_NAMES[0], targetOption, hResult);\n        copy(HV_NAMES[1], targetOption, vResult);\n\n        function merge(names, hvIdx) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = 2;\n\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n\n            if (ignoreSize[hvIdx]) {\n                // Only one of left/right is premitted to exist.\n                if (hasValue(newOption, names[1])) {\n                    merged[names[2]] = null;\n                }\n                else if (hasValue(newOption, names[2])) {\n                    merged[names[1]] = null;\n                }\n                return merged;\n            }\n\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }\n            // Case: newOption: {width: ..., right: ...},\n            // Than we can make sure user only want those two, and ignore\n            // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            }\n            else {\n                // Chose another param from targetOption by priority.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n\n    module.exports = layout;\n\n\n\n/***/ }),\n/* 204 */\n/***/ (function(module, exports) {\n\n\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * \n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n/***/ }),\n/* 205 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var OrdinalScale = __webpack_require__(281);\n    var IntervalScale = __webpack_require__(222);\n    __webpack_require__(282);\n    __webpack_require__(280);\n    var Scale = __webpack_require__(213);\n\n    var numberUtil = __webpack_require__(193);\n    var zrUtil = __webpack_require__(190);\n    var textContain = __webpack_require__(206);\n    var axisHelper = {};\n\n    /**\n     * Get axis scale extent before niced.\n     * Item of returned array can only be number (including Infinity and NaN).\n     */\n    axisHelper.getScaleExtent = function (scale, model) {\n        var scaleType = scale.type;\n\n        var min = model.getMin();\n        var max = model.getMax();\n        var fixMin = min != null;\n        var fixMax = max != null;\n        var originalExtent = scale.getExtent();\n\n        var axisDataLen;\n        var boundaryGap;\n        var span;\n        if (scaleType === 'ordinal') {\n            axisDataLen = (model.get('data') || []).length;\n        }\n        else {\n            boundaryGap = model.get('boundaryGap');\n            if (!zrUtil.isArray(boundaryGap)) {\n                boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n            }\n            if (typeof boundaryGap[0] === 'boolean') {\n                if (__DEV__) {\n                    console.warn('Boolean type for boundaryGap is only '\n                        + 'allowed for ordinal axis. Please use string in '\n                        + 'percentage instead, e.g., \"20%\". Currently, '\n                        + 'boundaryGap is set to be 0.');\n                }\n                boundaryGap = [0, 0];\n            }\n            boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n            span = (originalExtent[1] - originalExtent[0])\n                || Math.abs(originalExtent[0]);\n        }\n\n        // Notice: When min/max is not set (that is, when there are null/undefined,\n        // which is the most common case), these cases should be ensured:\n        // (1) For 'ordinal', show all axis.data.\n        // (2) For others:\n        //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n        //      disabled).\n        //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n        //      be the result that originalExtent enlarged by boundaryGap.\n        // (3) If no data, it should be ensured that `scale.setBlank` is set.\n\n        // FIXME\n        // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n        // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n        // that the results processed by boundaryGap are positive/negative?\n\n        if (min == null) {\n            min = scaleType === 'ordinal'\n                ? (axisDataLen ? 0 : NaN)\n                : originalExtent[0] - boundaryGap[0] * span;\n        }\n        if (max == null) {\n            max = scaleType === 'ordinal'\n                ? (axisDataLen ? axisDataLen - 1 : NaN)\n                : originalExtent[1] + boundaryGap[1] * span;\n        }\n\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n\n        (min == null || !isFinite(min)) && (min = NaN);\n        (max == null || !isFinite(max)) && (max = NaN);\n\n        scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max));\n\n        // Evaluate if axis needs cross zero\n        if (model.getNeedCrossZero()) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n\n        return [min, max];\n    };\n\n    axisHelper.niceScaleExtent = function (scale, model) {\n        var extent = axisHelper.getScaleExtent(scale, model);\n        var fixMin = model.getMin() != null;\n        var fixMax = model.getMax() != null;\n        var splitNumber = model.get('splitNumber');\n\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent({\n            splitNumber: splitNumber,\n            fixMin: fixMin,\n            fixMax: fixMax,\n            minInterval: scale.type === 'interval' ? model.get('minInterval') : null\n        });\n\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function(model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n                // Buildin scale\n                case 'category':\n                    return new OrdinalScale(\n                        model.getCategories(), [Infinity, -Infinity]\n                    );\n                case 'value':\n                    return new IntervalScale();\n                // Extended scale, like time and log\n                default:\n                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n    };\n\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // axislabelhorizontalvertical.\n\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(\n                labels[i], font, 'center', 'top'\n            );\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }\n            // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            }\n            else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = (function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val != null ? val : '');\n                };\n            })(labelFormatter);\n            // Consider empty array\n            return zrUtil.map(labels, labelFormatter);\n        }\n        else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(\n                    axisHelper.getAxisRawValue(axis, tick),\n                    idx\n                );\n            }, this);\n        }\n        else {\n            return labels;\n        }\n    };\n\n    axisHelper.getAxisRawValue = function (axis, value) {\n        // In category axis with data zoom, tick is not the original\n        // index of axis.data. So tick should not be exposed to user\n        // in category axis.\n        return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n    };\n\n    module.exports = axisHelper;\n\n\n/***/ }),\n/* 206 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = __webpack_require__(190);\n    var BoundingRect = __webpack_require__(200);\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText  Canvas \n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME \n        var lineHeight = getTextWidth('', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var lineHeight = textRect.lineHeight;\n        var halfHeight = height / 2 - textHeight / 2 + lineHeight;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight - lineHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance + lineHeight;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance + lineHeight;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance + lineHeight;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance + lineHeight;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'alphabetic'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n\n/***/ }),\n/* 207 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = __webpack_require__(195);\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // \n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} \n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] \n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out \n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n/***/ }),\n/* 208 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module zrender/tool/color\n */\n\n\n    var LRU = __webpack_require__(243);\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    function setRgba(out, r, g, b, a) {\n        out[0] = r; out[1] = g; out[2] = b; out[3] = a;\n        return out;\n    }\n    function copyRgba(out, a) {\n        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n        return out;\n    }\n    var colorCache = new LRU(20);\n    var lastRemovedArr = null;\n    function putToCache(colorStr, rgbaArr) {\n        // Reuse removed array\n        if (lastRemovedArr) {\n            copyRgba(lastRemovedArr, rgbaArr);\n        }\n        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n    }\n    /**\n     * @param {string} colorStr\n     * @param {Array.<number>} out\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr, rgbaArr) {\n        if (!colorStr) {\n            return;\n        }\n        rgbaArr = rgbaArr || [];\n\n        var cached = colorCache.get(colorStr);\n        if (cached) {\n            return copyRgba(rgbaArr, cached);\n        }\n\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            copyRgba(rgbaArr, kCSSColorTable[str]);\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    setRgba(rgbaArr,\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    );\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsla':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsl':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                default:\n                    return;\n            }\n        }\n\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla, rgba) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        rgba = rgba || [];\n        setRgba(rgba,\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),\n            1\n        );\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array.\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>} will be null/undefined if input illegal.\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        out = out || [];\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssFloat(lerp(leftColor[3], rightColor[3], dv));\n\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<number>} arrColor like [12,33,44,0.4]\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color. (If input illegal, return undefined).\n     */\n    function stringify(arrColor, type) {\n        if (!arrColor || !arrColor.length) {\n            return;\n        }\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n/***/ }),\n/* 209 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = __webpack_require__(210);\n    var env = __webpack_require__(198);\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * domtouch.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * preventDefault and stopPropagation.\n     * Notice: do not do that in zrender. Upper application\n     * do that if necessary.\n     *\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // \n        Dispatcher: Eventful\n    };\n\n\n\n/***/ }),\n/* 210 */\n/***/ (function(module, exports) {\n\n/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * \n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * trigger\n         *\n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} [handler] \n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * \n         *\n         * @param {string} type \n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * context, context\n         * @param {string} type \n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    //  onxxxx \n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n/***/ }),\n/* 211 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array;\n\n    var dataCtors = {\n        'float': Float64Array,\n        'int': Int32Array,\n        // Ordinal data type can be string or int\n        'ordinal': Array,\n        'number': Array,\n        'time': Array\n    };\n\n    var Model = __webpack_require__(199);\n    var DataDiffer = __webpack_require__(252);\n\n    var zrUtil = __webpack_require__(190);\n    var modelUtil = __webpack_require__(194);\n    var isObject = zrUtil.isObject;\n\n    var TRANSFERABLE_PROPERTIES = [\n        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n    ];\n\n    function transferProperties(a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n\n        a.__wrappedMethods = b.__wrappedMethods;\n    }\n\n    function DefaultDataProvider(dataArray) {\n        this._array = dataArray || [];\n    }\n\n    DefaultDataProvider.prototype.pure = false;\n\n    DefaultDataProvider.prototype.count = function () {\n        return this._array.length;\n    };\n    DefaultDataProvider.prototype.getItem = function (idx) {\n        return this._array[idx];\n    };\n\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string|Object>} dimensions\n     *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n     *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n\n        dimensions = dimensions || ['x', 'y'];\n\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    coordDim: dimensionName,\n                    coordDimIndex: 0,\n                    stackable: false,\n                    // Type can be 'float', 'int', 'number'\n                    // Default is number, Precision of float may not enough\n                    type: 'number'\n                };\n            }\n            else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n                if (!dimensionInfo.coordDim) {\n                    dimensionInfo.coordDim = dimensionName;\n                    dimensionInfo.coordDimIndex = 0;\n                }\n            }\n            dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n\n    var listProto = List.prototype;\n\n    listProto.type = 'list';\n\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n\n        var isDataArray = zrUtil.isArray(data);\n        if (isDataArray) {\n            data = new DefaultDataProvider(data);\n        }\n        if (__DEV__) {\n            if (!isDataArray && (typeof data.getItem != 'function' || typeof data.count != 'function')) {\n                throw new Error('Inavlid data provider.');\n            }\n        }\n\n        this._rawData = data;\n\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n\n        var dimensions = this.dimensions;\n        var dimensionInfoMap = this._dimensionInfos;\n\n        var size = data.count();\n\n        var idList = [];\n        var nameRepeatCount = {};\n        var nameDimIdx;\n\n        nameList = nameList || [];\n\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(\n                (value instanceof Array)\n                    ? value[dimIndex]\n                    // If value is a single number or something else not array.\n                    : value,\n                dimensionInfoMap[dimName]\n            );\n        };\n\n        for (var i = 0; i < size; i++) {\n            // NOTICE: Try not to write things into dataItem\n            var dataItem = data.getItem(i);\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[i] = dimValueGetter(dataItem, dim, i, k);\n            }\n\n            indices.push(i);\n        }\n\n        // Use the name in option and create id\n        for (var i = 0; i < size; i++) {\n            var dataItem = data.getItem(i);\n            if (!nameList[i] && dataItem) {\n                if (dataItem.name != null) {\n                    nameList[i] = dataItem.name;\n                }\n                else if (nameDimIdx != null) {\n                    nameList[i] = storage[dimensions[nameDimIdx]][i];\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = dataItem && dataItem.id;\n\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n\n        // If value not exists\n        if (dataIndex == null || !storage[dim]) {\n            return NaN;\n        }\n\n        var value = storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n                        || (value <= 0 && stackedValue < 0) // Negative stack\n                    ) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n\n        return values;\n    };\n\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (\n                // Ordinal type can be string or number\n                dimensionInfos[dimensions[i]].type !== 'ordinal'\n                && isNaN(this.get(dimensions[i], idx))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     * @param {Function} filter\n     */\n    listProto.getDataExtent = function (dim, stack, filter) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = (dimInfo && dimInfo.stackable) && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                if (!filter || filter(value, dim, i)) {\n                    value < min && (min = value);\n                    value > max && (max = value);\n                }\n            }\n            return (this._extent[dim + !!stack] = [min, max]);\n        }\n        else {\n            return [Infinity, -Infinity];\n        }\n    };\n\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n\n        // If rawIndex === dataIndex\n        var rawDataIndex = indices[rawIndex];\n        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n            return rawIndex;\n        }\n\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            }\n            else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {Array.<number>} Considere multiple points has the same value.\n     */\n    listProto.indicesOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var nearestIndices = [];\n\n        if (!dimData) {\n            return nearestIndices;\n        }\n\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n\n        var minDist = Number.MAX_VALUE;\n        var minDiff = -1;\n        for (var i = 0, len = this.count(); i < len; i++) {\n            var diff = value - this.get(dim, i, stack);\n            var dist = Math.abs(diff);\n            if (diff <= maxDistance && dist <= minDist) {\n                // For the case of two data are same on xAxis, which has sequence data.\n                // Show the nearest index\n                // https://github.com/ecomfe/echarts/issues/2869\n                if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                    minDist = dist;\n                    minDiff = diff;\n                    nearestIndices.length = 0;\n                }\n                nearestIndices.push(i);\n            }\n        }\n        return nearestIndices;\n    };\n\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData.getItem(this.getRawIndex(idx));\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n    };\n\n\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n                case 0:\n                    cb.call(context, i);\n                    break;\n                case 1:\n                    cb.call(context, this.get(dims[0], i, stack), i);\n                    break;\n                case 2:\n                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                    break;\n                default:\n                    for (var k = 0; k < dimSize; k++) {\n                        value[k] = this.get(dims[k], i, stack);\n                    }\n                    // Index\n                    value[k] = i;\n                    cb.apply(context, value);\n            }\n        }\n    };\n\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (!dimSize) {\n                keep = cb.call(context, i);\n            }\n            else if (dimSize === 1) {\n                keep = cb.call(\n                    context, this.get(dimensions[0], i, stack), i\n                );\n            }\n            else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n\n        this.indices = newIndices;\n\n        // Reset data extent\n        this._extent = {};\n\n        return this;\n    };\n\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(\n            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n            original.hostModel\n        );\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(\n                    originalStorage[dim].length\n                );\n            }\n            else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n\n        var storage = list._storage;\n\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n\n        return list;\n    };\n\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n\n        return list;\n    };\n\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);\n    };\n\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        var val;\n        // Use prefix to avoid index to be the same as otherIdList[idx],\n        // which will cause weird udpate animation.\n        var prefix = 'e\\0\\0';\n\n        return new DataDiffer(\n            otherList ? otherList.indices : [],\n            this.indices,\n            function (idx) {\n                return (val = otherIdList[idx]) != null ? val : prefix + idx;\n            },\n            function (idx) {\n                return (val = idList[idx]) != null ? val : prefix + idx;\n            }\n        );\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge\n            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n            : layout;\n    };\n\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} [ignoreParent=false]\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n\n        this._graphicEls[idx] = el;\n    };\n\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n\n        // FIXME\n        list._storage = this._storage;\n\n        transferProperties(list, this);\n\n\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n\n        return list;\n    };\n\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\n    module.exports = List;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(80)))\n\n/***/ }),\n/* 212 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = __webpack_require__(207);\n    var vec2 = __webpack_require__(195);\n    var bbox = __webpack_require__(257);\n    var BoundingRect = __webpack_require__(200);\n    var dpr = __webpack_require__(214).devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    // var CMD_MEM_SIZE = {\n    //     M: 3,\n    //     L: 3,\n    //     C: 7,\n    //     Q: 5,\n    //     A: 9,\n    //     R: 5,\n    //     Z: 1\n    // };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function (notSaveData) {\n\n        this._saveData = !(notSaveData || false);\n\n        if (this._saveData) {\n            /**\n             * Path data. Stored as flat array\n             * @type {Array.<Object>}\n             */\n            this.data = [];\n        }\n\n        this._ctx = null;\n    };\n\n    /**\n     * Path\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _xi: 0,\n        _yi: 0,\n\n        _x0: 0,\n        _y0: 0,\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        _ux: 0,\n        _uy: 0,\n\n        _len: 0,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            if (this._saveData) {\n                this._len = 0;\n            }\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi  _dashedXXXXTo \n            // xi, yi , x0, y0  closePath \n            //  beginPath  lineTo x0, y0 \n            //  lineTo dashed line  IE10- \n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._yi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context  rebuildPath  fill\n         * stroke \n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         *  Path \n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * \n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         *  Path \n         * \n         */\n        addData: function (cmd) {\n            if (!this._saveData) {\n                return;\n            }\n\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                //  Float32Array\n                // \n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         *  Float32Array \n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo  subpath, \n                        //  closePath \n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc \n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc \n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n/***/ }),\n/* 213 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n\n    var clazzUtil = __webpack_require__(201);\n\n    /**\n     * @param {Object} [setting]\n     */\n    function Scale(setting) {\n        this._setting = setting || {};\n\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [Infinity, -Infinity];\n\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n\n        this.init && this.init.apply(this, arguments);\n    }\n\n    var scaleProto = Scale.prototype;\n\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n\n    scaleProto.getSetting = function (name) {\n        return this._setting[name];\n    };\n\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        // not setExtent because in log axis it may transformed to power\n        // this.setExtent(extent[0], extent[1]);\n    };\n\n    /**\n     * Set extent from data\n     * @param {module:echarts/data/List} data\n     * @param {string} dim\n     */\n    scaleProto.unionExtentFromData = function (data, dim) {\n        this.unionExtent(data.getDataExtent(dim, true));\n    };\n\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.isBlank = function () {\n        return this._isBlank;\n    },\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.setBlank = function (isBlank) {\n        this._isBlank = isBlank;\n    };\n\n\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, {\n        registerWhenExtend: true\n    });\n\n    module.exports = Scale;\n\n\n/***/ }),\n/* 214 */\n/***/ (function(module, exports) {\n\n\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config\n     * @exports zrender/config\n     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debugcatchBrushExceptiontrue\n         * 0 : debug\n         * 1 : \n         * 2 : \n         */\n        debugMode: 0,\n\n        // retina \n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n/***/ }),\n/* 215 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = __webpack_require__(190);\n    var Element = __webpack_require__(239);\n    var BoundingRect = __webpack_require__(200);\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * \n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         *  index \n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * \n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         *  nextSibling \n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToStorage(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromStorage(child);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * \n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromStorage(child);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToStorage(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromStorage(child);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n/***/ }),\n/* 216 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var coordinateSystemCreators = {};\n\n    function CoordinateSystemManager() {\n\n        this._coordinateSystems = [];\n    }\n\n    CoordinateSystemManager.prototype = {\n\n        constructor: CoordinateSystemManager,\n\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n                var list = creater.create(ecModel, api);\n                coordinateSystems = coordinateSystems.concat(list || []);\n            });\n\n            this._coordinateSystems = coordinateSystems;\n        },\n\n        update: function (ecModel, api) {\n            zrUtil.each(this._coordinateSystems, function (coordSys) {\n                // FIXME MUST have\n                coordSys.update && coordSys.update(ecModel, api);\n            });\n        },\n\n        getCoordinateSystems: function () {\n            return this._coordinateSystems.slice();\n        }\n    };\n\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n\n    module.exports = CoordinateSystemManager;\n\n\n/***/ }),\n/* 217 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var formatUtil = __webpack_require__(197);\n    var classUtil = __webpack_require__(201);\n    var modelUtil = __webpack_require__(194);\n    var ComponentModel = __webpack_require__(202);\n    var colorPaletteMixin = __webpack_require__(237);\n    var env = __webpack_require__(198);\n    var layout = __webpack_require__(203);\n\n    var set = classUtil.set;\n    var get = classUtil.get;\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            var data = this.getInitialData(option, ecModel);\n            if (__DEV__) {\n                zrUtil.assert(data, 'getInitialData returned invalid data.');\n            }\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            set(this, 'dataBeforeProcessed', data);\n\n            // If we reverse the order (make data firstly, and then make\n            // dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause data.graph.data !== data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this.restoreData();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `position` and `show`\n            // FIXME Set label in mergeOption\n            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\n            this.fillDataTextStyle(option.data);\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n            }\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                set(this, 'data', data);\n                set(this, 'dataBeforeProcessed', data.cloneShallow());\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `position` and `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            var data = get(this, 'data');\n            return dataType == null ? data : data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            set(this, 'data', data);\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return get(this, 'dataBeforeProcessed');\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return modelUtil.coordDimToDataDim(this.getData(), coordDim);\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return modelUtil.dataDimToCoordDim(this.getData(), dataDim);\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var vertially = zrUtil.reduce(value, function (vertially, val, idx) {\n                    var dimItem = data.getDimensionInfo(idx);\n                    return vertially |= dimItem && dimItem.tooltip !== false && dimItem.tooltipName != null;\n                }, 0);\n\n                var result = [];\n                var tooltipDims = modelUtil.otherDimToDataDim(data, 'tooltip');\n\n                tooltipDims.length\n                    ? zrUtil.each(tooltipDims, function (dimIdx) {\n                        setEachItem(data.get(dimIdx, dataIndex), dimIdx);\n                    })\n                    // By default, all dims is used on tooltip.\n                    : zrUtil.each(value, setEachItem);\n\n                function setEachItem(val, dimIdx) {\n                    var dimInfo = data.getDimensionInfo(dimIdx);\n                    // If `dimInfo.tooltip` is not set, show tooltip.\n                    if (!dimInfo || dimInfo.otherDims.tooltip === false) {\n                        return;\n                    }\n                    var dimType = dimInfo.type;\n                    var valStr = (vertially ? '- ' + (dimInfo.tooltipName || dimInfo.name) + ': ' : '')\n                        + (dimType === 'ordinal'\n                            ? val + ''\n                            : dimType === 'time'\n                            ? (multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val))\n                            : addCommas(val)\n                        );\n                    valStr && result.push(encodeHTML(valStr));\n                }\n\n                return (vertially ? '<br/>' : '') + result.join(vertially ? '<br/>' : ', ');\n            }\n\n            var data = get(this, 'data');\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = zrUtil.isArray(value)\n                ? formatArrayValue(value) : encodeHTML(addCommas(value));\n            var name = data.getName(dataIndex);\n\n            var color = data.getItemVisual(dataIndex, 'color');\n            if (zrUtil.isObject(color) && color.colorStops) {\n                color = (color.colorStops[0] || {}).color;\n            }\n            color = color || 'transparent';\n\n            var colorEl = formatUtil.getTooltipMarker(color);\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            seriesName = seriesName\n                ? encodeHTML(seriesName) + (!multipleSeries ? '<br/>' : ': ')\n                : '';\n            return !multipleSeries\n                ? seriesName + colorEl\n                    + (name\n                        ? encodeHTML(name) + ': ' + formattedValue\n                        : formattedValue\n                    )\n                : colorEl + seriesName + formattedValue;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        isAnimationEnabled: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Object} {dataIndices, nestestValue}.\n         */\n        getAxisTooltipData: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n\n\n/***/ }),\n/* 218 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = __webpack_require__(190);\n    var modelUtil = __webpack_require__(194);\n    var each = zrUtil.each;\n    var isString = zrUtil.isString;\n    var defaults = zrUtil.defaults;\n    var normalizeToArray = modelUtil.normalizeToArray;\n\n    var OTHER_DIMS = {tooltip: 1, label: 1, itemName: 1};\n\n    /**\n     * Complete the dimensions array, by user defined `dimension` and `encode`,\n     * and guessing from the data structure.\n     * If no 'value' dimension specified, the first no-named dimension will be\n     * named as 'value'.\n     *\n     * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which\n     *      provides not only dim template, but also default order.\n     *      `name` of each item provides default coord name.\n     *      [{dimsDef: []}, ...] can be specified to give names.\n     * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].\n     * @param {Object} [opt]\n     * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions\n     *      For example: ['asdf', {name, type}, ...].\n     * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}\n     * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.\n     * @param {string} [opt.extraFromZero] If specified, extra dim names will be:\n     *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...\n     *                      If not specified, extra dim names will be:\n     *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...\n     * @param {number} [opt.dimCount] If not specified, guess by the first data item.\n     * @return {Array.<Object>} [{\n     *      name: string mandatory,\n     *      coordDim: string mandatory,\n     *      coordDimIndex: number mandatory,\n     *      type: string optional,\n     *      tooltipName: string optional,\n     *      otherDims: {\n     *          tooltip: number optional,\n     *          label: number optional\n     *      },\n     *      isExtraCoord: boolean true or undefined.\n     *      other props ...\n     * }]\n     */\n    function completeDimensions(sysDims, data, opt) {\n        data = data || [];\n        opt = opt || {};\n        sysDims = (sysDims || []).slice();\n        var dimsDef = (opt.dimsDef || []).slice();\n        var encodeDef = zrUtil.createHashMap(opt.encodeDef);\n        var dataDimNameMap = zrUtil.createHashMap();\n        var coordDimNameMap = zrUtil.createHashMap();\n        // var valueCandidate;\n        var result = [];\n\n        var dimCount = opt.dimCount;\n        if (dimCount == null) {\n            var value0 = retrieveValue(data[0]);\n            dimCount = Math.max(\n                zrUtil.isArray(value0) && value0.length || 1,\n                sysDims.length,\n                dimsDef.length\n            );\n            each(sysDims, function (sysDimItem) {\n                var sysDimItemDimsDef = sysDimItem.dimsDef;\n                sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));\n            });\n        }\n\n        // Apply user defined dims (`name` and `type`) and init result.\n        for (var i = 0; i < dimCount; i++) {\n            var dimDefItem = isString(dimsDef[i]) ? {name: dimsDef[i]} : (dimsDef[i] || {});\n            var userDimName = dimDefItem.name;\n            var resultItem = result[i] = {otherDims: {}};\n            // Name will be applied later for avoiding duplication.\n            if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n                // Only if `series.dimensions` is defined in option, tooltipName\n                // will be set, and dimension will be diplayed vertically in\n                // tooltip by default.\n                resultItem.name = resultItem.tooltipName = userDimName;\n                dataDimNameMap.set(userDimName, i);\n            }\n            dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n        }\n\n        // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.\n        encodeDef.each(function (dataDims, coordDim) {\n            dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice());\n            each(dataDims, function (resultDimIdx, coordDimIndex) {\n                // The input resultDimIdx can be dim name or index.\n                isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));\n                if (resultDimIdx != null && resultDimIdx < dimCount) {\n                    dataDims[coordDimIndex] = resultDimIdx;\n                    applyDim(result[resultDimIdx], coordDim, coordDimIndex);\n                }\n            });\n        });\n\n        // Apply templetes and default order from `sysDims`.\n        var availDimIdx = 0;\n        each(sysDims, function (sysDimItem, sysDimIndex) {\n            var coordDim;\n            var sysDimItem;\n            var sysDimItemDimsDef;\n            var sysDimItemOtherDims;\n            if (isString(sysDimItem)) {\n                coordDim = sysDimItem;\n                sysDimItem = {};\n            }\n            else {\n                coordDim = sysDimItem.name;\n                sysDimItem = zrUtil.clone(sysDimItem);\n                // `coordDimIndex` should not be set directly.\n                sysDimItemDimsDef = sysDimItem.dimsDef;\n                sysDimItemOtherDims = sysDimItem.otherDims;\n                sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex\n                    = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n            }\n\n            var dataDims = normalizeToArray(encodeDef.get(coordDim));\n            // dimensions provides default dim sequences.\n            if (!dataDims.length) {\n                for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n                    while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n                        availDimIdx++;\n                    }\n                    availDimIdx < result.length && dataDims.push(availDimIdx++);\n                }\n            }\n            // Apply templates.\n            each(dataDims, function (resultDimIdx, coordDimIndex) {\n                var resultItem = result[resultDimIdx];\n                applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n                if (resultItem.name == null && sysDimItemDimsDef) {\n                    resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];\n                }\n                sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n            });\n        });\n\n        // Make sure the first extra dim is 'value'.\n        var extra = opt.extraPrefix || 'value';\n\n        // Set dim `name` and other `coordDim` and other props.\n        for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n            var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};\n            var coordDim = resultItem.coordDim;\n\n            coordDim == null && (\n                resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero),\n                resultItem.coordDimIndex = 0,\n                resultItem.isExtraCoord = true\n            );\n\n            resultItem.name == null && (resultItem.name = genName(\n                resultItem.coordDim,\n                dataDimNameMap\n            ));\n\n            resultItem.type == null && guessOrdinal(data, resultDimIdx)\n                && (resultItem.type = 'ordinal');\n        }\n\n        return result;\n\n        function applyDim(resultItem, coordDim, coordDimIndex) {\n            if (OTHER_DIMS[coordDim]) {\n                resultItem.otherDims[coordDim] = coordDimIndex;\n            }\n            else {\n                resultItem.coordDim = coordDim;\n                resultItem.coordDimIndex = coordDimIndex;\n                coordDimNameMap.set(coordDim, true);\n            }\n        }\n\n        function genName(name, map, fromZero) {\n            if (fromZero || map.get(name) != null) {\n                var i = 0;\n                while (map.get(name + i) != null) {\n                    i++;\n                }\n                name += i;\n            }\n            map.set(name, true);\n            return name;\n        }\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            // Consider usage convenience, '1', '2' will be treated as \"number\".\n            if (value != null && isFinite(value)) {\n                return false;\n            }\n            else if (isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n\n\n/***/ }),\n/* 219 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Symbol factory\n\n\n    var graphic = __webpack_require__(192);\n    var BoundingRect = __webpack_require__(200);\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME  onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            // TODO Support image object, DynamicImage.\n\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n\n\n/***/ }),\n/* 220 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// TODO Parse shadow style\n// TODO Only shallow path support\n\n    var zrUtil = __webpack_require__(190);\n\n    module.exports = function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n               properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes, includes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if ((excludes && zrUtil.indexOf(excludes, propName) >= 0)\n                    || (includes && zrUtil.indexOf(includes, propName) < 0)\n                ) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n\n\n/***/ }),\n/* 221 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var Model = __webpack_require__(199);\n    var each = zrUtil.each;\n    var curry = zrUtil.curry;\n\n    var helper = {};\n\n    // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n    // allAxesInfo should be updated when setOption performed.\n    helper.collect = function (ecModel, api) {\n        var result = {\n            /**\n             * key: makeKey(axis.model)\n             * value: {\n             *      axis,\n             *      coordSys,\n             *      axisPointerModel,\n             *      triggerTooltip,\n             *      involveSeries,\n             *      snap,\n             *      seriesModels,\n             *      seriesDataCount\n             * }\n             */\n            axesInfo: {},\n            seriesInvolved: false,\n            /**\n             * key: makeKey(coordSys.model)\n             * value: Object: key makeKey(axis.model), value: axisInfo\n             */\n            coordSysAxesInfo: {},\n            coordSysMap: {}\n        };\n\n        collectAxesInfo(result, ecModel, api);\n\n        // Check seriesInvolved for performance, in case too many series in some chart.\n        result.seriesInvolved && collectSeriesInfo(result, ecModel);\n\n        return result;\n    };\n\n    function collectAxesInfo(result, ecModel, api) {\n        var globalTooltipModel = ecModel.getComponent('tooltip');\n        var globalAxisPointerModel = ecModel.getComponent('axisPointer');\n        // links can only be set on global.\n        var linksOption = globalAxisPointerModel.get('link', true) || [];\n        var linkGroups = [];\n\n        // Collect axes info.\n        each(api.getCoordinateSystems(), function (coordSys) {\n            // Some coordinate system do not support axes, like geo.\n            if (!coordSys.axisPointerEnabled) {\n                return;\n            }\n\n            var coordSysKey = makeKey(coordSys.model);\n            var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n            result.coordSysMap[coordSysKey] = coordSys;\n\n            // Set tooltip (like 'cross') is a convienent way to show axisPointer\n            // for user. So we enable seting tooltip on coordSys model.\n            var coordSysModel = coordSys.model;\n            var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n\n            each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null));\n\n            // If axis tooltip used, choose tooltip axis for each coordSys.\n            // Notice this case: coordSys is `grid` but not `cartesian2D` here.\n            if (coordSys.getTooltipAxes\n                && globalTooltipModel\n                // If tooltip.showContent is set as false, tooltip will not\n                // show but axisPointer will show as normal.\n                && baseTooltipModel.get('show')\n            ) {\n                // Compatible with previous logic. But series.tooltip.trigger: 'axis'\n                // or series.data[n].tooltip.trigger: 'axis' are not support any more.\n                var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n                var cross = baseTooltipModel.get('axisPointer.type') === 'cross';\n                var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));\n                if (triggerAxis || cross) {\n                    each(tooltipAxes.baseAxes, curry(\n                        saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis\n                    ));\n                }\n                if (cross) {\n                    each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));\n                }\n            }\n\n            // fromTooltip: true | false | 'cross'\n            // triggerTooltip: true | false | null\n            function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n                var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n\n                var axisPointerShow = axisPointerModel.get('show');\n                if (!axisPointerShow || (\n                    axisPointerShow === 'auto'\n                    && !fromTooltip\n                    && !isHandleTrigger(axisPointerModel)\n                )) {\n                    return;\n                }\n\n                if (triggerTooltip == null) {\n                    triggerTooltip = axisPointerModel.get('triggerTooltip');\n                }\n\n                axisPointerModel = fromTooltip\n                    ? makeAxisPointerModel(\n                        axis, baseTooltipModel, globalAxisPointerModel, ecModel,\n                        fromTooltip, triggerTooltip\n                    )\n                    : axisPointerModel;\n\n                var snap = axisPointerModel.get('snap');\n                var key = makeKey(axis.model);\n                var involveSeries = triggerTooltip || snap || axis.type === 'category';\n\n                // If result.axesInfo[key] exist, override it (tooltip has higher priority).\n                var axisInfo = result.axesInfo[key] = {\n                    key: key,\n                    axis: axis,\n                    coordSys: coordSys,\n                    axisPointerModel: axisPointerModel,\n                    triggerTooltip: triggerTooltip,\n                    involveSeries: involveSeries,\n                    snap: snap,\n                    useHandle: isHandleTrigger(axisPointerModel),\n                    seriesModels: []\n                };\n                axesInfoInCoordSys[key] = axisInfo;\n                result.seriesInvolved |= involveSeries;\n\n                var groupIndex = getLinkGroupIndex(linksOption, axis);\n                if (groupIndex != null) {\n                    var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {axesInfo: {}});\n                    linkGroup.axesInfo[key] = axisInfo;\n                    linkGroup.mapper = linksOption[groupIndex].mapper;\n                    axisInfo.linkGroup = linkGroup;\n                }\n            }\n        });\n    }\n\n    function makeAxisPointerModel(\n        axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip\n    ) {\n        var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n        var volatileOption = {};\n\n        each(\n            [\n                'type', 'snap', 'lineStyle', 'shadowStyle', 'label',\n                'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'\n            ],\n            function (field) {\n                volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));\n            }\n        );\n\n        // category axis do not auto snap, otherwise some tick that do not\n        // has value can not be hovered. value/time/log axis default snap if\n        // triggered from tooltip and trigger tooltip.\n        volatileOption.snap = axis.type !== 'category' && !!triggerTooltip;\n\n        // Compatibel with previous behavior, tooltip axis do not show label by default.\n        // Only these properties can be overrided from tooltip to axisPointer.\n        if (tooltipAxisPointerModel.get('type') === 'cross') {\n            volatileOption.type = 'line';\n        }\n        var labelOption = volatileOption.label || (volatileOption.label = {});\n        // Follow the convention, do not show label when triggered by tooltip by default.\n        labelOption.show == null && (labelOption.show = false);\n\n        if (fromTooltip === 'cross') {\n            // When 'cross', both axes show labels.\n            labelOption.show = true;\n            // If triggerTooltip, this is a base axis, which should better not use cross style\n            // (cross style is dashed by default)\n            if (!triggerTooltip) {\n                var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n                crossStyle && zrUtil.defaults(\n                    labelOption.textStyle || (labelOption.textStyle = {}),\n                    crossStyle.textStyle\n                );\n            }\n        }\n\n        return axis.model.getModel(\n            'axisPointer',\n            new Model(volatileOption, globalAxisPointerModel, ecModel)\n        );\n    }\n\n    function collectSeriesInfo(result, ecModel) {\n        // Prepare data for axis trigger\n        ecModel.eachSeries(function (seriesModel) {\n\n            // Notice this case: this coordSys is `cartesian2D` but not `grid`.\n            var coordSys = seriesModel.coordinateSystem;\n            var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);\n            var seriesTooltipShow = seriesModel.get('tooltip.show', true);\n            if (!coordSys\n                || seriesTooltipTrigger === 'none'\n                || seriesTooltipTrigger === false\n                || seriesTooltipTrigger === 'item'\n                || seriesTooltipShow === false\n                || seriesModel.get('axisPointer.show', true) === false\n            ) {\n                return;\n            }\n\n            each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n                var axis = axisInfo.axis;\n                if (coordSys.getAxis(axis.dim) === axis) {\n                    axisInfo.seriesModels.push(seriesModel);\n                    axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n                    axisInfo.seriesDataCount += seriesModel.getData().count();\n                }\n            });\n\n        }, this);\n    }\n\n    /**\n     * For example:\n     * {\n     *     axisPointer: {\n     *         links: [{\n     *             xAxisIndex: [2, 4],\n     *             yAxisIndex: 'all'\n     *         }, {\n     *             xAxisId: ['a5', 'a7'],\n     *             xAxisName: 'xxx'\n     *         }]\n     *     }\n     * }\n     */\n    function getLinkGroupIndex(linksOption, axis) {\n        var axisModel = axis.model;\n        var dim = axis.dim;\n        for (var i = 0; i < linksOption.length; i++) {\n            var linkOption = linksOption[i] || {};\n            if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id)\n                || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex)\n                || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)\n            ) {\n                return i;\n            }\n        }\n    }\n\n    function checkPropInLink(linkPropValue, axisPropValue) {\n        return linkPropValue === 'all'\n            || (zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0)\n            || linkPropValue === axisPropValue;\n    }\n\n    helper.fixValue = function (axisModel) {\n        var axisInfo = helper.getAxisInfo(axisModel);\n        if (!axisInfo) {\n            return;\n        }\n\n        var axisPointerModel = axisInfo.axisPointerModel;\n        var scale = axisInfo.axis.scale;\n        var option = axisPointerModel.option;\n        var status = axisPointerModel.get('status');\n        var value = axisPointerModel.get('value');\n\n        // Parse init value for category and time axis.\n        if (value != null) {\n            value = scale.parse(value);\n        }\n\n        var useHandle = isHandleTrigger(axisPointerModel);\n        // If `handle` used, `axisPointer` will always be displayed, so value\n        // and status should be initialized.\n        if (status == null) {\n            option.status = useHandle ? 'show' : 'hide';\n        }\n\n        var extent = scale.getExtent().slice();\n        extent[0] > extent[1] && extent.reverse();\n\n        if (// Pick a value on axis when initializing.\n            value == null\n            // If both `handle` and `dataZoom` are used, value may be out of axis extent,\n            // where we should re-pick a value to keep `handle` displaying normally.\n            || value > extent[1]\n        ) {\n            // Make handle displayed on the end of the axis when init, which looks better.\n            value = extent[1];\n        }\n        if (value < extent[0]) {\n            value = extent[0];\n        }\n\n        option.value = value;\n\n        if (useHandle) {\n            option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n        }\n    };\n\n    helper.getAxisInfo = function (axisModel) {\n        var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n        return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n    };\n\n    helper.getAxisPointerModel = function (axisModel) {\n        var axisInfo = helper.getAxisInfo(axisModel);\n        return axisInfo && axisInfo.axisPointerModel;\n    };\n\n    function isHandleTrigger(axisPointerModel) {\n        return !!axisPointerModel.get('handle.show');\n    }\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @return {string} unique key\n     */\n    var makeKey = helper.makeKey = function (model) {\n        return model.type + '||' + model.id;\n    };\n\n    module.exports = helper;\n\n\n\n/***/ }),\n/* 222 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\n\n    var numberUtil = __webpack_require__(193);\n    var formatUtil = __webpack_require__(197);\n    var Scale = __webpack_require__(213);\n    var helper = __webpack_require__(238);\n\n    var roundNumber = numberUtil.round;\n\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n\n        type: 'interval',\n\n        _interval: 0,\n\n        _intervalPrecision: 2,\n\n        setExtent: function (start, end) {\n            var thisExtent = this._extent;\n            //start,end may be a Number like '25',so...\n            if (!isNaN(start)) {\n                thisExtent[0] = parseFloat(start);\n            }\n            if (!isNaN(end)) {\n                thisExtent[1] = parseFloat(end);\n            }\n        },\n\n        unionExtent: function (other) {\n            var extent = this._extent;\n            other[0] < extent[0] && (extent[0] = other[0]);\n            other[1] > extent[1] && (extent[1] = other[1]);\n\n            // unionExtent may called by it's sub classes\n            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n        },\n        /**\n         * Get interval\n         */\n        getInterval: function () {\n            return this._interval;\n        },\n\n        /**\n         * Set interval\n         */\n        setInterval: function (interval) {\n            this._interval = interval;\n            // Dropped auto calculated niceExtent and use user setted extent\n            // We assume user wan't to set both interval, min, max to get a better result\n            this._niceExtent = this._extent.slice();\n\n            this._intervalPrecision = helper.getIntervalPrecision(interval);\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            return helper.intervalScaleGetTicks(\n                this._interval, this._extent, this._niceExtent, this._intervalPrecision\n            );\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getTicksLabels: function () {\n            var labels = [];\n            var ticks = this.getTicks();\n            for (var i = 0; i < ticks.length; i++) {\n                labels.push(this.getLabel(ticks[i]));\n            }\n            return labels;\n        },\n\n        /**\n         * @param {number} data\n         * @param {Object} [opt]\n         * @param {number|string} [opt.precision] If 'auto', use nice presision.\n         * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n         * @return {string}\n         */\n        getLabel: function (data, opt) {\n            if (data == null) {\n                return '';\n            }\n\n            var precision = opt && opt.precision;\n\n            if (precision == null) {\n                precision = numberUtil.getPrecisionSafe(data) || 0;\n            }\n            else if (precision === 'auto') {\n                // Should be more precise then tick.\n                precision = this._intervalPrecision;\n            }\n\n            // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n            // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n            data = roundNumber(data, precision, true);\n\n            return formatUtil.addCommas(data);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         *\n         * @param {number} [splitNumber = 5] Desired number of ticks\n         * @param {number} [minInterval]\n         */\n        niceTicks: function (splitNumber, minInterval) {\n            splitNumber = splitNumber || 5;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (!isFinite(span)) {\n                return;\n            }\n            // User may set axis min 0 and data are all negative\n            // FIXME If it needs to reverse ?\n            if (span < 0) {\n                span = -span;\n                extent.reverse();\n            }\n\n            var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval);\n\n            this._intervalPrecision = result.intervalPrecision;\n            this._interval = result.interval;\n            this._niceExtent = result.niceTickExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {Object} opt\n         * @param {number} [opt.splitNumber = 5] Given approx tick number\n         * @param {boolean} [opt.fixMin=false]\n         * @param {boolean} [opt.fixMax=false]\n         * @param {boolean} [opt.minInterval=false]\n         */\n        niceExtent: function (opt) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                if (extent[0] !== 0) {\n                    // Expand extent\n                    var expandSize = extent[0];\n                    // In the fowllowing case\n                    //      Axis has been fixed max 100\n                    //      Plus data are all 100 and axis extent are [100, 100].\n                    // Extend to the both side will cause expanded max is larger than fixed max.\n                    // So only expand to the smaller side.\n                    if (!opt.fixMax) {\n                        extent[1] += expandSize / 2;\n                        extent[0] -= expandSize / 2;\n                    }\n                    else {\n                        extent[0] -= expandSize / 2;\n                    }\n                }\n                else {\n                    extent[1] = 1;\n                }\n            }\n            var span = extent[1] - extent[0];\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (!isFinite(span)) {\n                extent[0] = 0;\n                extent[1] = 1;\n            }\n\n            this.niceTicks(opt.splitNumber, opt.minInterval);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!opt.fixMin) {\n                extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n            }\n            if (!opt.fixMax) {\n                extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n            }\n        }\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n\n    module.exports = IntervalScale;\n\n\n\n/***/ }),\n/* 223 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var Style = __webpack_require__(246);\n\n    var Element = __webpack_require__(239);\n    var RectText = __webpack_require__(264);\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable Painter \n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * true\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * zlevelcanvas\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * \n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * \n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         *  x, y \n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         *  x, y \n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * \n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * \n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO,  bind \n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n/***/ }),\n/* 224 */\n/***/ (function(module, exports) {\n\n\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n\n/***/ }),\n/* 225 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var clazz = __webpack_require__(201);\n\n    var parseClassType = clazz.parseClassType;\n\n    var base = 0;\n\n    var componentUtil = {};\n\n    var DELIMITER = '_';\n\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [(type || ''), base++, Math.random()].join(DELIMITER);\n    };\n\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n\n        var subTypeDefaulters = {};\n\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n\n        return entity;\n    };\n\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(\n                    currVertex.successor,\n                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n                );\n            }\n\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n\n            zrUtil.each(fullNameList, function (name) {\n\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n\n            return {graph: graph, noEntryList: noEntryList};\n        }\n\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {predecessor: [], successor: []};\n            }\n            return graph[name];\n        }\n\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n\n    module.exports = componentUtil;\n\n\n/***/ }),\n/* 226 */\n/***/ (function(module, exports) {\n\n// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n/***/ }),\n/* 227 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var numberUtil = __webpack_require__(193);\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = __webpack_require__(190);\n    var axisHelper = __webpack_require__(205);\n\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n\n    var normalizedExtent = [0, 1];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [0, 0];\n\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._labelInterval;\n    };\n\n    Axis.prototype = {\n\n        constructor: Axis,\n\n        /**\n         * If axis extent contain given coord\n         * @param {number} coord\n         * @return {boolean}\n         */\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n\n        /**\n         * If axis extent contain given data\n         * @param {number} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n\n        /**\n         * Get coord extent.\n         * @return {Array.<number>}\n         */\n        getExtent: function () {\n            return this._extent.slice();\n        },\n\n        /**\n         * Get precision used for formatting\n         * @param {Array.<number>} [dataExtent]\n         * @return {number}\n         */\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(\n                dataExtent || this.scale.getExtent(),\n                this._extent\n            );\n        },\n\n        /**\n         * Set coord extent\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n\n        /**\n         * Convert data to coord. Data is the rank if it has a ordinal scale\n         * @param {number} data\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n\n        /**\n         * Convert coord to data. Data is the rank if it has a ordinal scale\n         * @param {number} coord\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\n            return this.scale.scale(t);\n        },\n\n        /**\n         * Convert pixel point to data in axis\n         * @param {Array.<number>} point\n         * @param  {boolean} clamp\n         * @return {number} data\n         */\n        pointToData: function (point, clamp) {\n            // Should be implemented in derived class if necessary.\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            }\n            else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n\n        /**\n         * Coords of labels are on the ticks or on the middle of bands\n         * @return {Array.<number>}\n         */\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n\n        /**\n         * Get bands.\n         *\n         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n         * |---1---|---2---|---3---|---4---|.\n         *\n         * @return {Array}\n         */\n         // FIXME Situation when labels is on ticks\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n\n        /**\n         * Get width of band\n         * @return {number}\n         */\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n            return Math.abs(size) / len;\n        },\n\n        /**\n         * Get interval of the axis label.\n         * @return {number}\n         */\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                var axisModel = this.model;\n                var labelModel = axisModel.getModel('axisLabel');\n                var interval = labelModel.get('interval');\n                if (!(this.type === 'category' && interval === 'auto')) {\n                    labelInterval = interval === 'auto' ? 0 : interval;\n                }\n                else if (this.isHorizontal){\n                    labelInterval = axisHelper.getAxisLabelInterval(\n                        zrUtil.map(this.scale.getTicks(), this.dataToCoord, this),\n                        axisModel.getFormattedLabels(),\n                        labelModel.getModel('textStyle').getFont(),\n                        this.isHorizontal()\n                    );\n                }\n                this._labelInterval = labelInterval;\n            }\n            return labelInterval;\n        }\n\n    };\n\n    module.exports = Axis;\n\n\n/***/ }),\n/* 228 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var List = __webpack_require__(211);\n    var completeDimensions = __webpack_require__(218);\n    var zrUtil = __webpack_require__(190);\n    var modelUtil = __webpack_require__(194);\n    var CoordinateSystem = __webpack_require__(216);\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null\n            && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        var completeDimOpt = {\n            encodeDef: seriesModel.get('encode'),\n            dimsDef: seriesModel.get('dimensions')\n        };\n\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = (registeredCoordSys && (\n                registeredCoordSys.getDimensionsInfo\n                    ? registeredCoordSys.getDimensionsInfo()\n                    : registeredCoordSys.dimensions.slice()\n            )) || ['x', 'y'];\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n        }\n\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n        var list = new List(dimensions, seriesModel);\n\n        var nameList = createNameList(axesInfo, data);\n\n        var categories = {};\n        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex\n                    ? dataIndex\n                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            }\n            : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName]\n                            || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n\n        return list;\n    }\n\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category'\n            ? 'ordinal'\n            : axisType === 'time'\n            ? 'time'\n            : 'float';\n    }\n\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n\n        cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) {\n\n            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n                return ecModel.queryComponents({\n                    mainType: name,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n            });\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (__DEV__) {\n                if (!xAxisModel) {\n                    throw new Error('xAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('xAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n                if (!yAxisModel) {\n                    throw new Error('yAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('yAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n\n            var xAxisType = xAxisModel.get('type');\n            var yAxisType = yAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'x',\n                    type: getDimTypeByAxis(xAxisType),\n                    stackable: isStackable(xAxisType)\n                },\n                {\n                    name: 'y',\n                    // If two category axes\n                    type: getDimTypeByAxis(yAxisType),\n                    stackable: isStackable(yAxisType)\n                }\n            ];\n\n            var isXAxisCateogry = xAxisType === 'category';\n            var isYAxisCategory = yAxisType === 'category';\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isXAxisCateogry) {\n                categoryAxesModels.x = xAxisModel;\n            }\n            if (isYAxisCategory) {\n                categoryAxesModels.y = yAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        singleAxis: function (data, seriesModel, ecModel, completeDimOpt) {\n\n            var singleAxisModel = ecModel.queryComponents({\n                mainType: 'singleAxis',\n                index: seriesModel.get('singleAxisIndex'),\n                id: seriesModel.get('singleAxisId')\n            })[0];\n\n            if (__DEV__) {\n                if (!singleAxisModel) {\n                    throw new Error('singleAxis should be specified.');\n                }\n            }\n\n            var singleAxisType = singleAxisModel.get('type');\n            var isCategory = singleAxisType === 'category';\n\n            var dimensions = [{\n                name: 'single',\n                type: getDimTypeByAxis(singleAxisType),\n                stackable: isStackable(singleAxisType)\n            }];\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isCategory) {\n                categoryAxesModels.single = singleAxisModel;\n            }\n\n            return {\n                dimensions: dimensions,\n                categoryIndex: isCategory ? 0 : -1,\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        polar: function (data, seriesModel, ecModel, completeDimOpt) {\n            var polarModel = ecModel.queryComponents({\n                mainType: 'polar',\n                index: seriesModel.get('polarIndex'),\n                id: seriesModel.get('polarId')\n            })[0];\n\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n            if (__DEV__) {\n                if (!angleAxisModel) {\n                    throw new Error('angleAxis option not found');\n                }\n                if (!radiusAxisModel) {\n                    throw new Error('radiusAxis option not found');\n                }\n            }\n\n            var radiusAxisType = radiusAxisModel.get('type');\n            var angleAxisType = angleAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'radius',\n                    type: getDimTypeByAxis(radiusAxisType),\n                    stackable: isStackable(radiusAxisType)\n                },\n                {\n                    name: 'angle',\n                    type: getDimTypeByAxis(angleAxisType),\n                    stackable: isStackable(angleAxisType)\n                }\n            ];\n            var isAngleAxisCateogry = angleAxisType === 'category';\n            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isRadiusAxisCateogry) {\n                categoryAxesModels.radius = radiusAxisModel;\n            }\n            if (isAngleAxisCateogry) {\n                categoryAxesModels.angle = angleAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        geo: function (data, seriesModel, ecModel, completeDimOpt) {\n            // TODO Region\n            // \n            return {\n                dimensions: completeDimensions([\n                    {name: 'lng'},\n                    {name: 'lat'}\n                ], data, completeDimOpt)\n            };\n        }\n    };\n\n    function createNameList(result, data) {\n        var nameList = [];\n\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                }\n                else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n\n        return nameList;\n    }\n\n    module.exports = createListFromArray;\n\n\n\n/***/ }),\n/* 229 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var formatUtil = __webpack_require__(197);\n    var graphic = __webpack_require__(192);\n    var Model = __webpack_require__(199);\n    var numberUtil = __webpack_require__(193);\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = __webpack_require__(195);\n    var matrix = __webpack_require__(204);\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n\n    var PI = Math.PI;\n\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = {\n            componentType: axisModel.mainType\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     * @param {number} [opt.nameTruncateMaxWidth]\n     */\n    var AxisBuilder = function (axisModel, opt) {\n\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n\n        // Default value\n        zrUtil.defaults(\n            opt,\n            {\n                labelOffset: 0,\n                nameDirection: 1,\n                tickDirection: 1,\n                labelDirection: 1,\n                silent: true\n            }\n        );\n\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n            position: opt.position.slice(),\n            rotation: opt.rotation\n        });\n\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n\n        this._dumbGroup = dumbGroup;\n    };\n\n    AxisBuilder.prototype = {\n\n        constructor: AxisBuilder,\n\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n\n        add: function (name) {\n            builders[name].call(this);\n        },\n\n        getGroup: function () {\n            return this.group;\n        }\n\n    };\n\n    var builders = {\n\n        /**\n         * @private\n         */\n        axisLine: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisLine.show')) {\n                return;\n            }\n\n            var extent = this.axisModel.axis.getExtent();\n\n            var matrix = this._transform;\n            var pt1 = [extent[0], 0];\n            var pt2 = [extent[1], 0];\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n\n            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                // Id for animation\n                anid: 'line',\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.extend(\n                    {lineCap: 'round'},\n                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n                ),\n                strokeContainThreshold: opt.strokeContainThreshold || 5,\n                silent: true,\n                z2: 1\n            })));\n        },\n\n        /**\n         * @private\n         */\n        axisTick: function () {\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n\n            if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n                return;\n            }\n\n            var tickModel = axisModel.getModel('axisTick');\n            var opt = this.opt;\n\n            var lineStyleModel = tickModel.getModel('lineStyle');\n            var tickLen = tickModel.get('length');\n\n            var tickInterval = getInterval(tickModel, opt.labelInterval);\n            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n            var ticks = axis.scale.getTicks();\n\n            var pt1 = [];\n            var pt2 = [];\n            var matrix = this._transform;\n\n            for (var i = 0; i < ticksCoords.length; i++) {\n                // Only ordinal scale support tick interval\n                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                     continue;\n                }\n\n                var tickCoord = ticksCoords[i];\n\n                pt1[0] = tickCoord;\n                pt1[1] = 0;\n                pt2[0] = tickCoord;\n                pt2[1] = opt.tickDirection * tickLen;\n\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                // Tick line, Not use group transform to have better line draw\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                    // Id for animation\n                    anid: 'tick_' + ticks[i],\n\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.defaults(\n                        lineStyleModel.getLineStyle(),\n                        {\n                            stroke: axisModel.get('axisLine.lineStyle.color')\n                        }\n                    ),\n                    z2: 2,\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @private\n         */\n        axisLabel: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n            if (!show || axis.scale.isBlank()) {\n                return;\n            }\n\n            var labelModel = axisModel.getModel('axisLabel');\n            var textStyleModel = labelModel.getModel('textStyle');\n            var labelMargin = labelModel.get('margin');\n            var ticks = axis.scale.getTicks();\n            var labels = axisModel.getFormattedLabels();\n\n            // Special label rotate.\n            var labelRotation = (\n                retrieve(opt.labelRotate, labelModel.get('rotate')) || 0\n            ) * PI / 180;\n\n            var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n            var categoryData = axisModel.get('data');\n\n            var textEls = [];\n            var silent = isSilent(axisModel);\n            var triggerEvent = axisModel.get('triggerEvent');\n\n            zrUtil.each(ticks, function (tickVal, index) {\n                if (ifIgnoreOnTick(axis, index, opt.labelInterval)) {\n                     return;\n                }\n\n                var itemTextStyleModel = textStyleModel;\n                if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n                    itemTextStyleModel = new Model(\n                        categoryData[tickVal].textStyle, textStyleModel, axisModel.ecModel\n                    );\n                }\n                var textColor = itemTextStyleModel.getTextColor()\n                    || axisModel.get('axisLine.lineStyle.color');\n\n                var tickCoord = axis.dataToCoord(tickVal);\n                var pos = [\n                    tickCoord,\n                    opt.labelOffset + opt.labelDirection * labelMargin\n                ];\n                var labelStr = axis.scale.getLabel(tickVal);\n\n                var textEl = new graphic.Text({\n\n                    // Id for animation\n                    anid: 'label_' + tickVal,\n\n                    style: {\n                        text: labels[index],\n                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.textVerticalAlign,\n                        textFont: itemTextStyleModel.getFont(),\n                        fill: typeof textColor === 'function'\n                            ? textColor(\n                                // (1) In category axis with data zoom, tick is not the original\n                                // index of axis.data. So tick should not be exposed to user\n                                // in category axis.\n                                // (2) Compatible with previous version, which always returns labelStr.\n                                // But in interval scale labelStr is like '223,445', which maked\n                                // user repalce ','. So we modify it to return original val but remain\n                                // it as 'string' to avoid error in replacing.\n                                axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal,\n                                index\n                            )\n                            : textColor\n                    },\n                    position: pos,\n                    rotation: labelLayout.rotation,\n                    silent: silent,\n                    z2: 10\n                });\n\n                // Pack data for mouse event\n                if (triggerEvent) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisLabel';\n                    textEl.eventData.value = labelStr;\n                }\n\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n\n                textEls.push(textEl);\n                this.group.add(textEl);\n\n                textEl.decomposeTransform();\n\n            }, this);\n\n            fixMinMaxLabelShow(axisModel, textEls);\n        },\n\n        /**\n         * @private\n         */\n        axisName: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var name = retrieve(opt.axisName, axisModel.get('name'));\n\n            if (!name) {\n                return;\n            }\n\n            var nameLocation = axisModel.get('nameLocation');\n            var nameDirection = opt.nameDirection;\n            var textStyleModel = axisModel.getModel('nameTextStyle');\n            var gap = axisModel.get('nameGap') || 0;\n\n            var extent = this.axisModel.axis.getExtent();\n            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n            var pos = [\n                nameLocation === 'start'\n                    ? extent[0] - gapSignal * gap\n                    : nameLocation === 'end'\n                    ? extent[1] + gapSignal * gap\n                    : (extent[0] + extent[1]) / 2, // 'middle'\n                // Reuse labelOffset.\n                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n            ];\n\n            var labelLayout;\n\n            var nameRotation = axisModel.get('nameRotate');\n            if (nameRotation != null) {\n                nameRotation = nameRotation * PI / 180; // To radian.\n            }\n\n            var axisNameAvailableWidth;\n\n            if (nameLocation === 'middle') {\n                labelLayout = innerTextLayout(\n                    opt.rotation,\n                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                    nameDirection\n                );\n            }\n            else {\n                labelLayout = endTextLayout(\n                    opt, nameLocation, nameRotation || 0, extent\n                );\n\n                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                if (axisNameAvailableWidth != null) {\n                    axisNameAvailableWidth = Math.abs(\n                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                    );\n                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                }\n            }\n\n            var textFont = textStyleModel.getFont();\n\n            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n            var ellipsis = truncateOpt.ellipsis;\n            var maxWidth = retrieve(\n                opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth\n            );\n            var truncatedText = (ellipsis != null && maxWidth != null)\n                ? formatUtil.truncateText(\n                    name, maxWidth, textFont, ellipsis,\n                    {minChar: 2, placeholder: truncateOpt.placeholder}\n                )\n                : name;\n\n            var tooltipOpt = axisModel.get('tooltip', true);\n\n            var mainType = axisModel.mainType;\n            var formatterParams = {\n                componentType: mainType,\n                name: name,\n                $vars: ['name']\n            };\n            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n            var textEl = new graphic.Text({\n\n                // Id for animation\n                anid: 'name',\n\n                __fullText: name,\n                __truncatedText: truncatedText,\n\n                style: {\n                    text: truncatedText,\n                    textFont: textFont,\n                    fill: textStyleModel.getTextColor()\n                        || axisModel.get('axisLine.lineStyle.color'),\n                    textAlign: labelLayout.textAlign,\n                    textVerticalAlign: labelLayout.textVerticalAlign\n                },\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: isSilent(axisModel),\n                z2: 1,\n                tooltip: (tooltipOpt && tooltipOpt.show)\n                    ? zrUtil.extend({\n                        content: name,\n                        formatter: function () {\n                            return name;\n                        },\n                        formatterParams: formatterParams\n                    }, tooltipOpt)\n                    : null\n            });\n\n            if (axisModel.get('triggerEvent')) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisName';\n                textEl.eventData.name = name;\n            }\n\n            // FIXME\n            this._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            this.group.add(textEl);\n\n            textEl.decomposeTransform();\n        }\n\n    };\n\n    /**\n     * @public\n     * @static\n     * @param {Object} opt\n     * @param {number} axisRotation in radian\n     * @param {number} textRotation in radian\n     * @param {number} direction\n     * @return {Object} {\n     *  rotation, // according to axis\n     *  textAlign,\n     *  textVerticalAlign\n     * }\n     */\n    var innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - axisRotation);\n        var textAlign;\n        var textVerticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            }\n            else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    };\n\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var textVerticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = (textPosition === 'start' && !inverse)\n            || (textPosition !== 'start' && inverse);\n\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            textVerticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            textVerticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            }\n            else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    }\n\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent')\n            // Consider mouse cursor, add these restrictions.\n            || !(\n                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n            );\n    }\n\n    function fixMinMaxLabelShow(axisModel, textEls) {\n        // If min or max are user set, we need to check\n        // If the tick on min(max) are overlap on their neighbour tick\n        // If they are overlapped, we need to hide the min(max) tick label\n        var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n        var firstLabel = textEls[0];\n        var nextLabel = textEls[1];\n        var lastLabel = textEls[textEls.length - 1];\n        var prevLabel = textEls[textEls.length - 2];\n\n        if (showMinLabel === false) {\n            firstLabel.ignore = true;\n        }\n        else if (axisModel.getMin() != null && isTwoLabelOverlapped(firstLabel, nextLabel)) {\n            showMinLabel ? (nextLabel.ignore = true) : (firstLabel.ignore = true);\n        }\n\n        if (showMaxLabel === false) {\n            lastLabel.ignore = true;\n        }\n        else if (axisModel.getMax() != null && isTwoLabelOverlapped(prevLabel, lastLabel)) {\n            showMaxLabel ? (prevLabel.ignore = true) : (lastLabel.ignore = true);\n        }\n    }\n\n    function isTwoLabelOverlapped(current, next, labelLayout) {\n        // current and next has the same rotation.\n        var firstRect = current && current.getBoundingRect().clone();\n        var nextRect = next && next.getBoundingRect().clone();\n\n        if (!firstRect || !nextRect) {\n            return;\n        }\n\n        // When checking intersect of two rotated labels, we use mRotationBack\n        // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n        var mRotationBack = matrix.identity([]);\n        matrix.rotate(mRotationBack, mRotationBack, -current.rotation);\n\n        firstRect.applyTransform(matrix.mul([], mRotationBack, current.getLocalTransform()));\n        nextRect.applyTransform(matrix.mul([], mRotationBack, next.getLocalTransform()));\n\n        return firstRect.intersect(nextRect);\n    }\n\n\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n        var rawTick;\n        var scale = axis.scale;\n        return scale.type === 'ordinal'\n            && (\n                typeof interval === 'function'\n                    ? (\n                        rawTick = scale.getTicks()[i],\n                        !interval(rawTick, scale.getLabel(rawTick))\n                    )\n                    : i % (interval + 1)\n            );\n    };\n\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n        var interval = model.get('interval');\n        if (interval == null || interval == 'auto') {\n            interval = labelInterval;\n        }\n        return interval;\n    };\n\n    module.exports = AxisBuilder;\n\n\n\n/***/ }),\n/* 230 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var axisHelper = __webpack_require__(205);\n\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        }\n        else {\n            return obj + '';\n        }\n    }\n\n    module.exports = {\n\n        /**\n         * Format labels\n         * @return {Array.<string>}\n         */\n        getFormattedLabels: function () {\n            return axisHelper.getFormattedLabels(\n                this.axis,\n                this.get('axisLabel.formatter')\n            );\n        },\n\n        /**\n         * Get categories\n         */\n        getCategories: function () {\n            return this.get('type') === 'category'\n                && zrUtil.map(this.get('data'), getName);\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n         */\n        getMin: function (origin) {\n            var option = this.option;\n            var min = (!origin && option.rangeStart != null)\n                ? option.rangeStart : option.min;\n\n            if (this.axis && min != null && min !== 'dataMin' && !zrUtil.eqNaN(min)) {\n                min = this.axis.scale.parse(min);\n            }\n            return min;\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n         */\n        getMax: function (origin) {\n            var option = this.option;\n            var max = (!origin && option.rangeEnd != null)\n                ? option.rangeEnd : option.max;\n\n            if (this.axis && max != null && max !== 'dataMax' && !zrUtil.eqNaN(max)) {\n                max = this.axis.scale.parse(max);\n            }\n            return max;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        getNeedCrossZero: function () {\n            var option = this.option;\n            return (option.rangeStart != null || option.rangeEnd != null)\n                ? false : !option.scale;\n        },\n\n        /**\n         * Should be implemented by each axis model if necessary.\n         * @return {module:echarts/model/Component} coordinate system model\n         */\n        getCoordSysModel: zrUtil.noop,\n\n        /**\n         * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n         * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n         */\n        setRange: function (rangeStart, rangeEnd) {\n            this.option.rangeStart = rangeStart;\n            this.option.rangeEnd = rangeEnd;\n        },\n\n        /**\n         * Reset range\n         */\n        resetRange: function () {\n            // rangeStart and rangeEnd is readonly.\n            this.option.rangeStart = this.option.rangeEnd = null;\n        }\n    };\n\n\n/***/ }),\n/* 231 */\n/***/ (function(module, exports) {\n\n\n\n    var lib = {};\n\n    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n    var RATE = '\\0__throttleRate';\n    var THROTTLE_TYPE = '\\0__throttleType';\n\n    /**\n     * @public\n     * @param {(Function)} fn\n     * @param {number} [delay=0] Unit: ms.\n     * @param {boolean} [debounce=false]\n     *        true: If call interval less than `delay`, only the last call works.\n     *        false: If call interval less than `delay, call works on fixed rate.\n     * @return {(Function)} throttled fn.\n     */\n    lib.throttle = function (fn, delay, debounce) {\n\n        var currCall;\n        var lastCall = 0;\n        var lastExec = 0;\n        var timer = null;\n        var diff;\n        var scope;\n        var args;\n        var debounceNextCall;\n\n        delay = delay || 0;\n\n        function exec() {\n            lastExec = (new Date()).getTime();\n            timer = null;\n            fn.apply(scope, args || []);\n        }\n\n        var cb = function () {\n            currCall = (new Date()).getTime();\n            scope = this;\n            args = arguments;\n            var thisDelay = debounceNextCall || delay;\n            var thisDebounce = debounceNextCall || debounce;\n            debounceNextCall = null;\n            diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;\n\n            clearTimeout(timer);\n\n            if (thisDebounce) {\n                timer = setTimeout(exec, thisDelay);\n            }\n            else {\n                if (diff >= 0) {\n                    exec();\n                }\n                else {\n                    timer = setTimeout(exec, -diff);\n                }\n            }\n\n            lastCall = currCall;\n        };\n\n        /**\n         * Clear throttle.\n         * @public\n         */\n        cb.clear = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n\n        /**\n         * Enable debounce once.\n         */\n        cb.debounceNextCall = function (debounceDelay) {\n            debounceNextCall = debounceDelay;\n        };\n\n        return cb;\n    };\n\n    /**\n     * Create throttle method or update throttle rate.\n     *\n     * @example\n     * ComponentView.prototype.render = function () {\n     *     ...\n     *     throttle.createOrUpdate(\n     *         this,\n     *         '_dispatchAction',\n     *         this.model.get('throttle'),\n     *         'fixRate'\n     *     );\n     * };\n     * ComponentView.prototype.remove = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     * ComponentView.prototype.dispose = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     * @param {number} [rate]\n     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n     * @return {Function} throttled function.\n     */\n    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n        var fn = obj[fnAttr];\n\n        if (!fn) {\n            return;\n        }\n\n        var originFn = fn[ORIGIN_METHOD] || fn;\n        var lastThrottleType = fn[THROTTLE_TYPE];\n        var lastRate = fn[RATE];\n\n        if (lastRate !== rate || lastThrottleType !== throttleType) {\n            if (rate == null || !throttleType) {\n                return (obj[fnAttr] = originFn);\n            }\n\n            fn = obj[fnAttr] = lib.throttle(\n                originFn, rate, throttleType === 'debounce'\n            );\n            fn[ORIGIN_METHOD] = originFn;\n            fn[THROTTLE_TYPE] = throttleType;\n            fn[RATE] = rate;\n        }\n\n        return fn;\n    };\n\n    /**\n     * Clear throttle. Example see throttle.createOrUpdate.\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     */\n    lib.clear = function (obj, fnAttr) {\n        var fn = obj[fnAttr];\n        if (fn && fn[ORIGIN_METHOD]) {\n            obj[fnAttr] = fn[ORIGIN_METHOD];\n        }\n    };\n\n    module.exports = lib;\n\n\n\n/***/ }),\n/* 232 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var Group = __webpack_require__(215);\n    var componentUtil = __webpack_require__(225);\n    var clazzUtil = __webpack_require__(201);\n    var modelUtil = __webpack_require__(194);\n    var zrUtil = __webpack_require__(190);\n\n    function Chart() {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n\n    Chart.prototype = {\n\n        type: 'chart',\n\n        /**\n         * Init the chart\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        init: function (ecModel, api) {},\n\n        /**\n         * Render the chart\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        render: function (seriesModel, ecModel, api, payload) {},\n\n        /**\n         * Highlight series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n\n        /**\n         * Downplay series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n\n        /**\n         * Remove self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n\n        /**\n         * Dispose self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        dispose: function () {}\n\n        /**\n         * The view contains the given point.\n         * @interface\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        // containPoint: function () {}\n\n    };\n\n    var chartProto = Chart.prototype;\n    chartProto.updateView\n        = chartProto.updateLayout\n        = chartProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            this.render(seriesModel, ecModel, api, payload);\n        };\n\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n        if (dataIndex != null) {\n            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n                elSetState(data.getItemGraphicEl(dataIdx), state);\n            });\n        }\n        else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\n    module.exports = Chart;\n\n\n/***/ }),\n/* 233 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var axisPointerModelHelper = __webpack_require__(221);\n\n    /**\n     * Base class of AxisView.\n     */\n    var AxisView = __webpack_require__(191).extendComponentView({\n\n        type: 'axis',\n\n        /**\n         * @private\n         */\n        _axisPointer: null,\n\n        /**\n         * @protected\n         * @type {string}\n         */\n        axisPointerClass: null,\n\n        /**\n         * @override\n         */\n        render: function (axisModel, ecModel, api, payload) {\n            // FIXME\n            // This process should proformed after coordinate systems updated\n            // (axis scale updated), and should be performed each time update.\n            // So put it here temporarily, although it is not appropriate to\n            // put a model-writing procedure in `view`.\n            this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);\n\n            AxisView.superApply(this, 'render', arguments);\n\n            updateAxisPointer(this, axisModel, ecModel, api, payload, true);\n        },\n\n        /**\n         * Action handler.\n         * @public\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/model/Global} ecModel\n         * @param {module:echarts/ExtensionAPI} api\n         * @param {Object} payload\n         */\n        updateAxisPointer: function (axisModel, ecModel, api, payload, force) {\n            updateAxisPointer(this, axisModel, ecModel, api, payload, false);\n        },\n\n        /**\n         * @override\n         */\n        remove: function (ecModel, api) {\n            var axisPointer = this._axisPointer;\n            axisPointer && axisPointer.remove(api);\n            AxisView.superApply(this, 'remove', arguments);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function (ecModel, api) {\n            disposeAxisPointer(this, api);\n            AxisView.superApply(this, 'dispose', arguments);\n        }\n\n    });\n\n    function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {\n        var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);\n        if (!Clazz) {\n            return;\n        }\n        var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);\n        axisPointerModel\n            ? (axisView._axisPointer || (axisView._axisPointer = new Clazz()))\n                .render(axisModel, axisPointerModel, api, forceRender)\n            : disposeAxisPointer(axisView, api);\n    }\n\n    function disposeAxisPointer(axisView, ecModel, api) {\n        var axisPointer = axisView._axisPointer;\n        axisPointer && axisPointer.dispose(ecModel, api);\n        axisView._axisPointer = null;\n    }\n\n    var axisPointerClazz = [];\n\n    AxisView.registerAxisPointerClass = function (type, clazz) {\n        if (__DEV__) {\n            if (axisPointerClazz[type]) {\n                throw new Error('axisPointer ' + type + ' exists');\n            }\n        }\n        axisPointerClazz[type] = clazz;\n    };\n\n    AxisView.getAxisPointerClass = function (type) {\n        return type && axisPointerClazz[type];\n    };\n\n    module.exports = AxisView;\n\n\n/***/ }),\n/* 234 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n        var config = __webpack_require__(214);\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n/***/ }),\n/* 235 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = __webpack_require__(223);\n    var BoundingRect = __webpack_require__(200);\n    var zrUtil = __webpack_require__(190);\n\n    var LRU = __webpack_require__(243);\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // \n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // \n                if (!image.width || !image.height) {\n                    return;\n                }\n                var width = style.width;\n                var height = style.height;\n                var aspect = image.width / image.height;\n                if (width == null && height != null) {\n                    // Keep image/height ratio\n                    width = height * aspect;\n                }\n                else if (height == null && width != null) {\n                    height = width / aspect;\n                }\n                else if (width == null && height == null) {\n                    width = image.width;\n                    height = image.height;\n                }\n\n                // transform\n                this.setTransform(ctx);\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n/***/ }),\n/* 236 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = __webpack_require__(204);\n    var vector = __webpack_require__(195);\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * \n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * \n     * , position, rotation, scaletransformtransform\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // \n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // \n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        return Transformable.getLocalTransform(this, m);\n    };\n\n    /**\n     * transformcontext\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    };\n\n    var tmpTransform = [];\n\n    /**\n     * `transform``position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     *  shape \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    /**\n     * @static\n     * @param {Object} target\n     * @param {Array.<number>} target.origin\n     * @param {number} target.rotation\n     * @param {Array.<number>} target.position\n     * @param {Array.<number>} [m]\n     */\n    Transformable.getLocalTransform = function (target, m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = target.origin;\n        var scale = target.scale || [1, 1];\n        var rotation = target.rotation || 0;\n        var position = target.position || [0, 0];\n\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n\n    module.exports = Transformable;\n\n\n\n/***/ }),\n/* 237 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var classUtil = __webpack_require__(201);\n    var set = classUtil.set;\n    var get = classUtil.get;\n\n    module.exports = {\n        clearColorPalette: function () {\n            set(this, 'colorIdx', 0);\n            set(this, 'colorNameMap', {});\n        },\n\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = get(scope, 'colorIdx') || 0;\n            var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {});\n            // Use `hasOwnProperty` to avoid conflict with Object.prototype.\n            if (colorNameMap.hasOwnProperty(name)) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n\n            return color;\n        }\n    };\n\n\n/***/ }),\n/* 238 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * For testable.\n */\n\n\n    var numberUtil = __webpack_require__(193);\n\n    var roundNumber = numberUtil.round;\n\n    var helper = {};\n\n    /**\n     * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n     *                                Should be extent[0] < extent[1].\n     * @param {number} splitNumber splitNumber should be >= 1.\n     * @param {number} [minInterval]\n     * @return {Object} {interval, intervalPrecision, niceTickExtent}\n     */\n    helper.intervalScaleNiceTicks = function (extent, splitNumber, minInterval) {\n        var result = {};\n        var span = extent[1] - extent[0];\n\n        var interval = result.interval = numberUtil.nice(span / splitNumber, true);\n        if (minInterval != null && interval < minInterval) {\n            interval = result.interval = minInterval;\n        }\n        // Tow more digital for tick.\n        var precision = result.intervalPrecision = helper.getIntervalPrecision(interval);\n        // Niced extent inside original extent\n        var niceTickExtent = result.niceTickExtent = [\n            roundNumber(Math.ceil(extent[0] / interval) * interval, precision),\n            roundNumber(Math.floor(extent[1] / interval) * interval, precision)\n        ];\n\n        helper.fixExtent(niceTickExtent, extent);\n\n        return result;\n    };\n\n    /**\n     * @param {number} interval\n     * @return {number} interval precision\n     */\n    helper.getIntervalPrecision = function (interval) {\n        // Tow more digital for tick.\n        return numberUtil.getPrecisionSafe(interval) + 2;\n    };\n\n    function clamp(niceTickExtent, idx, extent) {\n        niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n    }\n\n    // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\n    helper.fixExtent = function (niceTickExtent, extent) {\n        !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n        !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n        clamp(niceTickExtent, 0, extent);\n        clamp(niceTickExtent, 1, extent);\n        if (niceTickExtent[0] > niceTickExtent[1]) {\n            niceTickExtent[0] = niceTickExtent[1];\n        }\n    };\n\n    helper.intervalScaleGetTicks = function (interval, extent, niceTickExtent, intervalPrecision) {\n        var ticks = [];\n\n        // If interval is 0, return [];\n        if (!interval) {\n            return ticks;\n        }\n\n        // Consider this case: using dataZoom toolbox, zoom and zoom.\n        var safeLimit = 10000;\n\n        if (extent[0] < niceTickExtent[0]) {\n            ticks.push(extent[0]);\n        }\n        var tick = niceTickExtent[0];\n\n        while (tick <= niceTickExtent[1]) {\n            ticks.push(tick);\n            // Avoid rounding error\n            tick = roundNumber(tick + interval, intervalPrecision);\n            if (tick === ticks[ticks.length - 1]) {\n                // Consider out of safe float point, e.g.,\n                // -3711126.9907707 + 2e-10 === -3711126.9907707\n                break;\n            }\n            if (ticks.length > safeLimit) {\n                return [];\n            }\n        }\n        // Consider this case: the last item of ticks is smaller\n        // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n        if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {\n            ticks.push(extent[1]);\n        }\n\n        return ticks;\n    };\n\n    module.exports = helper;\n\n\n/***/ }),\n/* 239 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @module zrender/Element\n */\n\n\n    var guid = __webpack_require__(244);\n    var Eventful = __webpack_require__(210);\n    var Transformable = __webpack_require__(236);\n    var Animatable = __webpack_require__(310);\n    var zrUtil = __webpack_require__(190);\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * \n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * \n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender  element  zrender \n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * true\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * (shape) Group \n         * \n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n/***/ }),\n/* 240 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = __webpack_require__(289);\n    var color = __webpack_require__(208);\n    var util = __webpack_require__(190);\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = len && p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function getArrayDim(keyframes) {\n        var lastValue = keyframes[keyframes.length - 1].value;\n        return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * \n         * @param  {number} time ms\n         * @param  {Object} props key-value\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        pause: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].pause();\n            }\n            this._paused = true;\n        },\n\n        resume: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].resume();\n            }\n            this._paused = false;\n        },\n\n        isPaused: function () {\n            return !!this._paused;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * \n         * @param  {string|Function} easing\n         *         {@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * \n         * @param  {number} time ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n/***/ }),\n/* 241 */\n/***/ (function(module, exports) {\n\n\n\n    module.exports = (typeof window !== 'undefined' &&\n                ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window))\n                // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\n                || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))\n                || window.mozRequestAnimationFrame\n                || window.webkitRequestAnimationFrame)\n            )\n            || function (func) {\n                setTimeout(func, 16);\n            };\n\n\n\n/***/ }),\n/* 242 */\n/***/ (function(module, exports) {\n\n\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n/***/ }),\n/* 243 */\n/***/ (function(module, exports) {\n\n// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function () {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function (val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function (entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            entry.next = null;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function (entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function () {\n        return this._len;\n    };\n\n    /**\n     * Clear list\n     */\n    linkedListProto.clear = function () {\n        this.head = this.tail = null;\n        this._len = 0;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function (val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function (maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n\n        this._lastRemovedEntry = null;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     * @return {} Removed value\n     */\n    LRUProto.put = function (key, value) {\n        var list = this._list;\n        var map = this._map;\n        var removed = null;\n        if (map[key] == null) {\n            var len = list.len();\n            // Reuse last removed entry\n            var entry = this._lastRemovedEntry;\n\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n\n                removed = leastUsedEntry.value;\n                this._lastRemovedEntry = leastUsedEntry;\n            }\n\n            if (entry) {\n                entry.value = value;\n            }\n            else {\n                entry = new Entry(value);\n            }\n            entry.key = key;\n            list.insertEntry(entry);\n            map[key] = entry;\n        }\n\n        return removed;\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function (key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function () {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n/***/ }),\n/* 244 */\n/***/ (function(module, exports) {\n\n/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n/***/ }),\n/* 245 */\n/***/ (function(module, exports) {\n\n\n\n    var Pattern = function (image, repeat) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {image: ...}`, where this constructor will not be called.\n\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n        return ctx.createPattern(this.image, this.repeat || 'repeat');\n    };\n\n    module.exports = Pattern;\n\n\n/***/ }),\n/* 246 */\n/***/ (function(module, exports) {\n\n/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        var x = obj.x == null ? 0 : obj.x;\n        var x2 = obj.x2 == null ? 1 : obj.x2;\n        var y = obj.y == null ? 0 : obj.y;\n        var y2 = obj.y2 == null ? 0 : obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x == null ? 0.5 : obj.x;\n        var y = obj.y == null ? 0.5 : obj.y;\n        var r = obj.r == null ? 0.5 : obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * If not specified, use the boundingRect of a `displayable`.\n         * @type {Object}\n         */\n        textPositionRect: null,\n\n        /**\n         * [x, y]\n         * @type {Array.<number>}\n         */\n        textOffset: null,\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n/***/ }),\n/* 247 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var smoothSpline = __webpack_require__(300);\n    var smoothBezier = __webpack_require__(299);\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n/***/ }),\n/* 248 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var echarts = __webpack_require__(191);\n    var axisPointerModelHelper = __webpack_require__(221);\n    var axisTrigger = __webpack_require__(321);\n    var zrUtil = __webpack_require__(190);\n\n    __webpack_require__(319);\n    __webpack_require__(320);\n\n    // CartesianAxisPointer is not supposed to be required here. But consider\n    // echarts.simple.js and online build tooltip, which only require gridSimple,\n    // CartesianAxisPointer should be able to required somewhere.\n    __webpack_require__(254);\n\n    echarts.registerPreprocessor(function (option) {\n        // Always has a global axisPointerModel for default setting.\n        if (option) {\n            (!option.axisPointer || option.axisPointer.length === 0)\n                && (option.axisPointer = {});\n\n            var link = option.axisPointer.link;\n            // Normalize to array to avoid object mergin. But if link\n            // is not set, remain null/undefined, otherwise it will\n            // override existent link setting.\n            if (link && !zrUtil.isArray(link)) {\n                option.axisPointer.link = [link];\n            }\n        }\n    });\n\n    // This process should proformed after coordinate systems created\n    // and series data processed. So put it on statistic processing stage.\n    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n        // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n        // allAxesInfo should be updated when setOption performed.\n        ecModel.getComponent('axisPointer').coordSysAxesInfo\n            = axisPointerModelHelper.collect(ecModel, api);\n    });\n\n    // Broadcast to all views.\n    echarts.registerAction({\n        type: 'updateAxisPointer',\n        event: 'updateAxisPointer',\n        update: ':updateAxisPointer'\n    }, axisTrigger);\n\n\n\n/***/ }),\n/* 249 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var graphic = __webpack_require__(192);\n    var textContain = __webpack_require__(206);\n    var formatUtil = __webpack_require__(197);\n    var matrix = __webpack_require__(204);\n    var axisHelper = __webpack_require__(205);\n    var AxisBuilder = __webpack_require__(229);\n\n    var helper = {};\n\n    /**\n     * @param {module:echarts/model/Model} axisPointerModel\n     */\n    helper.buildElStyle = function (axisPointerModel) {\n        var axisPointerType = axisPointerModel.get('type');\n        var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n        var style;\n        if (axisPointerType === 'line') {\n            style = styleModel.getLineStyle();\n            style.fill = null;\n        }\n        else if (axisPointerType === 'shadow') {\n            style = styleModel.getAreaStyle();\n            style.stroke = null;\n        }\n        return style;\n    };\n\n    /**\n     * @param {Function} labelPos {align, verticalAlign, position}\n     */\n    helper.buildLabelElOption = function (\n        elOption, axisModel, axisPointerModel, api, labelPos\n    ) {\n        var value = axisPointerModel.get('value');\n        var text = helper.getValueLabel(\n            value, axisModel.axis, axisModel.ecModel,\n            axisPointerModel.get('seriesDataIndices'),\n            {\n                precision: axisPointerModel.get('label.precision'),\n                formatter: axisPointerModel.get('label.formatter')\n            }\n        );\n        var labelModel = axisPointerModel.getModel('label');\n        var textStyleModel = labelModel.getModel('textStyle');\n        var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n\n        var font = textStyleModel.getFont();\n        var textRect = textContain.getBoundingRect(\n            text, font, labelPos.textAlign, labelPos.textBaseline\n        );\n\n        var position = labelPos.position;\n        var width = textRect.width + paddings[1] + paddings[3];\n        var height = textRect.height + paddings[0] + paddings[2];\n\n        // Adjust by align.\n        var align = labelPos.align;\n        align === 'right' && (position[0] -= width);\n        align === 'center' && (position[0] -= width / 2);\n        var verticalAlign = labelPos.verticalAlign;\n        verticalAlign === 'bottom' && (position[1] -= height);\n        verticalAlign === 'middle' && (position[1] -= height / 2);\n\n        // Not overflow ec container\n        confineInContainer(position, width, height, api);\n\n        var bgColor = labelModel.get('backgroundColor');\n        if (!bgColor || bgColor === 'auto') {\n            bgColor = axisModel.get('axisLine.lineStyle.color');\n        }\n\n        elOption.label = {\n            shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},\n            position: position.slice(),\n            style: {\n                text: text,\n                textFont: font,\n                textFill: textStyleModel.getTextColor(),\n                textPosition: 'inside',\n                fill: bgColor,\n                stroke: labelModel.get('borderColor') || 'transparent',\n                lineWidth: labelModel.get('borderWidth') || 0,\n                shadowBlur: labelModel.get('shadowBlur'),\n                shadowColor: labelModel.get('shadowColor'),\n                shadowOffsetX: labelModel.get('shadowOffsetX'),\n                shadowOffsetY: labelModel.get('shadowOffsetY')\n            },\n            // Lable should be over axisPointer.\n            z2: 10\n        };\n    };\n\n    // Do not overflow ec container\n    function confineInContainer(position, width, height, api) {\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n        position[0] = Math.min(position[0] + width, viewWidth) - width;\n        position[1] = Math.min(position[1] + height, viewHeight) - height;\n        position[0] = Math.max(position[0], 0);\n        position[1] = Math.max(position[1], 0);\n    }\n\n    /**\n     * @param {number} value\n     * @param {module:echarts/coord/Axis} axis\n     * @param {module:echarts/model/Global} ecModel\n     * @param {Object} opt\n     * @param {Array.<Object>} seriesDataIndices\n     * @param {number|string} opt.precision 'auto' or a number\n     * @param {string|Function} opt.formatter label formatter\n     */\n    helper.getValueLabel = function (value, axis, ecModel, seriesDataIndices, opt) {\n        var text = axis.scale.getLabel(\n            // If `precision` is set, width can be fixed (like '12.00500'), which\n            // helps to debounce when when moving label.\n            value, {precision: opt.precision}\n        );\n        var formatter = opt.formatter;\n\n        if (formatter) {\n            var params = {\n                value: axisHelper.getAxisRawValue(axis, value),\n                seriesData: []\n            };\n            zrUtil.each(seriesDataIndices, function (idxItem) {\n                var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n                var dataIndex = idxItem.dataIndexInside;\n                var dataParams = series && series.getDataParams(dataIndex);\n                dataParams && params.seriesData.push(dataParams);\n            });\n\n            if (zrUtil.isString(formatter)) {\n                text = formatter.replace('{value}', text);\n            }\n            else if (zrUtil.isFunction(formatter)) {\n                text = formatter(params);\n            }\n        }\n\n        return text;\n    };\n\n    /**\n     * @param {module:echarts/coord/Axis} axis\n     * @param {number} value\n     * @param {Object} layoutInfo {\n     *  rotation, position, labelOffset, labelDirection, labelMargin\n     * }\n     */\n    helper.getTransformedPosition = function (axis, value, layoutInfo) {\n        var transform = matrix.create();\n        matrix.rotate(transform, transform, layoutInfo.rotation);\n        matrix.translate(transform, transform, layoutInfo.position);\n\n        return graphic.applyTransform([\n            axis.dataToCoord(value),\n            (layoutInfo.labelOffset || 0)\n                + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)\n        ], transform);\n    };\n\n    helper.buildCartesianSingleLabelElOption = function (\n        value, elOption, layoutInfo, axisModel, axisPointerModel, api\n    ) {\n        var textLayout = AxisBuilder.innerTextLayout(\n            layoutInfo.rotation, 0, layoutInfo.labelDirection\n        );\n        layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n        helper.buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n            position: helper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n            align: textLayout.textAlign,\n            verticalAlign: textLayout.textVerticalAlign\n        });\n    };\n\n    /**\n     * @param {Array.<number>} p1\n     * @param {Array.<number>} p2\n     * @param {number} [xDimIndex=0] or 1\n     */\n    helper.makeLineShape = function (p1, p2, xDimIndex) {\n        xDimIndex = xDimIndex || 0;\n        return {\n            x1: p1[xDimIndex],\n            y1: p1[1 - xDimIndex],\n            x2: p2[xDimIndex],\n            y2: p2[1 - xDimIndex]\n        };\n    };\n\n    /**\n     * @param {Array.<number>} xy\n     * @param {Array.<number>} wh\n     * @param {number} [xDimIndex=0] or 1\n     */\n    helper.makeRectShape = function (xy, wh, xDimIndex) {\n        xDimIndex = xDimIndex || 0;\n        return {\n            x: xy[xDimIndex],\n            y: xy[1 - xDimIndex],\n            width: wh[xDimIndex],\n            height: wh[1 - xDimIndex]\n        };\n    };\n\n    helper.makeSectorShape = function (cx, cy, r0, r, startAngle, endAngle) {\n        return {\n            cx: cx,\n            cy: cy,\n            r0: r0,\n            r: r,\n            startAngle: startAngle,\n            endAngle: endAngle,\n            clockwise: true\n        };\n    };\n\n    module.exports = helper;\n\n\n/***/ }),\n/* 250 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var modelUtil = __webpack_require__(194);\n\n    /**\n     * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}\n     * @param {module:echarts/model/Global} ecModel\n     * @return {Object} {point: [x, y], el: ...} point Will not be null.\n     */\n    module.exports = function (finder, ecModel) {\n        var point = [];\n        var seriesIndex = finder.seriesIndex;\n        var seriesModel;\n        if (seriesIndex == null || !(\n            seriesModel = ecModel.getSeriesByIndex(seriesIndex)\n        )) {\n            return {point: []};\n        }\n\n        var data = seriesModel.getData();\n        var dataIndex = modelUtil.queryDataIndex(data, finder);\n        if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n            return {point: []};\n        }\n\n        var el = data.getItemGraphicEl(dataIndex);\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (seriesModel.getTooltipPosition) {\n            point = seriesModel.getTooltipPosition(dataIndex) || [];\n        }\n        else if (coordSys && coordSys.dataToPoint) {\n            point = coordSys.dataToPoint(\n                data.getValues(\n                    zrUtil.map(coordSys.dimensions, function (dim) {\n                        return seriesModel.coordDimToDataDim(dim)[0];\n                    }), dataIndex, true\n                )\n            ) || [];\n        }\n        else if (el) {\n            // Use graphic bounding rect\n            var rect = el.getBoundingRect().clone();\n            rect.applyTransform(el.transform);\n            point = [\n                rect.x + rect.width / 2,\n                rect.y + rect.height / 2\n            ];\n        }\n\n        return {point: point, el: el};\n    };\n\n\n\n\n/***/ }),\n/* 251 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var env = __webpack_require__(198);\n    var zrUtil = __webpack_require__(190);\n    var get = __webpack_require__(194).makeGetter();\n\n    var each = zrUtil.each;\n\n    var globalListener = {};\n\n    /**\n     * @param {string} key\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Function} handler\n     *      param: {string} currTrigger\n     *      param: {Array.<number>} point\n     */\n    globalListener.register = function (key, api, handler) {\n        if (env.node) {\n            return;\n        }\n\n        var zr = api.getZr();\n        get(zr).records || (get(zr).records = {});\n\n        initGlobalListeners(zr, api);\n\n        var record = get(zr).records[key] || (get(zr).records[key] = {});\n        record.handler = handler;\n    };\n\n    function initGlobalListeners(zr, api) {\n        if (get(zr).initialized) {\n            return;\n        }\n\n        get(zr).initialized = true;\n\n        useHandler('click', zrUtil.curry(doEnter, 'click'));\n        useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove'));\n        // useHandler('mouseout', onLeave);\n        useHandler('globalout', onLeave);\n\n        function useHandler(eventType, cb) {\n            zr.on(eventType, function (e) {\n                var dis = makeDispatchAction(api);\n\n                each(get(zr).records, function (record) {\n                    record && cb(record, e, dis.dispatchAction);\n                });\n\n                dispatchTooltipFinally(dis.pendings, api);\n            });\n        }\n    }\n\n    function dispatchTooltipFinally(pendings, api) {\n        var showLen = pendings.showTip.length;\n        var hideLen = pendings.hideTip.length;\n\n        var actuallyPayload;\n        if (showLen) {\n            actuallyPayload = pendings.showTip[showLen - 1];\n        }\n        else if (hideLen) {\n            actuallyPayload = pendings.hideTip[hideLen - 1];\n        }\n        if (actuallyPayload) {\n            actuallyPayload.dispatchAction = null;\n            api.dispatchAction(actuallyPayload);\n        }\n    }\n\n    function onLeave(record, e, dispatchAction) {\n        record.handler('leave', null, dispatchAction);\n    }\n\n    function doEnter(currTrigger, record, e, dispatchAction) {\n        record.handler(currTrigger, e, dispatchAction);\n    }\n\n    function makeDispatchAction(api) {\n        var pendings = {\n            showTip: [],\n            hideTip: []\n        };\n        // FIXME\n        // better approach?\n        // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\n        // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\n        // So we have to add \"final stage\" to merge those dispatched actions.\n        var dispatchAction = function (payload) {\n            var pendingList = pendings[payload.type];\n            if (pendingList) {\n                pendingList.push(payload);\n            }\n            else {\n                payload.dispatchAction = dispatchAction;\n                api.dispatchAction(payload);\n            }\n        };\n\n        return {\n            dispatchAction: dispatchAction,\n            pendings: pendings\n        };\n    }\n\n    /**\n     * @param {string} key\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    globalListener.unregister = function (key, api) {\n        if (env.node) {\n            return;\n        }\n        var zr = api.getZr();\n        var record = (get(zr).records || {})[key];\n        if (record) {\n            get(zr).records[key] = null;\n        }\n    };\n\n    module.exports = globalListener;\n\n\n/***/ }),\n/* 252 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    function defaultKeyGetter(item) {\n        return item;\n    }\n\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n\n    DataDiffer.prototype = {\n\n        constructor: DataDiffer,\n\n        /**\n         * Callback function when add a data\n         */\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n\n        /**\n         * Callback function when update a data\n         */\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n\n        /**\n         * Callback function when remove a data\n         */\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    }\n                    else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                }\n                else {\n                    this._remove && this._remove(i);\n                }\n            }\n\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    }\n                    else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            // Add prefix to avoid conflict with Object.prototype.\n            var key = '_ec_' + keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            }\n            else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n\n    module.exports = DataDiffer;\n\n\n/***/ }),\n/* 253 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var helper = {};\n\n    /**\n     * @param {Object} opt {labelInside}\n     * @return {Object} {\n     *  position, rotation, labelDirection, labelOffset,\n     *  tickDirection, labelRotate, labelInterval, z2\n     * }\n     */\n    helper.layout = function (gridModel, axisModel, opt) {\n        opt = opt || {};\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n\n        // [left, right, top, bottom]\n        var rect = grid.getRect();\n        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\n        var axisOffset = axisModel.get('offset') || 0;\n\n        var posMap = {\n            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },\n            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }\n        };\n\n        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\n        function getZero(dim, val) {\n            var theAxis = grid.getAxis(dim);\n            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n        }\n\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n        ];\n\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\n        // Tick and label direction, x y is axisDim\n        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        layout.labelOffset = axis.onZero ? posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero : 0;\n\n        if (axisModel.get('axisTick.inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n\n        // Special label rotation\n        var labelRotate = axisModel.get('axisLabel.rotate');\n        layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate;\n\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n\n        return layout;\n    };\n\n    module.exports = helper;\n\n\n\n/***/ }),\n/* 254 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var graphic = __webpack_require__(192);\n    var BaseAxisPointer = __webpack_require__(267);\n    var viewHelper = __webpack_require__(249);\n    var cartesianAxisHelper = __webpack_require__(253);\n    var AxisView = __webpack_require__(233);\n\n    var CartesianAxisPointer = BaseAxisPointer.extend({\n\n        /**\n         * @override\n         */\n        makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n            var axis = axisModel.axis;\n            var grid = axis.grid;\n            var axisPointerType = axisPointerModel.get('type');\n            var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n            var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n\n            if (axisPointerType && axisPointerType !== 'none') {\n                var elStyle = viewHelper.buildElStyle(axisPointerModel);\n                var pointerOption = pointerShapeBuilder[axisPointerType](\n                    axis, pixelValue, otherExtent, elStyle\n                );\n                pointerOption.style = elStyle;\n                elOption.graphicKey = pointerOption.type;\n                elOption.pointer = pointerOption;\n            }\n\n            var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);\n            viewHelper.buildCartesianSingleLabelElOption(\n                value, elOption, layoutInfo, axisModel, axisPointerModel, api\n            );\n        },\n\n        /**\n         * @override\n         */\n        getHandleTransform: function (value, axisModel, axisPointerModel) {\n            var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {\n                labelInside: false\n            });\n            layoutInfo.labelMargin = axisPointerModel.get('handle.margin');\n            return {\n                position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n                rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n            };\n        },\n\n        /**\n         * @override\n         */\n        updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {\n            var axis = axisModel.axis;\n            var grid = axis.grid;\n            var axisExtent = axis.getGlobalExtent(true);\n            var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n            var dimIndex = axis.dim === 'x' ? 0 : 1;\n\n            var currPosition = transform.position;\n            currPosition[dimIndex] += delta[dimIndex];\n            currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n            currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n\n            var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n            var cursorPoint = [cursorOtherValue, cursorOtherValue];\n            cursorPoint[dimIndex] = currPosition[dimIndex];\n\n            // Make tooltip do not overlap axisPointer and in the middle of the grid.\n            var tooltipOptions = [{verticalAlign: 'middle'}, {align: 'center'}];\n\n            return {\n                position: currPosition,\n                rotation: transform.rotation,\n                cursorPoint: cursorPoint,\n                tooltipOption: tooltipOptions[dimIndex]\n            };\n        }\n\n    });\n\n    function getCartesian(grid, axis) {\n        var opt = {};\n        opt[axis.dim + 'AxisIndex'] = axis.index;\n        return grid.getCartesian(opt);\n    }\n\n    var pointerShapeBuilder = {\n\n        line: function (axis, pixelValue, otherExtent, elStyle) {\n            var targetShape = viewHelper.makeLineShape(\n                [pixelValue, otherExtent[0]],\n                [pixelValue, otherExtent[1]],\n                getAxisDimIndex(axis)\n            );\n            graphic.subPixelOptimizeLine({\n                shape: targetShape,\n                style: elStyle\n            });\n            return {\n                type: 'Line',\n                shape: targetShape\n            };\n        },\n\n        shadow: function (axis, pixelValue, otherExtent, elStyle) {\n            var bandWidth = axis.getBandWidth();\n            var span = otherExtent[1] - otherExtent[0];\n            return {\n                type: 'Rect',\n                shape: viewHelper.makeRectShape(\n                    [pixelValue - bandWidth / 2, otherExtent[0]],\n                    [bandWidth, span],\n                    getAxisDimIndex(axis)\n                )\n            };\n        }\n    };\n\n    function getAxisDimIndex(axis) {\n        return axis.dim === 'x' ? 0 : 1;\n    }\n\n    AxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);\n\n    module.exports = CartesianAxisPointer;\n\n\n/***/ }),\n/* 255 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var graphic = __webpack_require__(192);\n    var zrUtil = __webpack_require__(190);\n    var echarts = __webpack_require__(191);\n\n    __webpack_require__(317);\n\n    __webpack_require__(326);\n\n    // Grid view\n    echarts.extendComponentView({\n\n        type: 'grid',\n\n        render: function (gridModel, ecModel) {\n            this.group.removeAll();\n            if (gridModel.get('show')) {\n                this.group.add(new graphic.Rect({\n                    shape: gridModel.coordinateSystem.getRect(),\n                    style: zrUtil.defaults({\n                        fill: gridModel.get('backgroundColor')\n                    }, gridModel.getItemStyle()),\n                    silent: true,\n                    z2: -1\n                }));\n            }\n        }\n\n    });\n\n    echarts.registerPreprocessor(function (option) {\n        // Only create grid when need\n        if (option.xAxis && option.yAxis && !option.grid) {\n            option.grid = {};\n        }\n    });\n\n\n/***/ }),\n/* 256 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var Group = __webpack_require__(215);\n    var componentUtil = __webpack_require__(225);\n    var clazzUtil = __webpack_require__(201);\n\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n\n    Component.prototype = {\n\n        constructor: Component,\n\n        init: function (ecModel, api) {},\n\n        render: function (componentModel, ecModel, api, payload) {},\n\n        dispose: function () {}\n\n    };\n\n    var componentProto = Component.prototype;\n    componentProto.updateView\n        = componentProto.updateLayout\n        = componentProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            // Do nothing;\n        };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\n    module.exports = Component;\n\n\n/***/ }),\n/* 257 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = __webpack_require__(195);\n    var curve = __webpack_require__(207);\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * `min``max`\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points \n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * (p0, p1, p2, p3)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * (p0, p1, p2)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * `min``max`\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n/***/ }),\n/* 258 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var ComponentModel = __webpack_require__(202);\n    var zrUtil = __webpack_require__(190);\n    var axisModelCreator = __webpack_require__(316);\n\n    var AxisModel = ComponentModel.extend({\n\n        type: 'cartesian2dAxis',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Axis2D}\n         */\n        axis: null,\n\n        /**\n         * @override\n         */\n        init: function () {\n            AxisModel.superApply(this, 'init', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function () {\n            AxisModel.superApply(this, 'mergeOption', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        restoreData: function () {\n            AxisModel.superApply(this, 'restoreData', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         * @return {module:echarts/model/Component}\n         */\n        getCoordSysModel: function () {\n            return this.ecModel.queryComponents({\n                mainType: 'grid',\n                index: this.option.gridIndex,\n                id: this.option.gridId\n            })[0];\n        }\n\n    });\n\n    function getAxisType(axisDim, option) {\n        // Default axis with data is category axis\n        return option.type || (option.data ? 'category' : 'value');\n    }\n\n    zrUtil.merge(AxisModel.prototype, __webpack_require__(230));\n\n    var extraOption = {\n        // gridIndex: 0,\n        // gridId: '',\n\n        // Offset is for multiple axis on the same position\n        offset: 0\n    };\n\n    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\n    module.exports = AxisModel;\n\n\n/***/ }),\n/* 259 */\n/***/ (function(module, exports) {\n\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n/***/ }),\n/* 260 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var curve = __webpack_require__(207);\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n/***/ }),\n/* 261 */\n/***/ (function(module, exports) {\n\n\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n/***/ }),\n/* 262 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var Gradient = __webpack_require__(224);\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'linear', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n/***/ }),\n/* 263 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = __webpack_require__(223);\n    var zrUtil = __webpack_require__(190);\n    var textContain = __webpack_require__(206);\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                // FIXME in text contain default is top\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    // Fill after stroke so the outline will not cover the main part.\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (!this._rect) {\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                if (style.hasStroke()) {\n                    var w = style.lineWidth;\n                    rect.x -= w / 2;\n                    rect.y -= w / 2;\n                    rect.width += w;\n                    rect.height += w;\n                }\n                this._rect = rect;\n            }\n\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n/***/ }),\n/* 264 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = __webpack_require__(206);\n    var BoundingRect = __webpack_require__(200);\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var textOffset = style.textOffset;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n            rect = style.textPositionRect || rect;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            if (textOffset) {\n                x += textOffset[0];\n                y += textOffset[1];\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                // Fill after stroke so the outline will not cover the main part.\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                textFill && ctx.fillText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n/***/ }),\n/* 265 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = __webpack_require__(244);\n    var env = __webpack_require__(198);\n    var zrUtil = __webpack_require__(190);\n\n    var Handler = __webpack_require__(284);\n    var Storage = __webpack_require__(287);\n    var Animation = __webpack_require__(288);\n    var HandlerProxy = __webpack_require__(295);\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: __webpack_require__(286)\n    };\n\n    var instances = {};    // ZRendermap\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.5.2';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        // TODO WebGL\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        //  storage.delFromStorage, \n        // FIXME ugly\n        var oldDelFromStorage = storage.delFromStorage;\n        var oldAddToStorage = storage.addToStorage;\n\n        storage.delFromStorage = function (el) {\n            oldDelFromStorage.call(storage, el);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToStorage = function (el) {\n            oldAddToStorage.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * \n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, dpr) {\n            return this.painter.pathToImage(e, dpr);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Find hovered element\n         * @param {number} x\n         * @param {number} y\n         * @return {Object} {target, topTarget}\n         */\n        findHover: function (x, y) {\n            return this.handler.findHover(x, y);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n/***/ }),\n/* 266 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var echartsAPIList = [\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed',\n        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',\n        'getViewOfComponentModel', 'getViewOfSeriesModel'\n    ];\n    // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js\n\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n\n    module.exports = ExtensionAPI;\n\n\n/***/ }),\n/* 267 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var clazzUtil = __webpack_require__(201);\n    var graphic = __webpack_require__(192);\n    var get = __webpack_require__(194).makeGetter();\n    var axisPointerModelHelper = __webpack_require__(221);\n    var eventTool = __webpack_require__(209);\n    var throttle = __webpack_require__(231);\n\n    var clone = zrUtil.clone;\n    var bind = zrUtil.bind;\n\n    /**\n     * Base axis pointer class in 2D.\n     * Implemenents {module:echarts/component/axis/IAxisPointer}.\n     */\n    function BaseAxisPointer () {\n    }\n\n    BaseAxisPointer.prototype = {\n\n        /**\n         * @private\n         */\n        _group: null,\n\n        /**\n         * @private\n         */\n        _lastGraphicKey: null,\n\n        /**\n         * @private\n         */\n        _handle: null,\n\n        /**\n         * @private\n         */\n        _dragging: false,\n\n        /**\n         * @private\n         */\n        _lastValue: null,\n\n        /**\n         * @private\n         */\n        _lastStatus: null,\n\n        /**\n         * @private\n         */\n        _payloadInfo: null,\n\n        /**\n         * In px, arbitrary value. Do not set too small,\n         * no animation is ok for most cases.\n         * @protected\n         */\n        animationThreshold: 15,\n\n        /**\n         * @implement\n         */\n        render: function (axisModel, axisPointerModel, api, forceRender) {\n            var value = axisPointerModel.get('value');\n            var status = axisPointerModel.get('status');\n\n            // Bind them to `this`, not in closure, otherwise they will not\n            // be replaced when user calling setOption in not merge mode.\n            this._axisModel = axisModel;\n            this._axisPointerModel = axisPointerModel;\n            this._api = api;\n\n            // Optimize: `render` will be called repeatly during mouse move.\n            // So it is power consuming if performing `render` each time,\n            // especially on mobile device.\n            if (!forceRender\n                && this._lastValue === value\n                && this._lastStatus === status\n            ) {\n                return;\n            }\n            this._lastValue = value;\n            this._lastStatus = status;\n\n            var group = this._group;\n            var handle = this._handle;\n\n            if (!status || status === 'hide') {\n                // Do not clear here, for animation better.\n                group && group.hide();\n                handle && handle.hide();\n                return;\n            }\n            group && group.show();\n            handle && handle.show();\n\n            // Otherwise status is 'show'\n            var elOption = {};\n            this.makeElOption(elOption, value, axisModel, axisPointerModel, api);\n\n            // Enable change axis pointer type.\n            var graphicKey = elOption.graphicKey;\n            if (graphicKey !== this._lastGraphicKey) {\n                this.clear(api);\n            }\n            this._lastGraphicKey = graphicKey;\n\n            var moveAnimation = this._moveAnimation =\n                this.determineAnimation(axisModel, axisPointerModel);\n\n            if (!group) {\n                group = this._group = new graphic.Group();\n                this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n                this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n                api.getZr().add(group);\n            }\n            else {\n                var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);\n                this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);\n                this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n            }\n\n            updateMandatoryProps(group, axisPointerModel, true);\n\n            this._renderHandle(value);\n        },\n\n        /**\n         * @implement\n         */\n        remove: function (api) {\n            this.clear(api);\n        },\n\n        /**\n         * @implement\n         */\n        dispose: function (api) {\n            this.clear(api);\n        },\n\n        /**\n         * @protected\n         */\n        determineAnimation: function (axisModel, axisPointerModel) {\n            var animation = axisPointerModel.get('animation');\n            var axis = axisModel.axis;\n            var isCategoryAxis = axis.type === 'category';\n            var useSnap = axisPointerModel.get('snap');\n\n            // Value axis without snap always do not snap.\n            if (!useSnap && !isCategoryAxis) {\n                return false;\n            }\n\n            if (animation === 'auto' || animation == null) {\n                var animationThreshold = this.animationThreshold;\n                if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n                    return true;\n                }\n\n                // It is important to auto animation when snap used. Consider if there is\n                // a dataZoom, animation will be disabled when too many points exist, while\n                // it will be enabled for better visual effect when little points exist.\n                if (useSnap) {\n                    var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;\n                    var axisExtent = axis.getExtent();\n                    // Approximate band width\n                    return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n                }\n\n                return false;\n            }\n\n            return animation === true;\n        },\n\n        /**\n         * add {pointer, label, graphicKey} to elOption\n         * @protected\n         */\n        makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n            // Shoule be implemenented by sub-class.\n        },\n\n        /**\n         * @protected\n         */\n        createPointerEl: function (group, elOption, axisModel, axisPointerModel) {\n            var pointerOption = elOption.pointer;\n            if (pointerOption) {\n                var pointerEl = get(group).pointerEl = new graphic[pointerOption.type](\n                    clone(elOption.pointer)\n                );\n                group.add(pointerEl);\n            }\n        },\n\n        /**\n         * @protected\n         */\n        createLabelEl: function (group, elOption, axisModel, axisPointerModel) {\n            if (elOption.label) {\n                var labelEl = get(group).labelEl = new graphic.Rect(\n                    clone(elOption.label)\n                );\n\n                group.add(labelEl);\n                updateLabelShowHide(labelEl, axisPointerModel);\n            }\n        },\n\n        /**\n         * @protected\n         */\n        updatePointerEl: function (group, elOption, updateProps) {\n            var pointerEl = get(group).pointerEl;\n            if (pointerEl) {\n                pointerEl.setStyle(elOption.pointer.style);\n                updateProps(pointerEl, {shape: elOption.pointer.shape});\n            }\n        },\n\n        /**\n         * @protected\n         */\n        updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {\n            var labelEl = get(group).labelEl;\n            if (labelEl) {\n                labelEl.setStyle(elOption.label.style);\n                updateProps(labelEl, {\n                    // Consider text length change in vertical axis, animation should\n                    // be used on shape, otherwise the effect will be weird.\n                    shape: elOption.label.shape,\n                    position: elOption.label.position\n                });\n\n                updateLabelShowHide(labelEl, axisPointerModel);\n            }\n        },\n\n        /**\n         * @private\n         */\n        _renderHandle: function (value) {\n            if (this._dragging || !this.updateHandleTransform) {\n                return;\n            }\n\n            var axisPointerModel = this._axisPointerModel;\n            var zr = this._api.getZr();\n            var handle = this._handle;\n            var handleModel = axisPointerModel.getModel('handle');\n\n            var status = axisPointerModel.get('status');\n            if (!handleModel.get('show') || !status || status === 'hide') {\n                handle && zr.remove(handle);\n                this._handle = null;\n                return;\n            }\n\n            var isInit;\n            if (!this._handle) {\n                isInit = true;\n                handle = this._handle = createIcon(handleModel, {\n                    onmousemove: function (e) {\n                        // Fot mobile devicem, prevent screen slider on the button.\n                        eventTool.stop(e.event);\n                    },\n                    onmousedown: bind(this._onHandleDragMove, this, 0, 0),\n                    drift: bind(this._onHandleDragMove, this),\n                    ondragend: bind(this._onHandleDragEnd, this)\n                });\n                zr.add(handle);\n            }\n\n            updateMandatoryProps(handle, axisPointerModel, false);\n\n            // update style\n            var includeStyles = [\n                'color', 'borderColor', 'borderWidth', 'opacity',\n                'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'\n            ];\n            handle.setStyle(handleModel.getItemStyle(null, includeStyles));\n\n            // update position\n            var handleSize = handleModel.get('size');\n            if (!zrUtil.isArray(handleSize)) {\n                handleSize = [handleSize, handleSize];\n            }\n            handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);\n\n            throttle.createOrUpdate(\n                this,\n                '_doDispatchAxisPointer',\n                handleModel.get('throttle') || 0,\n                'fixRate'\n            );\n\n            this._moveHandleToValue(value, isInit);\n        },\n\n        /**\n         * @private\n         */\n        _moveHandleToValue: function (value, isInit) {\n            updateProps(\n                this._axisPointerModel,\n                !isInit && this._moveAnimation,\n                this._handle,\n                getHandleTransProps(this.getHandleTransform(\n                    value, this._axisModel, this._axisPointerModel\n                ))\n            );\n        },\n\n        /**\n         * @private\n         */\n        _onHandleDragMove: function (dx, dy) {\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            this._dragging = true;\n\n            // Persistent for throttle.\n            var trans = this.updateHandleTransform(\n                getHandleTransProps(handle),\n                [dx, dy],\n                this._axisModel,\n                this._axisPointerModel\n            );\n            this._payloadInfo = trans;\n\n            handle.stopAnimation();\n            handle.attr(getHandleTransProps(trans));\n            get(handle).lastProp = null;\n\n            this._doDispatchAxisPointer();\n        },\n\n        /**\n         * Throttled method.\n         * @private\n         */\n        _doDispatchAxisPointer: function () {\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            var payloadInfo = this._payloadInfo;\n            var axisModel = this._axisModel;\n            this._api.dispatchAction({\n                type: 'updateAxisPointer',\n                x: payloadInfo.cursorPoint[0],\n                y: payloadInfo.cursorPoint[1],\n                tooltipOption: payloadInfo.tooltipOption,\n                axesInfo: [{\n                    axisDim: axisModel.axis.dim,\n                    axisIndex: axisModel.componentIndex\n                }]\n            });\n        },\n\n        /**\n         * @private\n         */\n        _onHandleDragEnd: function (moveAnimation) {\n            this._dragging = false;\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            var value = this._axisPointerModel.get('value');\n            // Consider snap or categroy axis, handle may be not consistent with\n            // axisPointer. So move handle to align the exact value position when\n            // drag ended.\n            this._moveHandleToValue(value);\n\n            // For the effect: tooltip will be shown when finger holding on handle\n            // button, and will be hidden after finger left handle button.\n            this._api.dispatchAction({\n                type: 'hideTip'\n            });\n        },\n\n        /**\n         * Should be implemenented by sub-class if support `handle`.\n         * @protected\n         * @param {number} value\n         * @param {module:echarts/model/Model} axisModel\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @return {Object} {position: [x, y], rotation: 0}\n         */\n        getHandleTransform: null,\n\n        /**\n         * * Should be implemenented by sub-class if support `handle`.\n         * @protected\n         * @param {Object} transform {position, rotation}\n         * @param {Array.<number>} delta [dx, dy]\n         * @param {module:echarts/model/Model} axisModel\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}\n         */\n        updateHandleTransform: null,\n\n        /**\n         * @private\n         */\n        clear: function (api) {\n            this._lastValue = null;\n            this._lastStatus = null;\n\n            var zr = api.getZr();\n            var group = this._group;\n            var handle = this._handle;\n            if (zr && group) {\n                this._lastGraphicKey = null;\n                group && zr.remove(group);\n                handle && zr.remove(handle);\n                this._group = null;\n                this._handle = null;\n                this._payloadInfo = null;\n            }\n        },\n\n        /**\n         * @protected\n         */\n        doClear: function () {\n            // Implemented by sub-class if necessary.\n        },\n\n        /**\n         * @protected\n         * @param {Array.<number>} xy\n         * @param {Array.<number>} wh\n         * @param {number} [xDimIndex=0] or 1\n         */\n        buildLabel: function (xy, wh, xDimIndex) {\n            xDimIndex = xDimIndex || 0;\n            return {\n                x: xy[xDimIndex],\n                y: xy[1 - xDimIndex],\n                width: wh[xDimIndex],\n                height: wh[1 - xDimIndex]\n            };\n        }\n    };\n\n    BaseAxisPointer.prototype.constructor = BaseAxisPointer;\n\n\n    function updateProps(animationModel, moveAnimation, el, props) {\n        // Animation optimize.\n        if (!propsEqual(get(el).lastProp, props)) {\n            get(el).lastProp = props;\n            moveAnimation\n                ? graphic.updateProps(el, props, animationModel)\n                : (el.stopAnimation(), el.attr(props));\n        }\n    }\n\n    function propsEqual(lastProps, newProps) {\n        if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {\n            var equals = true;\n            zrUtil.each(newProps, function (item, key) {\n                equals &= propsEqual(lastProps[key], item);\n            });\n            return !!equals;\n        }\n        else {\n            return lastProps === newProps;\n        }\n    }\n\n    function updateLabelShowHide(labelEl, axisPointerModel) {\n        labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();\n    }\n\n    function getHandleTransProps(trans) {\n        return {\n            position: trans.position.slice(),\n            rotation: trans.rotation || 0\n        };\n    }\n\n    function createIcon(handleModel, handlers) {\n        var iconStr = handleModel.get('icon');\n        var style = {\n            x: -1, y: -1, width: 2, height: 2\n        };\n        var opt = zrUtil.extend({\n            style: {\n                strokeNoScale: true\n            },\n            rectHover: true,\n            cursor: 'move',\n            draggable: true\n        }, handlers);\n\n        return iconStr.indexOf('image://') === 0\n            ? (\n                style.image = iconStr.slice(8),\n                opt.style = style,\n                new graphic.Image(opt)\n            )\n            : graphic.makePath(\n                iconStr.replace('path://', ''),\n                opt,\n                style,\n                'center'\n            );\n    }\n\n    function updateMandatoryProps(group, axisPointerModel, silent) {\n        var z = axisPointerModel.get('z');\n        var zlevel = axisPointerModel.get('zlevel');\n\n        group && group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n                el.silent = silent;\n            }\n        });\n    }\n\n    clazzUtil.enableClassExtend(BaseAxisPointer);\n\n    module.exports = BaseAxisPointer;\n\n\n/***/ }),\n/* 268 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var createListFromArray = __webpack_require__(228);\n    var symbolUtil = __webpack_require__(219);\n    var axisHelper = __webpack_require__(205);\n    var axisModelCommonMixin = __webpack_require__(230);\n    var Model = __webpack_require__(199);\n    var util = __webpack_require__(190);\n\n    module.exports = {\n        /**\n         * Create a muti dimension List structure from seriesModel.\n         * @param  {module:echarts/model/Model} seriesModel\n         * @return {module:echarts/data/List} list\n         */\n        createList: function (seriesModel) {\n            var data = seriesModel.get('data');\n            return createListFromArray(data, seriesModel, seriesModel.ecModel);\n        },\n\n        /**\n         * @see {module:echarts/data/helper/completeDimensions}\n         */\n        completeDimensions: __webpack_require__(218),\n\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @see http://echarts.baidu.com/option.html#series-scatter.symbol\n         * @param {string} symbolDesc\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: symbolUtil.createSymbol,\n\n        /**\n         * Create scale\n         * @param {Array.<number>} dataExtent\n         * @param {Object|module:echarts/Model} option\n         */\n        createScale: function (dataExtent, option) {\n            var axisModel = option;\n            if (!(option instanceof Model)) {\n                axisModel = new Model(option);\n                util.mixin(axisModel, axisModelCommonMixin);\n            }\n\n            var scale = axisHelper.createScaleByModel(axisModel);\n            scale.setExtent(dataExtent[0], dataExtent[1]);\n\n            axisHelper.niceScaleExtent(scale, axisModel);\n            return scale;\n        },\n\n        /**\n         * Mixin common methods to axis model,\n         *\n         * Inlcude methods\n         * `getFormattedLabels() => Array.<string>`\n         * `getCategories() => Array.<string>`\n         * `getMin(origin: boolean) => number`\n         * `getMax(origin: boolean) => number`\n         * `getNeedCrossZero() => boolean`\n         * `setRange(start: number, end: number)`\n         * `resetRange()`\n         */\n        mixinAxisModelCommonMethods: function (Model) {\n            util.mixin(Model, axisModelCommonMixin);\n        }\n    };\n\n\n/***/ }),\n/* 269 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var graphic = __webpack_require__(192);\n    var zrUtil = __webpack_require__(190);\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    module.exports = function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n            style: {\n                fill: opts.maskColor\n            },\n            zlevel: opts.zlevel,\n            z: 10000\n        });\n        var arc = new graphic.Arc({\n            shape: {\n                startAngle: -PI / 2,\n                endAngle: -PI / 2 + 0.1,\n                r: 10\n            },\n            style: {\n                stroke: opts.color,\n                lineCap: 'round',\n                lineWidth: 5\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n        var labelRect = new graphic.Rect({\n            style: {\n                fill: 'none',\n                text: opts.text,\n                textPosition: 'right',\n                textDistance: 10,\n                textFill: opts.textColor\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n\n        arc.animateShape(true)\n            .when(1000, {\n                endAngle: PI * 3 / 2\n            })\n            .start('circularInOut');\n        arc.animateShape(true)\n            .when(1000, {\n                startAngle: PI * 3 / 2\n            })\n            .delay(300)\n            .start('circularInOut');\n\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n\n\n/***/ }),\n/* 270 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n\n    /**\n     * Caution: If the mechanism should be changed some day, these cases\n     * should be considered:\n     *\n     * (1) In `merge option` mode, if using the same option to call `setOption`\n     * many times, the result should be the same (try our best to ensure that).\n     * (2) In `merge option` mode, if a component has no id/name specified, it\n     * will be merged by index, and the result sequence of the components is\n     * consistent to the original sequence.\n     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n     * `mergeOption` in module:echarts/model/OptionManager.\n     */\n\n    var zrUtil = __webpack_require__(190);\n    var modelUtil = __webpack_require__(194);\n    var Model = __webpack_require__(199);\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n\n    var ComponentModel = __webpack_require__(202);\n\n    var globalDefault = __webpack_require__(272);\n\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n\n        constructor: GlobalModel,\n\n        init: function (option, parentModel, theme, optionManager) {\n            theme = theme || {};\n\n            this.option = null; // Mark as not initialized.\n\n            /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n            this._theme = new Model(theme);\n\n            /**\n             * @type {module:echarts/model/OptionManager}\n             */\n            this._optionManager = optionManager;\n        },\n\n        setOption: function (option, optionPreprocessorFuncs) {\n            zrUtil.assert(\n                !(OPTION_INNER_KEY in option),\n                'please use chart.getOption()'\n            );\n\n            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n            this.resetOption(null);\n        },\n\n        /**\n         * @param {string} type null/undefined: reset all.\n         *                      'recreate': force recreate all.\n         *                      'timeline': only reset timeline option\n         *                      'media': only reset media query option\n         * @return {boolean} Whether option changed.\n         */\n        resetOption: function (type) {\n            var optionChanged = false;\n            var optionManager = this._optionManager;\n\n            if (!type || type === 'recreate') {\n                var baseOption = optionManager.mountOption(type === 'recreate');\n\n                if (!this.option || type === 'recreate') {\n                    initBase.call(this, baseOption);\n                }\n                else {\n                    this.restoreData();\n                    this.mergeOption(baseOption);\n                }\n                optionChanged = true;\n            }\n\n            if (type === 'timeline' || type === 'media') {\n                this.restoreData();\n            }\n\n            if (!type || type === 'recreate' || type === 'timeline') {\n                var timelineOption = optionManager.getTimelineOption(this);\n                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n            }\n\n            if (!type || type === 'recreate' || type === 'media') {\n                var mediaOptions = optionManager.getMediaOption(this, this._api);\n                if (mediaOptions.length) {\n                    each(mediaOptions, function (mediaOption) {\n                        this.mergeOption(mediaOption, optionChanged = true);\n                    }, this);\n                }\n            }\n\n            return optionChanged;\n        },\n\n        /**\n         * @protected\n         */\n        mergeOption: function (newOption) {\n            var option = this.option;\n            var componentsMap = this._componentsMap;\n            var newCptTypes = [];\n\n            //  component model  merge\n            each(newOption, function (componentOption, mainType) {\n                if (componentOption == null) {\n                    return;\n                }\n\n                if (!ComponentModel.hasClass(mainType)) {\n                    option[mainType] = option[mainType] == null\n                        ? zrUtil.clone(componentOption)\n                        : zrUtil.merge(option[mainType], componentOption, true);\n                }\n                else {\n                    newCptTypes.push(mainType);\n                }\n            });\n\n            // FIXME OPTION \n            ComponentModel.topologicalTravel(\n                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n            );\n\n            this._seriesIndices = this._seriesIndices || [];\n\n            function visitComponent(mainType, dependencies) {\n                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\n                var mapResult = modelUtil.mappingToExists(\n                    componentsMap.get(mainType), newCptOptionList\n                );\n\n                modelUtil.makeIdAndName(mapResult);\n\n                // Set mainType and complete subType.\n                each(mapResult, function (item, index) {\n                    var opt = item.option;\n                    if (isObject(opt)) {\n                        item.keyInfo.mainType = mainType;\n                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n                    }\n                });\n\n                var dependentModels = getComponentsByTypes(\n                    componentsMap, dependencies\n                );\n\n                option[mainType] = [];\n                componentsMap.set(mainType, []);\n\n                each(mapResult, function (resultItem, index) {\n                    var componentModel = resultItem.exist;\n                    var newCptOption = resultItem.option;\n\n                    zrUtil.assert(\n                        isObject(newCptOption) || componentModel,\n                        'Empty component definition'\n                    );\n\n                    // Consider where is no new option and should be merged using {},\n                    // see removeEdgeAndAdd in topologicalTravel and\n                    // ComponentModel.getAllClassMainTypes.\n                    if (!newCptOption) {\n                        componentModel.mergeOption({}, this);\n                        componentModel.optionUpdated({}, false);\n                    }\n                    else {\n                        var ComponentModelClass = ComponentModel.getClass(\n                            mainType, resultItem.keyInfo.subType, true\n                        );\n\n                        if (componentModel && componentModel instanceof ComponentModelClass) {\n                            componentModel.name = resultItem.keyInfo.name;\n                            componentModel.mergeOption(newCptOption, this);\n                            componentModel.optionUpdated(newCptOption, false);\n                        }\n                        else {\n                            // PENDING Global as parent ?\n                            var extraOpt = zrUtil.extend(\n                                {\n                                    dependentModels: dependentModels,\n                                    componentIndex: index\n                                },\n                                resultItem.keyInfo\n                            );\n                            componentModel = new ComponentModelClass(\n                                newCptOption, this, this, extraOpt\n                            );\n                            zrUtil.extend(componentModel, extraOpt);\n                            componentModel.init(newCptOption, this, this, extraOpt);\n                            // Call optionUpdated after init.\n                            // newCptOption has been used as componentModel.option\n                            // and may be merged with theme and default, so pass null\n                            // to avoid confusion.\n                            componentModel.optionUpdated(null, true);\n                        }\n                    }\n\n                    componentsMap.get(mainType)[index] = componentModel;\n                    option[mainType][index] = componentModel.option;\n                }, this);\n\n                // Backup series for filtering.\n                if (mainType === 'series') {\n                    this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n                }\n            }\n        },\n\n        /**\n         * Get option for output (cloned option and inner info removed)\n         * @public\n         * @return {Object}\n         */\n        getOption: function () {\n            var option = zrUtil.clone(this.option);\n\n            each(option, function (opts, mainType) {\n                if (ComponentModel.hasClass(mainType)) {\n                    var opts = modelUtil.normalizeToArray(opts);\n                    for (var i = opts.length - 1; i >= 0; i--) {\n                        // Remove options with inner id.\n                        if (modelUtil.isIdInner(opts[i])) {\n                            opts.splice(i, 1);\n                        }\n                    }\n                    option[mainType] = opts;\n                }\n            });\n\n            delete option[OPTION_INNER_KEY];\n\n            return option;\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        getTheme: function () {\n            return this._theme;\n        },\n\n        /**\n         * @param {string} mainType\n         * @param {number} [idx=0]\n         * @return {module:echarts/model/Component}\n         */\n        getComponent: function (mainType, idx) {\n            var list = this._componentsMap.get(mainType);\n            if (list) {\n                return list[idx || 0];\n            }\n        },\n\n        /**\n         * If none of index and id and name used, return all components with mainType.\n         * @param {Object} condition\n         * @param {string} condition.mainType\n         * @param {string} [condition.subType] If ignore, only query by mainType\n         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        queryComponents: function (condition) {\n            var mainType = condition.mainType;\n            if (!mainType) {\n                return [];\n            }\n\n            var index = condition.index;\n            var id = condition.id;\n            var name = condition.name;\n\n            var cpts = this._componentsMap.get(mainType);\n\n            if (!cpts || !cpts.length) {\n                return [];\n            }\n\n            var result;\n\n            if (index != null) {\n                if (!isArray(index)) {\n                    index = [index];\n                }\n                result = filter(map(index, function (idx) {\n                    return cpts[idx];\n                }), function (val) {\n                    return !!val;\n                });\n            }\n            else if (id != null) {\n                var isIdArray = isArray(id);\n                result = filter(cpts, function (cpt) {\n                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n                        || (!isIdArray && cpt.id === id);\n                });\n            }\n            else if (name != null) {\n                var isNameArray = isArray(name);\n                result = filter(cpts, function (cpt) {\n                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n                        || (!isNameArray && cpt.name === name);\n                });\n            }\n            else {\n                // Return all components with mainType\n                result = cpts.slice();\n            }\n\n            return filterBySubType(result, condition);\n        },\n\n        /**\n         * The interface is different from queryComponents,\n         * which is convenient for inner usage.\n         *\n         * @usage\n         * var result = findComponents(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series'},\n         *     function (model, index) {...}\n         * );\n         * // result like [component0, componnet1, ...]\n         *\n         * @param {Object} condition\n         * @param {string} condition.mainType Mandatory.\n         * @param {string} [condition.subType] Optional.\n         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n         *        where xxx is mainType.\n         *        If query attribute is null/undefined or has no index/id/name,\n         *        do not filtering by query conditions, which is convenient for\n         *        no-payload situations or when target of action is global.\n         * @param {Function} [condition.filter] parameter: component, return boolean.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        findComponents: function (condition) {\n            var query = condition.query;\n            var mainType = condition.mainType;\n\n            var queryCond = getQueryCond(query);\n            var result = queryCond\n                ? this.queryComponents(queryCond)\n                : this._componentsMap.get(mainType);\n\n            return doFilter(filterBySubType(result, condition));\n\n            function getQueryCond(q) {\n                var indexAttr = mainType + 'Index';\n                var idAttr = mainType + 'Id';\n                var nameAttr = mainType + 'Name';\n                return q && (\n                        q[indexAttr] != null\n                        || q[idAttr] != null\n                        || q[nameAttr] != null\n                    )\n                    ? {\n                        mainType: mainType,\n                        // subType will be filtered finally.\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    }\n                    : null;\n            }\n\n            function doFilter(res) {\n                return condition.filter\n                     ? filter(res, condition.filter)\n                     : res;\n            }\n        },\n\n        /**\n         * @usage\n         * eachComponent('legend', function (legendModel, index) {\n         *     ...\n         * });\n         * eachComponent(function (componentType, model, index) {\n         *     // componentType does not include subType\n         *     // (componentType is 'xxx' but not 'xxx.aa')\n         * });\n         * eachComponent(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n         *     function (model, index) {...}\n         * );\n         * eachComponent(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n         *     function (model, index) {...}\n         * );\n         *\n         * @param {string|Object=} mainType When mainType is object, the definition\n         *                                  is the same as the method 'findComponents'.\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachComponent: function (mainType, cb, context) {\n            var componentsMap = this._componentsMap;\n\n            if (typeof mainType === 'function') {\n                context = cb;\n                cb = mainType;\n                componentsMap.each(function (components, componentType) {\n                    each(components, function (component, index) {\n                        cb.call(context, componentType, component, index);\n                    });\n                });\n            }\n            else if (zrUtil.isString(mainType)) {\n                each(componentsMap.get(mainType), cb, context);\n            }\n            else if (isObject(mainType)) {\n                var queryResult = this.findComponents(mainType);\n                each(queryResult, cb, context);\n            }\n        },\n\n        /**\n         * @param {string} name\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByName: function (name) {\n            var series = this._componentsMap.get('series');\n            return filter(series, function (oneSeries) {\n                return oneSeries.name === name;\n            });\n        },\n\n        /**\n         * @param {number} seriesIndex\n         * @return {module:echarts/model/Series}\n         */\n        getSeriesByIndex: function (seriesIndex) {\n            return this._componentsMap.get('series')[seriesIndex];\n        },\n\n        /**\n         * @param {string} subType\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByType: function (subType) {\n            var series = this._componentsMap.get('series');\n            return filter(series, function (oneSeries) {\n                return oneSeries.subType === subType;\n            });\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeries: function () {\n            return this._componentsMap.get('series').slice();\n        },\n\n        /**\n         * After filtering, series may be different\n         * frome raw series.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.get('series')[rawSeriesIndex];\n                cb.call(context, series, rawSeriesIndex);\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeries: function (cb, context) {\n            each(this._componentsMap.get('series'), cb, context);\n        },\n\n        /**\n         * After filtering, series may be different.\n         * frome raw series.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeriesByType: function (subType, cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.get('series')[rawSeriesIndex];\n                if (series.subType === subType) {\n                    cb.call(context, series, rawSeriesIndex);\n                }\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered of given type.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeriesByType: function (subType, cb, context) {\n            return each(this.getSeriesByType(subType), cb, context);\n        },\n\n        /**\n         * @param {module:echarts/model/Series} seriesModel\n         */\n        isSeriesFiltered: function (seriesModel) {\n            assertSeriesInitialized(this);\n            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getCurrentSeriesIndices: function () {\n            return (this._seriesIndices || []).slice();\n        },\n\n        /**\n         * @param {Function} cb\n         * @param {*} context\n         */\n        filterSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            var filteredSeries = filter(\n                this._componentsMap.get('series'), cb, context\n            );\n            this._seriesIndices = createSeriesIndices(filteredSeries);\n        },\n\n        restoreData: function () {\n            var componentsMap = this._componentsMap;\n\n            this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n\n            var componentTypes = [];\n            componentsMap.each(function (components, componentType) {\n                componentTypes.push(componentType);\n            });\n\n            ComponentModel.topologicalTravel(\n                componentTypes,\n                ComponentModel.getAllClassMainTypes(),\n                function (componentType, dependencies) {\n                    each(componentsMap.get(componentType), function (component) {\n                        component.restoreData();\n                    });\n                }\n            );\n        }\n\n    });\n\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        zrUtil.each(theme, function (themeItem, name) {\n            //  component model  merge  model \n            if (!ComponentModel.hasClass(name)) {\n                if (typeof themeItem === 'object') {\n                    option[name] = !option[name]\n                        ? zrUtil.clone(themeItem)\n                        : zrUtil.merge(option[name], themeItem, false);\n                }\n                else {\n                    if (option[name] == null) {\n                        option[name] = themeItem;\n                    }\n                }\n            }\n        });\n    }\n\n    function initBase(baseOption) {\n        baseOption = baseOption;\n\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n\n        /**\n         * Init with series: [], in case of calling findSeries method\n         * before series initialized.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = zrUtil.createHashMap({series: []});\n\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n\n        mergeTheme(baseOption, this._theme.option);\n\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n\n        this.mergeOption(baseOption);\n    }\n\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap.get(type) || []).slice();\n        });\n\n        return ret;\n    }\n\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type\n            ? newCptOption.type\n            : existComponent\n            ? existComponent.subType\n            // Use determineSubType only when there is no existComponent.\n            : ComponentModel.determineSubType(mainType, newCptOption);\n\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType')\n            ? filter(components, function (cpt) {\n                return cpt.subType === condition.subType;\n            })\n            : components;\n    }\n\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (__DEV__) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Option should contains series.');\n            }\n        }\n    }\n\n    zrUtil.mixin(GlobalModel, __webpack_require__(237));\n\n    module.exports = GlobalModel;\n\n\n/***/ }),\n/* 271 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var modelUtil = __webpack_require__(194);\n    var ComponentModel = __webpack_require__(202);\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n    OptionManager.prototype = {\n\n        constructor: OptionManager,\n\n        /**\n         * @public\n         * @param {Object} rawOption Raw option.\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Array.<Function>} optionPreprocessorFuncs\n         * @return {Object} Init option\n         */\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n\n            // FIXME\n            //  timeline options  media baseOption\n\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(\n                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n            );\n            this._newBaseOption = newParsedOption.baseOption;\n\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            }\n            else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n\n        /**\n         * @param {boolean} isRecreate\n         * @return {Object}\n         */\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n\n            // TODO\n            // resetclone\n\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n\n            return clone(isRecreate\n                // this._optionBackup.baseOption, which is created at the first `setOption`\n                // called, and is merged into every new option by inner method `mergeOption`\n                // each time `setOption` called, can be only used in `isRecreate`, because\n                // its reliability is under suspicion. In other cases option merge is\n                // performed by `model.mergeOption`.\n                ? optionBackup.baseOption : this._newBaseOption\n            );\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object}\n         */\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(\n                        timelineOptions[timelineModel.getCurrentIndex()],\n                        true\n                    );\n                }\n            }\n\n            return option;\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Array.<Object>}\n         */\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n\n            // FIXME\n            // mediaDefault\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(\n                        index === -1 ? mediaDefault.option : mediaList[index].option\n                    );\n                });\n            }\n            // Otherwise return nothing.\n\n            this._currentMediaIndices = indices;\n\n            return result;\n        }\n    };\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    }\n                    else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n\n        // Preprocess.\n        each([baseOption].concat(timelineOptions)\n            .concat(zrUtil.map(mediaList, function (media) {\n                return media.option;\n            })),\n            function (option) {\n                each(optionPreprocessorFuncs, function (preProcess) {\n                    preProcess(option, isNew);\n                });\n            }\n        );\n\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n            width: ecWidth,\n            height: ecHeight,\n            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n        };\n\n        var applicatable = true;\n\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n\n        return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        }\n        else if (operator === 'max') {\n            return real <= expect;\n        }\n        else { // Equals\n            return real === expect;\n        }\n    }\n\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n\n            var oldCptOpt = oldOption[mainType];\n\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            }\n            else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return (item.option && item.exist)\n                        ? merge(item.exist, item.option, true)\n                        : (item.exist || item.option);\n                });\n            }\n        });\n    }\n\n    module.exports = OptionManager;\n\n\n/***/ }),\n/* 272 */\n/***/ (function(module, exports) {\n\n\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    module.exports = {\n        // \n        // backgroundColor: 'rgba(0,0,0,0)',\n\n        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n        // \n        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n        // \n        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n        //  Grid \n        // grid: {},\n        // \n        textStyle: {\n            // color: '#000',\n            // decoration: 'none',\n            // PENDING\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            // fontFamily: 'Arial, Verdana, sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n\n        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n        // Default is source-over\n        blendMode: null,\n\n        animation: 'auto',\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n\n        animationThreshold: 2000,\n        // Configuration for progressive/incremental rendering\n        progressiveThreshold: 3000,\n        progressive: 400,\n\n        // Threshold of if use single hover layer to optimize.\n        // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n        // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n        // which is unexpected.\n        // see example <echarts/test/heatmap-large.html>.\n        hoverLayerThreshold: 3000,\n\n        // See: module:echarts/scale/Time\n        useUTC: false\n    };\n\n\n/***/ }),\n/* 273 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    module.exports = {\n        getAreaStyle: __webpack_require__(220)(\n            [\n                ['fill', 'color'],\n                ['shadowBlur'],\n                ['shadowOffsetX'],\n                ['shadowOffsetY'],\n                ['opacity'],\n                ['shadowColor']\n            ]\n        )\n    };\n\n\n/***/ }),\n/* 274 */\n/***/ (function(module, exports) {\n\n\n\n    module.exports = {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n\n\n/***/ }),\n/* 275 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var getItemStyle = __webpack_require__(220)(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor'],\n            ['textPosition'],\n            ['textAlign']\n        ]\n    );\n    module.exports = {\n        getItemStyle: function (excludes, includes) {\n            var style = getItemStyle.call(this, excludes, includes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n        }\n    };\n\n\n/***/ }),\n/* 276 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var getLineStyle = __webpack_require__(220)(\n        [\n            ['lineWidth', 'width'],\n            ['stroke', 'color'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash(style.lineWidth);\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getLineDash: function (lineWidth) {\n            if (lineWidth == null) {\n                lineWidth = 1;\n            }\n            var lineType = this.get('type');\n            var dotSize = Math.max(lineWidth, 2);\n            var dashSize = lineWidth * 4;\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n        }\n    };\n\n\n/***/ }),\n/* 277 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var textContain = __webpack_require__(206);\n    var graphicUtil = __webpack_require__(192);\n\n    module.exports = {\n        /**\n         * Get color property or get color from option.textStyle.color\n         * @return {string}\n         */\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color')\n                || (ecModel && ecModel.get('textStyle.color'));\n        },\n\n        /**\n         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n         * @return {string}\n         */\n        getFont: function () {\n            return graphicUtil.getFont({\n                fontStyle: this.getShallow('fontStyle'),\n                fontWeight: this.getShallow('fontWeight'),\n                fontSize: this.getShallow('fontSize'),\n                fontFamily: this.getShallow('fontFamily')\n            }, this.ecModel);\n        },\n\n        getTextRect: function (text) {\n            return textContain.getBoundingRect(\n                text,\n                this.getFont(),\n                this.getShallow('align'),\n                this.getShallow('baseline')\n            );\n        },\n\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(\n                text, containerWidth, this.getFont(), ellipsis, options\n            );\n        }\n    };\n\n\n/***/ }),\n/* 278 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Compatitable with 2.0\n\n\n    var zrUtil = __webpack_require__(190);\n    var compatStyle = __webpack_require__(279);\n\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n\n    var LAYOUT_PROPERTIES = [\n        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n    ];\n\n    var COMPATITABLE_COMPONENTS = [\n        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n    ];\n\n    var COMPATITABLE_SERIES = [\n        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n    ];\n\n    var each = zrUtil.each;\n\n    module.exports = function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n\n            var seriesType = seriesOpt.type;\n\n            compatStyle(seriesOpt);\n\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null\n                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n\n\n/***/ }),\n/* 279 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var POSSIBLE_STYLES = [\n        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n        'chordStyle', 'label', 'labelLine'\n    ];\n\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n\n    module.exports = function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    }\n                    else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n\n\n/***/ }),\n/* 280 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n\n    var zrUtil = __webpack_require__(190);\n    var Scale = __webpack_require__(213);\n    var numberUtil = __webpack_require__(193);\n\n    // Use some method of IntervalScale\n    var IntervalScale = __webpack_require__(222);\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n\n    var mathLog = Math.log;\n\n    var LogScale = Scale.extend({\n\n        type: 'log',\n\n        base: 10,\n\n        $constructor: function () {\n            Scale.apply(this, arguments);\n            this._originalScale = new IntervalScale();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            var originalScale = this._originalScale;\n            var extent = this._extent;\n            var originalExtent = originalScale.getExtent();\n\n            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                var powVal = numberUtil.round(mathPow(this.base, val));\n\n                // Fix #4158\n                powVal = (val === extent[0] && originalScale.__fixMin)\n                    ? fixRoundingError(powVal, originalExtent[0])\n                    : powVal;\n                powVal = (val === extent[1] && originalScale.__fixMax)\n                    ? fixRoundingError(powVal, originalExtent[1])\n                    : powVal;\n\n                return powVal;\n            }, this);\n        },\n\n        /**\n         * @param {number} val\n         * @return {string}\n         */\n        getLabel: intervalScaleProto.getLabel,\n\n        /**\n         * @param  {number} val\n         * @return {number}\n         */\n        scale: function (val) {\n            val = scaleProto.scale.call(this, val);\n            return mathPow(this.base, val);\n        },\n\n        /**\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var base = this.base;\n            start = mathLog(start) / mathLog(base);\n            end = mathLog(end) / mathLog(base);\n            intervalScaleProto.setExtent.call(this, start, end);\n        },\n\n        /**\n         * @return {number} end\n         */\n        getExtent: function () {\n            var base = this.base;\n            var extent = scaleProto.getExtent.call(this);\n            extent[0] = mathPow(base, extent[0]);\n            extent[1] = mathPow(base, extent[1]);\n\n            // Fix #4158\n            var originalScale = this._originalScale;\n            var originalExtent = originalScale.getExtent();\n            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n            return extent;\n        },\n\n        /**\n         * @param  {Array.<number>} extent\n         */\n        unionExtent: function (extent) {\n            this._originalScale.unionExtent(extent);\n\n            var base = this.base;\n            extent[0] = mathLog(extent[0]) / mathLog(base);\n            extent[1] = mathLog(extent[1]) / mathLog(base);\n            scaleProto.unionExtent.call(this, extent);\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, true, function (val) {\n                return val > 0;\n            }));\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         * @param  {number} [approxTickNum = 10] Given approx tick number\n         */\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (span === Infinity || span <= 0) {\n                return;\n            }\n\n            var interval = numberUtil.quantity(span);\n            var err = approxTickNum / span * interval;\n\n            // Filter ticks to get closer to the desired count.\n            if (err <= 0.5) {\n                interval *= 10;\n            }\n\n            // Interval should be integer\n            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                interval *= 10;\n            }\n\n            var niceExtent = [\n                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n            ];\n\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @override\n         */\n        niceExtent: function (opt) {\n            intervalScaleProto.niceExtent.call(this, opt);\n\n            var originalScale = this._originalScale;\n            originalScale.__fixMin = opt.fixMin;\n            originalScale.__fixMax = opt.fixMax;\n        }\n\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n\n    LogScale.create = function () {\n        return new LogScale();\n    };\n\n    function fixRoundingError(val, originalVal) {\n        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n    }\n\n    module.exports = LogScale;\n\n\n/***/ }),\n/* 281 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\n\n    var zrUtil = __webpack_require__(190);\n    var Scale = __webpack_require__(213);\n\n    var scaleProto = Scale.prototype;\n\n    var OrdinalScale = Scale.extend({\n\n        type: 'ordinal',\n\n        init: function (data, extent) {\n            this._data = data;\n            this._extent = extent || [0, data.length - 1];\n        },\n\n        parse: function (val) {\n            return typeof val === 'string'\n                ? zrUtil.indexOf(this._data, val)\n                // val might be float.\n                : Math.round(val);\n        },\n\n        contain: function (rank) {\n            rank = this.parse(rank);\n            return scaleProto.contain.call(this, rank)\n                && this._data[rank] != null;\n        },\n\n        /**\n         * Normalize given rank or name to linear [0, 1]\n         * @param {number|string} [val]\n         * @return {number}\n         */\n        normalize: function (val) {\n            return scaleProto.normalize.call(this, this.parse(val));\n        },\n\n        scale: function (val) {\n            return Math.round(scaleProto.scale.call(this, val));\n        },\n\n        /**\n         * @return {Array}\n         */\n        getTicks: function () {\n            var ticks = [];\n            var extent = this._extent;\n            var rank = extent[0];\n\n            while (rank <= extent[1]) {\n                ticks.push(rank);\n                rank++;\n            }\n\n            return ticks;\n        },\n\n        /**\n         * Get item on rank n\n         * @param {number} n\n         * @return {string}\n         */\n        getLabel: function (n) {\n            return this._data[n];\n        },\n\n        /**\n         * @return {number}\n         */\n        count: function () {\n            return this._extent[1] - this._extent[0] + 1;\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, false));\n        },\n\n        niceTicks: zrUtil.noop,\n        niceExtent: zrUtil.noop\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n\n    module.exports = OrdinalScale;\n\n\n/***/ }),\n/* 282 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Interval scale\n * @module echarts/coord/scale/Time\n */\n\n\n\n    // [About UTC and local time zone]:\n    // In most cases, `number.parseDate` will treat input data string as local time\n    // (except time zone is specified in time string). And `format.formateTime` returns\n    // local time by default. option.useUTC is false by default. This design have\n    // concidered these common case:\n    // (1) Time that is persistent in server is in UTC, but it is needed to be diplayed\n    // in local time by default.\n    // (2) By default, the input data string (e.g., '2011-01-02') should be displayed\n    // as its original time, without any time difference.\n\n    var zrUtil = __webpack_require__(190);\n    var numberUtil = __webpack_require__(193);\n    var formatUtil = __webpack_require__(197);\n    var scaleHelper = __webpack_require__(238);\n\n    var IntervalScale = __webpack_require__(222);\n\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n\n    // FIXME \n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            }\n            else {\n                hi  = mid;\n            }\n        }\n        return lo;\n    };\n\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n        type: 'time',\n\n        /**\n         * @override\n         */\n        getLabel: function (val) {\n            var stepLvl = this._stepLvl;\n\n            var date = new Date(val);\n\n            return formatUtil.formatTime(stepLvl[0], date, this.getSetting('useUTC'));\n        },\n\n        /**\n         * @override\n         */\n        niceExtent: function (opt) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                // Expand extent\n                extent[0] -= ONE_DAY;\n                extent[1] += ONE_DAY;\n            }\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (extent[1] === -Infinity && extent[0] === Infinity) {\n                var d = new Date();\n                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                extent[0] = extent[1] - ONE_DAY;\n            }\n\n            this.niceTicks(opt.splitNumber);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!opt.fixMin) {\n                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!opt.fixMax) {\n                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n            }\n        },\n\n        /**\n         * @override\n         */\n        niceTicks: function (approxTickNum) {\n            var timezoneOffset = this.getSetting('useUTC')\n                ? 0 : numberUtil.getTimezoneOffset() * 60 * 1000;\n            approxTickNum = approxTickNum || 10;\n\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            var approxInterval = span / approxTickNum;\n            var scaleLevelsLen = scaleLevels.length;\n            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n            var interval = level[2];\n            // Same with interval scale if span is much larger than 1 year\n            if (level[0] === 'year') {\n                var yearSpan = span / interval;\n\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\n                interval *= yearStep;\n            }\n\n            var niceExtent = [\n                Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset),\n                Math.round(mathFloor((extent[1] - timezoneOffset)/ interval) * interval + timezoneOffset)\n            ];\n\n            scaleHelper.fixExtent(niceExtent, extent);\n\n            this._stepLvl = level;\n            // Interval will be used in getTicks\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        parse: function (val) {\n            // val might be float.\n            return +numberUtil.parseDate(val);\n        }\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n\n    // Steps from d3\n    var scaleLevels = [\n        // Format       step    interval\n        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n        ['week',        7,      ONE_DAY * 7],        // 7d\n        ['month',       1,      ONE_DAY * 31],       // 1M\n        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n        ['year',        1,      ONE_DAY * 380]       // 1Y\n    ];\n\n    /**\n     * @param {module:echarts/model/Model}\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function (model) {\n        return new TimeScale({useUTC: model.ecModel.get('useUTC')});\n    };\n\n    module.exports = TimeScale;\n\n\n/***/ }),\n/* 283 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var Gradient = __webpack_require__(224);\n    module.exports = function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(\n                            idx, 'color', color(seriesModel.getDataParams(idx))\n                        );\n                    });\n                }\n\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n\n\n/***/ }),\n/* 284 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = __webpack_require__(190);\n    var Draggable = __webpack_require__(311);\n\n    var Eventful = __webpack_require__(210);\n\n    var SILENT = 'silent';\n\n    function makeEventPacket(eveType, targetInfo, event) {\n        return {\n            type: eveType,\n            event: event,\n            // target can only be an element that is not silent.\n            target: targetInfo.target,\n            // topTarget can be a silent element.\n            topTarget: targetInfo.topTarget,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * {target, topTarget}\n         * @private\n         * @type {Object}\n         */\n        this._hovered = {};\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var lastHovered = this._hovered;\n            var hovered = this._hovered = this.findHover(x, y);\n            var hoveredTarget = hovered.target;\n            var lastHoveredTarget = lastHovered.target;\n\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget && lastHoveredTarget.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = {};\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * cursor style\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * \n         *\n         * @private\n         * @param {Object} targetInfo {target, topTarget} \n         * @param {string} eventName \n         * @param {Object} event \n         */\n        dispatchToElement: function (targetInfo, eventName, event) {\n            targetInfo = targetInfo || {};\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n            var el = targetInfo.target;\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                //  zrender \n                this.trigger(eventName, eventPacket);\n                // \n                //  click  dispose painter \n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @return {model:zrender/Element}\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            var out = {};\n\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                var hoverCheckResult;\n                if (list[i] !== exclude\n                    // getDisplayList may include ignored item in VML mode\n                    && !list[i].ignore\n                    && (hoverCheckResult = isHover(list[i], x, y))\n                ) {\n                    !out.topTarget && (out.topTarget = list[i]);\n                    if (hoverCheckResult !== SILENT) {\n                        out.target = list[i];\n                        break;\n                    }\n                }\n            }\n\n            return out;\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY);\n            var hoveredTarget = hovered.target;\n\n            if (name === 'mousedown') {\n                this._downel = hoveredTarget;\n                // In case click triggered before mouseup\n                this._upel = hoveredTarget;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hoveredTarget;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            var isSilent;\n            while (el) {\n                // If clipped by ancestor.\n                // FIXME: If clipPath has neither stroke nor fill,\n                // el.clipPath.contain(x, y) will always return false.\n                if (el.clipPath && !el.clipPath.contain(x, y))  {\n                    return false;\n                }\n                if (el.silent) {\n                    isSilent = true;\n                }\n                el = el.parent;\n            }\n            return isSilent ? SILENT : true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n/***/ }),\n/* 285 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = __webpack_require__(190);\n    var config = __webpack_require__(214);\n    var Style = __webpack_require__(246);\n    var Pattern = __webpack_require__(245);\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * dom\n     *\n     * @inner\n     * @param {string} id dom id \n     * @param {string} type dom typesuch as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // append~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // \n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * \n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * \n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * alpha\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n/***/ }),\n/* 286 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = __webpack_require__(214);\n    var util = __webpack_require__(190);\n    var log = __webpack_require__(234);\n    var BoundingRect = __webpack_require__(200);\n    var timsort = __webpack_require__(226);\n\n    var Layer = __webpack_require__(285);\n\n    var requestAnimationFrame = __webpack_require__(241);\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.__builtin__) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n\n            clipPath.setTransform(ctx);\n            ctx.beginPath();\n            clipPath.buildPath(ctx, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // \n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root \n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * \n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            if (opts.width != null) {\n                root.width = opts.width;\n            }\n            if (opts.height != null) {\n                root.height = opts.height;\n            }\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n\n            this._domRoot = root;\n        }\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._domRoot;\n        },\n\n        /**\n         * \n         * @param {boolean} [paintAll=false] displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.__builtin__ && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuiltinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuiltinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.__builtin__) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         *  zlevel \n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.__builtin__ = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            layersMap[zlevel] = layer;\n\n            // Vitual layer will not directly show on the screen.\n            // (It can be a WebGL layer and assigned to a ZImage element)\n            // But it still under management of zrender.\n            if (!layer.virtual) {\n                if (prevLayer) {\n                    var prevDom = prevLayer.dom;\n                    if (prevDom.nextSibling) {\n                        domRoot.insertBefore(\n                            layer.dom,\n                            prevDom.nextSibling\n                        );\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n                else {\n                    if (domRoot.firstChild) {\n                        domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n            }\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuiltinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (!layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuiltinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // \n            this.eachBuiltinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * hover\n         */\n        clear: function () {\n            this.eachBuiltinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * zlevel\n         *\n         * @param {string} zlevel\n         * @param {Object} config \n         * @param {string} [config.clearColor=0] \n         * @param {string} [config.motionBlur=false] \n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 alpha\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {number} zlevel zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * \n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * \n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            var zlevel;\n\n            var self = this;\n            function findAndDrawOtherLayer(smaller, larger) {\n                var zlevelList = self._zlevelList;\n                if (smaller == null) {\n                    smaller = -Infinity;\n                }\n                var intermediateLayer;\n                for (var i = 0; i < zlevelList.length; i++) {\n                    var z = zlevelList[i];\n                    var layer = self._layers[z];\n                    if (!layer.__builtin__ && z > smaller && z < larger) {\n                        intermediateLayer = layer;\n                        break;\n                    }\n                }\n                if (intermediateLayer && intermediateLayer.renderToCanvas) {\n                    imageLayer.ctx.save();\n                    intermediateLayer.renderToCanvas(imageLayer.ctx);\n                    imageLayer.ctx.restore();\n                }\n            }\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n\n                if (el.zlevel !== zlevel) {\n                    findAndDrawOtherLayer(zlevel, el.zlevel);\n                    zlevel = el.zlevel;\n                }\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            findAndDrawOtherLayer(zlevel, Infinity);\n\n            return imageLayer.dom;\n        },\n        /**\n         * \n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * \n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        pathToImage: function (path, dpr) {\n            dpr = dpr || this.dpr;\n\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            var rect = path.getBoundingRect();\n            var style = path.style;\n            var shadowBlurSize = style.shadowBlur;\n            var shadowOffsetX = style.shadowOffsetX;\n            var shadowOffsetY = style.shadowOffsetY;\n            var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\n            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n            var width = rect.width + leftMargin + rightMargin;\n            var height = rect.height + topMargin + bottomMargin;\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.scale(dpr, dpr);\n            ctx.clearRect(0, 0, width, height);\n            ctx.dpr = dpr;\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [leftMargin - rect.x, topMargin - rect.y];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            path.updateTransform();\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = __webpack_require__(235);\n            var imgShape = new ImageShape({\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n/***/ }),\n/* 287 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = __webpack_require__(190);\n    var env = __webpack_require__(198);\n\n    var Group = __webpack_require__(215);\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = __webpack_require__(226);\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     *  (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} [update=false] \n         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n         *\n         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * \n         * GroupShapeShape\n         * zlevel > z > \n         * @param {boolean} [includeIgnore=false]  ignore \n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var userSetClipPath = el.clipPath;\n            if (userSetClipPath) {\n\n                // FIXME \n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                // Recursively add clip path\n                while (currentClipPath) {\n                    // clipPath  clipPath \n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n\n                    clipPaths.push(currentClipPath);\n\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.clipPath;\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            if (el.__storage === this) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToStorage(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {string|Array.<string>} [el] Storage\n         */\n        delRoot: function (el) {\n            if (el == null) {\n                // el\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (el instanceof Array) {\n                for (var i = 0, l = el.length; i < l; i++) {\n                    this.delRoot(el[i]);\n                }\n                return;\n            }\n\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromStorage(el);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToStorage: function (el) {\n            el.__storage = this;\n            el.dirty(false);\n\n            return this;\n        },\n\n        delFromStorage: function (el) {\n            if (el) {\n                el.__storage = null;\n            }\n\n            return this;\n        },\n\n        /**\n         * Storage\n         */\n        dispose: function () {\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n/***/ }),\n/* 288 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = __webpack_require__(190);\n    var Dispatcher = __webpack_require__(209).Dispatcher;\n\n    var requestAnimationFrame = __webpack_require__(241);\n\n    var Animator = __webpack_require__(240);\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         *  clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         *  animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * \n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * \n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time, delta);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * \n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * \n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * \n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * animator\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] \n         * @param  {Function} [options.getter=null]\n         *         gettergetter\n         * @param  {Function} [options.setter=null]\n         *         settersetter\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            this.addAnimator(animator);\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n/***/ }),\n/* 289 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = __webpack_require__(290);\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // \n        this._life = options.life || 1000;\n        // \n        this._delay = options.delay || 0;\n        // \n        // this._startTime = new Date().getTime() + this._delay;// \n        this._initialized = false;\n\n        // \n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n\n        this._pausedTime = 0;\n        this._paused = false;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime, deltaTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            if (this._paused) {\n                this._pausedTime += deltaTime;\n                return;\n            }\n\n            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n\n            // \n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // \n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // \n                    //  stage.update \n                    return 'restart';\n                }\n\n                // \n                // Animation.update\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._pausedTime = 0;\n\n            this._needsRemove = false;\n        },\n\n        fire: function (eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        },\n\n        pause: function () {\n            this._paused = true;\n        },\n\n        resume: function () {\n            this._paused = false;\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n/***/ }),\n/* 290 */\n/***/ (function(module, exports) {\n\n/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // t^3\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // t^4\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // t^5\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // sin(t)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 2^t\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // sqrt(1-t^2)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n/***/ }),\n/* 291 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var normalizeRadian = __webpack_require__(242).normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n/***/ }),\n/* 292 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var curve = __webpack_require__(207);\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n/***/ }),\n/* 293 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var CMD = __webpack_require__(212).CMD;\n    var line = __webpack_require__(259);\n    var cubic = __webpack_require__(292);\n    var quadratic = __webpack_require__(260);\n    var arc = __webpack_require__(291);\n    var normalizeRadian = __webpack_require__(242).normalizeRadian;\n    var curve = __webpack_require__(207);\n\n    var windingLine = __webpack_require__(261);\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // \n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc \n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                //  subpath \n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE  L, C, Q  NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    //  arc \n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // \n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr scale, x\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        //  subpath \n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n/***/ }),\n/* 294 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = __webpack_require__(209);\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n/***/ }),\n/* 295 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var eventTool = __webpack_require__(209);\n    var zrUtil = __webpack_require__(190);\n    var Eventful = __webpack_require__(210);\n    var env = __webpack_require__(198);\n    var GestureMgr = __webpack_require__(294);\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerEventNames = {\n        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n    };\n\n    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n        var nm = name.replace('mouse', 'pointer');\n        return pointerEventNames[nm] ? nm : name;\n    });\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null).target,\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        // Do not do any preventDefault here. Upper application do that if necessary.\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement({target: gestureInfo.target}, type, gestureInfo.event);\n        }\n    }\n\n    // function onMSGestureChange(proxy, event) {\n    //     if (event.translationX || event.translationY) {\n    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n    //     }\n    //     if (event.scale !== 1) {\n    //         event.pinchX = event.offsetX;\n    //         event.pinchY = event.offsetY;\n    //         event.pinchScale = event.scale;\n    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n    //     }\n    // }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // rootdommouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered, and must before `mousedown` triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        },\n\n        pointerdown: function (event) {\n            domHandlers.mousedown.call(this, event);\n\n            // if (useMSGuesture(this, event)) {\n            //     this._msGesture.addPointer(event.pointerId);\n            // }\n        },\n\n        pointermove: function (event) {\n            // FIXME\n            // pointermove is so sensitive that it always triggered when\n            // tap(click) on touch screen, which affect some judgement in\n            // upper application. So, we dont support mousemove on MS touch\n            // device yet.\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mousemove.call(this, event);\n            }\n        },\n\n        pointerup: function (event) {\n            domHandlers.mouseup.call(this, event);\n        },\n\n        pointerout: function (event) {\n            // pointerout will be triggered when tap on touch screen\n            // (IE11+/Edge on MS Surface) after click event triggered,\n            // which is inconsistent with the mousout behavior we defined\n            // in touchend. So we unify them.\n            // (check domHandlers.touchend for detailed explanation)\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n\n    // function useMSGuesture(handlerProxy, event) {\n    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n    // }\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * dom \n     *\n     * @inner\n     * @param {module:zrender/Handler} instance \n     */\n    function initDomHandler(instance) {\n        zrUtil.each(touchHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(pointerHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(mouseHandlerNames, function (name) {\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        });\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (env.pointerEventsSupported) { // Only IE11+/Edge\n            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n            // at the same time.\n            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n            // screen, which do not occurs in pointer event.\n            // So we use pointer event to both detect touch gesture and mouse behavior.\n            mountHandlers(pointerHandlerNames, this);\n\n            // FIXME\n            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n            // which does not prevent defuault behavior occasionally (which may cause view port\n            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n            // touch screen. And we only support click behavior on MS touch screen now.\n\n            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n            // We dont support touch on IE on win7.\n            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n            // if (typeof MSGesture === 'function') {\n            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n            // }\n        }\n        else {\n            if (env.touchEventsSupported) {\n                mountHandlers(touchHandlerNames, this);\n                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n            }\n\n            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n            // mouse event can not be handle in those devices.\n            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n            // mouseevent after touch event triggered, see `setTouchTimer`.\n            mountHandlers(mouseHandlerNames, this);\n        }\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n/***/ }),\n/* 296 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// CompoundPath to improve performance\n\n\n    var Path = __webpack_require__(196);\n\n    module.exports = Path.extend({\n\n        type: 'compound',\n\n        shape: {\n\n            paths: null\n        },\n\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                if (!paths[i].path) {\n                    paths[i].createPathProxy();\n                }\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n\n\n/***/ }),\n/* 297 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var Gradient = __webpack_require__(224);\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'radial', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n/***/ }),\n/* 298 */\n/***/ (function(module, exports) {\n\n\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n/***/ }),\n/* 299 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = __webpack_require__(195);\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * \n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points \n     * @param {number} smooth , 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint \n     *                            [[0, 0], [100, 100]], \n     *                           \n     * @param {Array} \n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // \n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n/***/ }),\n/* 300 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = __webpack_require__(195);\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points \n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n/***/ }),\n/* 301 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = __webpack_require__(196).extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n/***/ }),\n/* 302 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = __webpack_require__(207);\n    var vec2 = __webpack_require__(195);\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = __webpack_require__(196).extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n/***/ }),\n/* 303 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = __webpack_require__(196).extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // else {\n            //     if (ctx.allocate && !ctx.data.length) {\n            //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n            //     }\n            // }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n/***/ }),\n/* 304 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = __webpack_require__(196).extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n/***/ }),\n/* 305 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = __webpack_require__(247);\n\n    module.exports = __webpack_require__(196).extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n/***/ }),\n/* 306 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = __webpack_require__(247);\n\n    module.exports = __webpack_require__(196).extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n/***/ }),\n/* 307 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = __webpack_require__(298);\n\n    module.exports = __webpack_require__(196).extend({\n\n        type: 'rect',\n\n        shape: {\n            // r1r2r3r4\n            // r1          [1, 1, 1, 1]\n            // r[1]        [1, 1, 1, 1]\n            // r[1, 2]     [1, 2, 1, 2]\n            // r[1, 2, 3]  [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n/***/ }),\n/* 308 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = __webpack_require__(196).extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n/***/ }),\n/* 309 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    var env = __webpack_require__(198);\n    var Path = __webpack_require__(196);\n\n    var shadowTemp = [\n        ['shadowBlur', 0],\n        ['shadowColor', '#000'],\n        ['shadowOffsetX', 0],\n        ['shadowOffsetY', 0]\n    ];\n\n    module.exports = Path.extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\n            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\n            // where exception \"unexpected call to method or property access\"\n            // might be thrown when calling ctx.fill after a path whose area size\n            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\n            // (e.g.,\n            //  ctx.moveTo(10, 10);\n            //  ctx.lineTo(20, 10);\n            //  ctx.closePath();\n            //  ctx.clip();\n            //  ctx.shadowBlur = 10;\n            //  ...\n            //  ctx.fill();\n            // )\n            ? function () {\n                var clipPaths = this.__clipPaths;\n                var style = this.style;\n                var modified;\n\n                if (clipPaths) {\n                    for (var i = 0; i < clipPaths.length; i++) {\n                        var shape = clipPaths[i] && clipPaths[i].shape;\n                        if (shape && shape.startAngle === shape.endAngle) {\n                            for (var j = 0; j < shadowTemp.length; j++) {\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n                            }\n                            modified = true;\n                            break;\n                        }\n                    }\n                }\n\n                Path.prototype.brush.apply(this, arguments);\n\n                if (modified) {\n                    for (var j = 0; j < shadowTemp.length; j++) {\n                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n                    }\n                }\n            }\n            : Path.prototype.brush,\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n/***/ }),\n/* 310 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = __webpack_require__(240);\n    var util = __webpack_require__(190);\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = __webpack_require__(234);\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * \n         *\n         * @param {string} path a.b.c\n         * @param {boolean} [loop] \n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n/***/ }),\n/* 311 */\n/***/ (function(module, exports) {\n\n// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget).target;\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    function param(target, e) {\n        return {target: target, topTarget: e && e.topTarget};\n    }\n\n    module.exports = Draggable;\n\n\n/***/ }),\n/* 312 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var Path = __webpack_require__(196);\n    var PathProxy = __webpack_require__(212);\n    var transformPath = __webpack_require__(313);\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            if (path.setData) {\n                path.setData(pathProxy.data);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            }\n            else {\n                var ctx = path;\n                pathProxy.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            transformPath(pathProxy, m);\n\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (!pathEl.path) {\n                    pathEl.createPathProxy();\n                }\n                if (pathEl.__dirtyPath) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            // Need path proxy.\n            pathBundle.createPathProxy();\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n/***/ }),\n/* 313 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var CMD = __webpack_require__(212).CMD;\n    var vec2 = __webpack_require__(195);\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i] *= sx;\n                    data[i++] += x;\n                    // cy\n                    data[i] *= sy;\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n/***/ }),\n/* 314 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// FIXME Better way to pack data in graphic element\n\n\n    __webpack_require__(248);\n\n    __webpack_require__(323);\n\n    __webpack_require__(324);\n\n\n    // Show tip action\n    /**\n     * @action\n     * @property {string} type\n     * @property {number} seriesIndex\n     * @property {number} dataIndex\n     * @property {number} [x]\n     * @property {number} [y]\n     */\n    __webpack_require__(191).registerAction(\n        {\n            type: 'showTip',\n            event: 'showTip',\n            update: 'tooltip:manuallyShowTip'\n        },\n        // noop\n        function () {}\n    );\n    // Hide tip action\n    __webpack_require__(191).registerAction(\n        {\n            type: 'hideTip',\n            event: 'hideTip',\n            update: 'tooltip:manuallyHideTip'\n        },\n        // noop\n        function () {}\n    );\n\n\n/***/ }),\n/* 315 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    var defaultOption = {\n        show: true,\n        zlevel: 0,                  // \n        z: 0,                       // \n        // \n        inverse: false,\n\n        // \n        name: '',\n        // 'start' | 'middle' | 'end'\n        nameLocation: 'end',\n        // degree\n        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n        nameTruncate: {\n            maxWidth: null,\n            ellipsis: '...',\n            placeholder: '.'\n        },\n        // \n        nameTextStyle: {},\n        // \n        nameGap: 15,\n\n        silent: false, // Default false to support tooltip.\n        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\n        tooltip: {\n            show: false\n        },\n\n        axisPointer: {},\n\n        // \n        axisLine: {\n            // show\n            show: true,\n            onZero: true,\n            // lineStyle\n            lineStyle: {\n                color: '#333',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        axisTick: {\n            // show\n            show: true,\n            // grid\n            inside: false,\n            // length\n            length: 5,\n            // lineStyle\n            lineStyle: {\n                width: 1\n            }\n        },\n        // axis.axisLabel\n        axisLabel: {\n            show: true,\n            // grid\n            inside: false,\n            rotate: 0,\n            showMinLabel: null, // true | false | null (auto)\n            showMaxLabel: null, // true | false | null (auto)\n            margin: 8,\n            // formatter: null,\n            // TEXTSTYLE\n            textStyle: {\n                fontSize: 12\n            }\n        },\n        // \n        splitLine: {\n            // show\n            show: true,\n            // lineStylelineStyle\n            lineStyle: {\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        splitArea: {\n            // show\n            show: false,\n            // areaStyleareaStyle\n            areaStyle: {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    };\n\n    var categoryAxis = zrUtil.merge({\n        // \n        boundaryGap: true,\n        // splitArea: {\n            // show: false\n        // },\n        splitLine: {\n            show: false\n        },\n        // \n        axisTick: {\n            // If tick is align with label when boundaryGap is true\n            alignWithLabel: false,\n            interval: 'auto'\n        },\n        // axis.axisLabel\n        axisLabel: {\n            interval: 'auto'\n        }\n    }, defaultOption);\n\n    var valueAxis = zrUtil.merge({\n        // \n        boundaryGap: [0, 0],\n        // ,  'dataMin' \n        // min: null,\n        //  'dataMax' \n        // max: null,\n        // Readonly prop, specifies start value of the range when using data zoom.\n        // rangeStart: null\n        // Readonly prop, specifies end value of the range when using data zoom.\n        // rangeEnd: null\n        // 0_min_max\n        // scale: false,\n        // 5\n        splitNumber: 5\n        // Minimum interval\n        // minInterval: null\n    }, defaultOption);\n\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n        scale: true,\n        min: 'dataMin',\n        max: 'dataMax'\n    }, valueAxis);\n\n    var logAxis = zrUtil.defaults({\n        scale: true,\n        logBase: 10\n    }, valueAxis);\n\n    module.exports = {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n\n\n/***/ }),\n/* 316 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var axisDefault = __webpack_require__(315);\n    var zrUtil = __webpack_require__(190);\n    var ComponentModel = __webpack_require__(202);\n    var layout = __webpack_require__(203);\n\n    // FIXME axisType is fixed ?\n    var AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\n    /**\n     * Generate sub axis model class\n     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n     * @param {module:echarts/model/Component} BaseAxisModelClass\n     * @param {Function} axisTypeDefaulter\n     * @param {Object} [extraDefaultOption]\n     */\n    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\n        zrUtil.each(AXIS_TYPES, function (axisType) {\n\n            BaseAxisModelClass.extend({\n\n                type: axisName + 'Axis.' + axisType,\n\n                mergeDefaultAndTheme: function (option, ecModel) {\n                    var layoutMode = this.layoutMode;\n                    var inputPositionParams = layoutMode\n                        ? layout.getLayoutParams(option) : {};\n\n                    var themeModel = ecModel.getTheme();\n                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n                    zrUtil.merge(option, this.getDefaultOption());\n\n                    option.type = axisTypeDefaulter(axisName, option);\n\n                    if (layoutMode) {\n                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                    }\n                },\n\n                defaultOption: zrUtil.mergeAll(\n                    [\n                        {},\n                        axisDefault[axisType + 'Axis'],\n                        extraDefaultOption\n                    ],\n                    true\n                )\n            });\n        });\n\n        ComponentModel.registerSubTypeDefaulter(\n            axisName + 'Axis',\n            zrUtil.curry(axisTypeDefaulter, axisName)\n        );\n    };\n\n\n/***/ }),\n/* 317 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\nvar factory = exports;\n\n    var layout = __webpack_require__(203);\n    var axisHelper = __webpack_require__(205);\n\n    var zrUtil = __webpack_require__(190);\n    var Cartesian2D = __webpack_require__(331);\n    var Axis2D = __webpack_require__(329);\n\n    var each = zrUtil.each;\n\n    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n    var niceScaleExtent = axisHelper.niceScaleExtent;\n\n    //  GridModel, AxisModel \n    __webpack_require__(332);\n\n    /**\n     * Check if the axis is used in the specified grid\n     * @inner\n     */\n    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n        return axisModel.getCoordSysModel() === gridModel;\n    }\n\n    function getLabelUnionRect(axis) {\n        var axisModel = axis.model;\n        var labels = axisModel.getFormattedLabels();\n        var textStyleModel = axisModel.getModel('axisLabel.textStyle');\n        var rect;\n        var step = 1;\n        var labelCount = labels.length;\n        if (labelCount > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.ceil(labelCount / 40);\n        }\n        for (var i = 0; i < labelCount; i += step) {\n            if (!axis.isLabelIgnored(i)) {\n                var singleRect = textStyleModel.getTextRect(labels[i]);\n                // FIXME consider label rotate\n                rect ? rect.union(singleRect) : (rect = singleRect);\n            }\n        }\n        return rect;\n    }\n\n    function Grid(gridModel, ecModel, api) {\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n         * @private\n         */\n        this._coordsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n         * @private\n         */\n        this._coordsList = [];\n\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesList = [];\n\n        this._initCartesian(gridModel, ecModel, api);\n\n        this.model = gridModel;\n    }\n\n    var gridProto = Grid.prototype;\n\n    gridProto.type = 'grid';\n\n    gridProto.axisPointerEnabled = true;\n\n    gridProto.getRect = function () {\n        return this._rect;\n    };\n\n    gridProto.update = function (ecModel, api) {\n\n        var axesMap = this._axesMap;\n\n        this._updateScale(ecModel, this.model);\n\n        function ifAxisCanNotOnZero(otherAxisDim) {\n            var axes = axesMap[otherAxisDim];\n            for (var idx in axes) {\n                if (axes.hasOwnProperty(idx)) {\n                    var axis = axes[idx];\n                    if (axis && (\n                        axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis)\n                    )) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        each(axesMap.x, function (xAxis) {\n            niceScaleExtent(xAxis.scale, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n            niceScaleExtent(yAxis.scale, yAxis.model);\n        });\n        // Fix configuration\n        each(axesMap.x, function (xAxis) {\n            // onZero can not be enabled in these two situations\n            // 1. When any other axis is a category axis\n            // 2. When any other axis not across 0 point\n            if (ifAxisCanNotOnZero('y')) {\n                xAxis.onZero = false;\n            }\n        });\n        each(axesMap.y, function (yAxis) {\n            if (ifAxisCanNotOnZero('x')) {\n                yAxis.onZero = false;\n            }\n        });\n\n        // Resize again if containLabel is enabled\n        // FIXME It may cause getting wrong grid size in data processing stage\n        this.resize(this.model, api);\n    };\n\n    /**\n     * Resize the grid\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    gridProto.resize = function (gridModel, api, ignoreContainLabel) {\n\n        var gridRect = layout.getLayoutRect(\n            gridModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n\n        this._rect = gridRect;\n\n        var axesList = this._axesList;\n\n        adjustAxes();\n\n        // Minus label size\n        if (!ignoreContainLabel && gridModel.get('containLabel')) {\n            each(axesList, function (axis) {\n                if (!axis.model.get('axisLabel.inside')) {\n                    var labelUnionRect = getLabelUnionRect(axis);\n                    if (labelUnionRect) {\n                        var dim = axis.isHorizontal() ? 'height' : 'width';\n                        var margin = axis.model.get('axisLabel.margin');\n                        gridRect[dim] -= labelUnionRect[dim] + margin;\n                        if (axis.position === 'top') {\n                            gridRect.y += labelUnionRect.height + margin;\n                        }\n                        else if (axis.position === 'left')  {\n                            gridRect.x += labelUnionRect.width + margin;\n                        }\n                    }\n                }\n            });\n\n            adjustAxes();\n        }\n\n        function adjustAxes() {\n            each(axesList, function (axis) {\n                var isHorizontal = axis.isHorizontal();\n                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n                var idx = axis.inverse ? 1 : 0;\n                axis.setExtent(extent[idx], extent[1 - idx]);\n                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n            });\n        }\n    };\n\n    /**\n     * @param {string} axisType\n     * @param {ndumber} [axisIndex]\n     */\n    gridProto.getAxis = function (axisType, axisIndex) {\n        var axesMapOnDim = this._axesMap[axisType];\n        if (axesMapOnDim != null) {\n            if (axisIndex == null) {\n                // Find first axis\n                for (var name in axesMapOnDim) {\n                    if (axesMapOnDim.hasOwnProperty(name)) {\n                        return axesMapOnDim[name];\n                    }\n                }\n            }\n            return axesMapOnDim[axisIndex];\n        }\n    };\n\n    /**\n     * @return {Array.<module:echarts/coord/Axis>}\n     */\n    gridProto.getAxes = function () {\n        return this._axesList.slice();\n    };\n\n    /**\n     * Usage:\n     *      grid.getCartesian(xAxisIndex, yAxisIndex);\n     *      grid.getCartesian(xAxisIndex);\n     *      grid.getCartesian(null, yAxisIndex);\n     *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n     *\n     * @param {number|Object} [xAxisIndex]\n     * @param {number} [yAxisIndex]\n     */\n    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            return this._coordsMap[key];\n        }\n\n        if (zrUtil.isObject(xAxisIndex)) {\n            yAxisIndex = xAxisIndex.yAxisIndex;\n            xAxisIndex = xAxisIndex.xAxisIndex;\n        }\n        // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n        for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n            if (coordList[i].getAxis('x').index === xAxisIndex\n                || coordList[i].getAxis('y').index === yAxisIndex\n            ) {\n                return coordList[i];\n            }\n        }\n    };\n\n    gridProto.getCartesians = function () {\n        return this._coordsList.slice();\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertToPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.dataToPoint(value)\n            : target.axis\n            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n            : null;\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertFromPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.pointToData(value)\n            : target.axis\n            ? target.axis.coordToData(target.axis.toLocalCoord(value))\n            : null;\n    };\n\n    /**\n     * @inner\n     */\n    gridProto._findConvertTarget = function (ecModel, finder) {\n        var seriesModel = finder.seriesModel;\n        var xAxisModel = finder.xAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n        var yAxisModel = finder.yAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n        var gridModel = finder.gridModel;\n        var coordsList = this._coordsList;\n        var cartesian;\n        var axis;\n\n        if (seriesModel) {\n            cartesian = seriesModel.coordinateSystem;\n            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n        }\n        else if (xAxisModel && yAxisModel) {\n            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        }\n        else if (xAxisModel) {\n            axis = this.getAxis('x', xAxisModel.componentIndex);\n        }\n        else if (yAxisModel) {\n            axis = this.getAxis('y', yAxisModel.componentIndex);\n        }\n        // Lowest priority.\n        else if (gridModel) {\n            var grid = gridModel.coordinateSystem;\n            if (grid === this) {\n                cartesian = this._coordsList[0];\n            }\n        }\n\n        return {cartesian: cartesian, axis: axis};\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.containPoint = function (point) {\n        var coord = this._coordsList[0];\n        if (coord) {\n            return coord.containPoint(point);\n        }\n    };\n\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    gridProto._initCartesian = function (gridModel, ecModel, api) {\n        var axisPositionUsed = {\n            left: false,\n            right: false,\n            top: false,\n            bottom: false\n        };\n\n        var axesMap = {\n            x: {},\n            y: {}\n        };\n        var axesCount = {\n            x: 0,\n            y: 0\n        };\n\n        /// Create axis\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n        if (!axesCount.x || !axesCount.y) {\n            // Roll back when there no either x or y axis\n            this._axesMap = {};\n            this._axesList = [];\n            return;\n        }\n\n        this._axesMap = axesMap;\n\n        /// Create cartesian2d\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n            each(axesMap.y, function (yAxis, yAxisIndex) {\n                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n                var cartesian = new Cartesian2D(key);\n\n                cartesian.grid = this;\n                cartesian.model = gridModel;\n\n                this._coordsMap[key] = cartesian;\n                this._coordsList.push(cartesian);\n\n                cartesian.addAxis(xAxis);\n                cartesian.addAxis(yAxis);\n            }, this);\n        }, this);\n\n        function createAxisCreator(axisType) {\n            return function (axisModel, idx) {\n                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                    return;\n                }\n\n                var axisPosition = axisModel.get('position');\n                if (axisType === 'x') {\n                    // Fix position\n                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                        // Default bottom of X\n                        axisPosition = 'bottom';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                        }\n                    }\n                }\n                else {\n                    // Fix position\n                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n                        // Default left of Y\n                        axisPosition = 'left';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                        }\n                    }\n                }\n                axisPositionUsed[axisPosition] = true;\n\n                var axis = new Axis2D(\n                    axisType, axisHelper.createScaleByModel(axisModel),\n                    [0, 0],\n                    axisModel.get('type'),\n                    axisPosition\n                );\n\n                var isCategory = axis.type === 'category';\n                axis.onBand = isCategory && axisModel.get('boundaryGap');\n                axis.inverse = axisModel.get('inverse');\n\n                axis.onZero = axisModel.get('axisLine.onZero');\n\n                // Inject axis into axisModel\n                axisModel.axis = axis;\n\n                // Inject axisModel into axis\n                axis.model = axisModel;\n\n                // Inject grid info axis\n                axis.grid = this;\n\n                // Index of axis, can be used as key\n                axis.index = idx;\n\n                this._axesList.push(axis);\n\n                axesMap[axisType][idx] = axis;\n                axesCount[axisType]++;\n            };\n        }\n    };\n\n    /**\n     * Update cartesian properties from series\n     * @param  {module:echarts/model/Option} option\n     * @private\n     */\n    gridProto._updateScale = function (ecModel, gridModel) {\n        // Reset scale\n        zrUtil.each(this._axesList, function (axis) {\n            axis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCartesian2D(seriesModel)) {\n                var axesModels = findAxesModels(seriesModel, ecModel);\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n\n                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n                 ) {\n                    return;\n                }\n\n                var cartesian = this.getCartesian(\n                    xAxisModel.componentIndex, yAxisModel.componentIndex\n                );\n                var data = seriesModel.getData();\n                var xAxis = cartesian.getAxis('x');\n                var yAxis = cartesian.getAxis('y');\n\n                if (data.type === 'list') {\n                    unionExtent(data, xAxis, seriesModel);\n                    unionExtent(data, yAxis, seriesModel);\n                }\n            }\n        }, this);\n\n        function unionExtent(data, axis, seriesModel) {\n            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n                axis.scale.unionExtentFromData(data, dim);\n            });\n        }\n    };\n\n    /**\n     * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n     * @return {Object} {baseAxes: [], otherAxes: []}\n     */\n    gridProto.getTooltipAxes = function (dim) {\n        var baseAxes = [];\n        var otherAxes = [];\n\n        each(this.getCartesians(), function (cartesian) {\n            var baseAxis = (dim != null && dim !== 'auto')\n                ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n            var otherAxis = cartesian.getOtherAxis(baseAxis);\n            zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n            zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n        });\n\n        return {baseAxes: baseAxes, otherAxes: otherAxes};\n    };\n\n    /**\n     * @inner\n     */\n    function updateAxisTransfrom(axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\n        // Fast transform\n        axis.toGlobalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord + coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n        axis.toLocalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord - coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n    }\n\n    var axesTypes = ['xAxis', 'yAxis'];\n    /**\n     * @inner\n     */\n    function findAxesModels(seriesModel, ecModel) {\n        return zrUtil.map(axesTypes, function (axisType) {\n            var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\n            if (__DEV__) {\n                if (!axisModel) {\n                    throw new Error(axisType + ' \"' + zrUtil.retrieve(\n                        seriesModel.get(axisType + 'Index'),\n                        seriesModel.get(axisType + 'Id'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n            return axisModel;\n        });\n    }\n\n    /**\n     * @inner\n     */\n    function isCartesian2D(seriesModel) {\n        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n\n    Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n            var grid = new Grid(gridModel, ecModel, api);\n            grid.name = 'grid_' + idx;\n            // dataSampling requires axis extent, so resize\n            // should be performed in create stage.\n            grid.resize(gridModel, api, true);\n\n            gridModel.coordinateSystem = grid;\n\n            grids.push(grid);\n        });\n\n        // Inject the coordinateSystems into seriesModel\n        ecModel.eachSeries(function (seriesModel) {\n            if (!isCartesian2D(seriesModel)) {\n                return;\n            }\n\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            var gridModel = xAxisModel.getCoordSysModel();\n\n            if (__DEV__) {\n                if (!gridModel) {\n                    throw new Error(\n                        'Grid \"' + zrUtil.retrieve(\n                            xAxisModel.get('gridIndex'),\n                            xAxisModel.get('gridId'),\n                            0\n                        ) + '\" not found'\n                    );\n                }\n                if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n                    throw new Error('xAxis and yAxis must use the same grid');\n                }\n            }\n\n            var grid = gridModel.coordinateSystem;\n\n            seriesModel.coordinateSystem = grid.getCartesian(\n                xAxisModel.componentIndex, yAxisModel.componentIndex\n            );\n        });\n\n        return grids;\n    };\n\n    // For deciding which dimensions to use when creating list data\n    Grid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\n\n    __webpack_require__(216).register('cartesian2d', Grid);\n\n    module.exports = Grid;\n\n\n/***/ }),\n/* 318 */,\n/* 319 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var echarts = __webpack_require__(191);\n\n    var AxisPointerModel = echarts.extendComponentModel({\n\n        type: 'axisPointer',\n\n        coordSysAxesInfo: null,\n\n        defaultOption: {\n            // 'auto' means that show when triggered by tooltip or handle.\n            show: 'auto',\n            // 'click' | 'mousemove' | 'none'\n            triggerOn: null, // set default in AxisPonterView.js\n\n            zlevel: 0,\n            z: 50,\n\n            type: 'line',\n            // axispointer triggered by tootip determine snap automatically,\n            // see `modelHelper`.\n            snap: false,\n            triggerTooltip: true,\n\n            value: null,\n            status: null, // Init value depends on whether handle is used.\n\n            // [group0, group1, ...]\n            // Each group can be: {\n            //      mapper: function () {},\n            //      singleTooltip: 'multiple',  // 'multiple' or 'single'\n            //      xAxisId: ...,\n            //      yAxisName: ...,\n            //      angleAxisIndex: ...\n            // }\n            // mapper: can be ignored.\n            //      input: {axisInfo, value}\n            //      output: {axisInfo, value}\n            link: [],\n\n            // Do not set 'auto' here, otherwise global animation: false\n            // will not effect at this axispointer.\n            animation: null,\n            animationDurationUpdate: 200,\n\n            lineStyle: {\n                color: '#aaa',\n                width: 1,\n                type: 'solid'\n            },\n\n            shadowStyle: {\n                color: 'rgba(150,150,150,0.3)'\n            },\n\n            label: {\n                show: true,\n                formatter: null, // string | Function\n                precision: 'auto', // Or a number like 0, 1, 2 ...\n                margin: 3,\n                textStyle: {\n                    color: '#fff'\n                },\n                padding: [5, 7, 5, 7],\n                backgroundColor: 'auto', // default: axis line color\n                borderColor: null,\n                borderWidth: 0,\n                shadowBlur: 3,\n                shadowColor: '#aaa'\n                // Considering applicability, common style should\n                // better not have shadowOffset.\n                // shadowOffsetX: 0,\n                // shadowOffsetY: 2\n            },\n\n            handle: {\n                show: false,\n                icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z', // jshint ignore:line\n                size: 45,\n                // handle margin is from symbol center to axis, which is stable when circular move.\n                margin: 50,\n                // color: '#1b8bbd'\n                // color: '#2f4554'\n                color: '#333',\n                shadowBlur: 3,\n                shadowColor: '#aaa',\n                shadowOffsetX: 0,\n                shadowOffsetY: 2,\n\n                // For mobile performance\n                throttle: 40\n            }\n        }\n\n    });\n\n    module.exports = AxisPointerModel;\n\n\n\n/***/ }),\n/* 320 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var globalListener = __webpack_require__(251);\n\n    var AxisPonterView = __webpack_require__(191).extendComponentView({\n\n        type: 'axisPointer',\n\n        render: function (globalAxisPointerModel, ecModel, api) {\n            var globalTooltipModel = ecModel.getComponent('tooltip');\n            var triggerOn = globalAxisPointerModel.get('triggerOn')\n                || (globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click');\n\n            // Register global listener in AxisPointerView to enable\n            // AxisPointerView to be independent to Tooltip.\n            globalListener.register(\n                'axisPointer',\n                api,\n                function (currTrigger, e, dispatchAction) {\n                    // If 'none', it is not controlled by mouse totally.\n                    if (triggerOn !== 'none'\n                        && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)\n                    ) {\n                        dispatchAction({\n                            type: 'updateAxisPointer',\n                            currTrigger: currTrigger,\n                            x: e && e.offsetX,\n                            y: e && e.offsetY\n                        });\n                    }\n                }\n            );\n        },\n\n        /**\n         * @override\n         */\n        remove: function (ecModel, api) {\n            globalListener.disopse(api.getZr(), 'axisPointer');\n            AxisPonterView.superApply(this._model, 'remove', arguments);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function (ecModel, api) {\n            globalListener.unregister('axisPointer', api);\n            AxisPonterView.superApply(this._model, 'dispose', arguments);\n        }\n\n    });\n\n\n\n/***/ }),\n/* 321 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var modelUtil = __webpack_require__(194);\n    var modelHelper = __webpack_require__(221);\n    var findPointFromSeries = __webpack_require__(250);\n\n    var each = zrUtil.each;\n    var curry = zrUtil.curry;\n    var get = modelUtil.makeGetter();\n\n    /**\n     * Basic logic: check all axis, if they do not demand show/highlight,\n     * then hide/downplay them.\n     *\n     * @param {Object} coordSysAxesInfo\n     * @param {Object} payload\n     * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'\n     * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to\n     *              trigger axisPointer and tooltip.\n     * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to\n     *              trigger axisPointer and tooltip.\n     * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.\n     * @param {Object} [payload.dataIndex] finder, restrict target axes.\n     * @param {Object} [payload.axesInfo] finder, restrict target axes.\n     *        [{\n     *          axisDim: 'x'|'y'|'angle'|...,\n     *          axisIndex: ...,\n     *          value: ...\n     *        }, ...]\n     * @param {Function} [payload.dispatchAction]\n     * @param {Object} [payload.tooltipOption]\n     * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,\n     *        which can be specified in dispatchAction\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     * @return {Object} content of event obj for echarts.connect.\n     */\n    function axisTrigger(payload, ecModel, api) {\n        var currTrigger = payload.currTrigger;\n        var point = [payload.x, payload.y];\n        var finder = payload;\n        var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n        var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n        if (illegalPoint(point)) {\n            // Used in the default behavior of `connection`: use the sample seriesIndex\n            // and dataIndex. And also used in the tooltipView trigger.\n            point = findPointFromSeries({\n                seriesIndex: finder.seriesIndex,\n                // Do not use dataIndexInside from other ec instance.\n                // FIXME: auto detect it?\n                dataIndex: finder.dataIndex\n            }, ecModel).point;\n        }\n        var isIllegalPoint = illegalPoint(point);\n\n        // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).\n        // Notice: In this case, it is difficult to get the `point` (which is necessary to show\n        // tooltip, so if point is not given, we just use the point found by sample seriesIndex\n        // and dataIndex.\n        var inputAxesInfo = finder.axesInfo;\n\n        var axesInfo = coordSysAxesInfo.axesInfo;\n        var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n        var outputFinder = {};\n\n        var showValueMap = {};\n        var dataByCoordSys = {list: [], map: {}};\n        var updaters = {\n            showPointer: curry(showPointer, showValueMap),\n            showTooltip: curry(showTooltip, dataByCoordSys)\n        };\n\n        // Process for triggered axes.\n        each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n            // If a point given, it must be contained by the coordinate system.\n            var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);\n\n            each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n                var axis = axisInfo.axis;\n                var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);\n                // If no inputAxesInfo, no axis is restricted.\n                if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {\n                    var val = inputAxisInfo && inputAxisInfo.value;\n                    if (val == null && !isIllegalPoint) {\n                        val = axis.pointToData(point);\n                    }\n                    val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);\n                }\n            });\n        });\n\n        // Process for linked axes.\n        var linkTriggers = {};\n        each(axesInfo, function (tarAxisInfo, tarKey) {\n            var linkGroup = tarAxisInfo.linkGroup;\n\n            // If axis has been triggered in the previous stage, it should not be triggered by link.\n            if (linkGroup && !showValueMap[tarKey]) {\n                each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n                    var srcValItem = showValueMap[srcKey];\n                    // If srcValItem exist, source axis is triggered, so link to target axis.\n                    if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n                        var val = srcValItem.value;\n                        linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(\n                            val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo)\n                        )));\n                        linkTriggers[tarAxisInfo.key] = val;\n                    }\n                });\n            }\n        });\n        each(linkTriggers, function (val, tarKey) {\n            processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);\n        });\n\n        updateModelActually(showValueMap, axesInfo, outputFinder);\n        dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);\n        dispatchHighDownActually(axesInfo, dispatchAction, api);\n\n        return outputFinder;\n    }\n\n    function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {\n        var axis = axisInfo.axis;\n\n        if (axis.scale.isBlank() || !axis.containData(newValue)) {\n            return;\n        }\n\n        if (!axisInfo.involveSeries) {\n            updaters.showPointer(axisInfo, newValue);\n            return;\n        }\n\n        // Heavy calculation. So put it after axis.containData checking.\n        var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n        var payloadBatch = payloadInfo.payloadBatch;\n        var snapToValue = payloadInfo.snapToValue;\n\n        // Fill content of event obj for echarts.connect.\n        // By defualt use the first involved series data as a sample to connect.\n        if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n            zrUtil.extend(outputFinder, payloadBatch[0]);\n        }\n\n        // If no linkSource input, this process is for collecting link\n        // target, where snap should not be accepted.\n        if (!dontSnap && axisInfo.snap) {\n            if (axis.containData(snapToValue) && snapToValue != null) {\n                newValue = snapToValue;\n            }\n        }\n\n        updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder);\n        // Tooltip should always be snapToValue, otherwise there will be\n        // incorrect \"axis value ~ series value\" mapping displayed in tooltip.\n        updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n    }\n\n    function buildPayloadsBySeries(value, axisInfo) {\n        var axis = axisInfo.axis;\n        var dim = axis.dim;\n        var snapToValue = value;\n        var payloadBatch = [];\n        var minDist = Number.MAX_VALUE;\n        var minDiff = -1;\n\n        each(axisInfo.seriesModels, function (series, idx) {\n            var dataDim = series.coordDimToDataDim(dim);\n            var seriesNestestValue;\n            var dataIndices;\n\n            if (series.getAxisTooltipData) {\n                var result = series.getAxisTooltipData(dataDim, value, axis);\n                dataIndices = result.dataIndices;\n                seriesNestestValue = result.nestestValue;\n            }\n            else {\n                dataIndices = series.getData().indicesOfNearest(\n                    dataDim[0],\n                    value,\n                    // Add a threshold to avoid find the wrong dataIndex\n                    // when data length is not same.\n                    false, axis.type === 'category' ? 0.5 : null\n                );\n                if (!dataIndices.length) {\n                    return;\n                }\n                seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n            }\n\n            if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n                return;\n            }\n\n            var diff = value - seriesNestestValue;\n            var dist = Math.abs(diff);\n            // Consider category case\n            if (dist <= minDist) {\n                if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                    minDist = dist;\n                    minDiff = diff;\n                    snapToValue = seriesNestestValue;\n                    payloadBatch.length = 0;\n                }\n                each(dataIndices, function (dataIndex) {\n                    payloadBatch.push({\n                        seriesIndex: series.seriesIndex,\n                        dataIndexInside: dataIndex,\n                        dataIndex: series.getData().getRawIndex(dataIndex)\n                    });\n                });\n            }\n        });\n\n        return {\n            payloadBatch: payloadBatch,\n            snapToValue: snapToValue\n        };\n    }\n\n    function showPointer(showValueMap, axisInfo, value, payloadBatch) {\n        showValueMap[axisInfo.key] = {value: value, payloadBatch: payloadBatch};\n    }\n\n    function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n        var payloadBatch = payloadInfo.payloadBatch;\n        var axis = axisInfo.axis;\n        var axisModel = axis.model;\n        var axisPointerModel = axisInfo.axisPointerModel;\n\n        // If no data, do not create anything in dataByCoordSys,\n        // whose length will be used to judge whether dispatch action.\n        if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n            return;\n        }\n\n        var coordSysModel = axisInfo.coordSys.model;\n        var coordSysKey = modelHelper.makeKey(coordSysModel);\n        var coordSysItem = dataByCoordSys.map[coordSysKey];\n        if (!coordSysItem) {\n            coordSysItem = dataByCoordSys.map[coordSysKey] = {\n                coordSysId: coordSysModel.id,\n                coordSysIndex: coordSysModel.componentIndex,\n                coordSysType: coordSysModel.type,\n                coordSysMainType: coordSysModel.mainType,\n                dataByAxis: []\n            };\n            dataByCoordSys.list.push(coordSysItem);\n        }\n\n        coordSysItem.dataByAxis.push({\n            axisDim: axis.dim,\n            axisIndex: axisModel.componentIndex,\n            axisType: axisModel.type,\n            axisId: axisModel.id,\n            value: value,\n            // Caustion: viewHelper.getValueLabel is actually on \"view stage\", which\n            // depends that all models have been updated. So it should not be performed\n            // here. Considering axisPointerModel used here is volatile, which is hard\n            // to be retrieve in TooltipView, we prepare parameters here.\n            valueLabelOpt: {\n                precision: axisPointerModel.get('label.precision'),\n                formatter: axisPointerModel.get('label.formatter')\n            },\n            seriesDataIndices: payloadBatch.slice()\n        });\n    }\n\n    function updateModelActually(showValueMap, axesInfo, outputFinder) {\n        var outputAxesInfo = outputFinder.axesInfo = [];\n        // Basic logic: If no 'show' required, 'hide' this axisPointer.\n        each(axesInfo, function (axisInfo, key) {\n            var option = axisInfo.axisPointerModel.option;\n            var valItem = showValueMap[key];\n\n            if (valItem) {\n                !axisInfo.useHandle && (option.status = 'show');\n                option.value = valItem.value;\n                // For label formatter param and highlight.\n                option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n            }\n            // When always show (e.g., handle used), remain\n            // original value and status.\n            else {\n                // If hide, value still need to be set, consider\n                // click legend to toggle axis blank.\n                !axisInfo.useHandle && (option.status = 'hide');\n            }\n\n            // If status is 'hide', should be no info in payload.\n            option.status === 'show' && outputAxesInfo.push({\n                axisDim: axisInfo.axis.dim,\n                axisIndex: axisInfo.axis.model.componentIndex,\n                value: option.value\n            });\n        });\n    }\n\n    function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {\n        // Basic logic: If no showTip required, hideTip will be dispatched.\n        if (illegalPoint(point) || !dataByCoordSys.list.length) {\n            dispatchAction({type: 'hideTip'});\n            return;\n        }\n\n        // In most case only one axis (or event one series is used). It is\n        // convinient to fetch payload.seriesIndex and payload.dataIndex\n        // dirtectly. So put the first seriesIndex and dataIndex of the first\n        // axis on the payload.\n        var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n\n        dispatchAction({\n            type: 'showTip',\n            escapeConnect: true,\n            x: point[0],\n            y: point[1],\n            tooltipOption: payload.tooltipOption,\n            position: payload.position,\n            dataIndexInside: sampleItem.dataIndexInside,\n            dataIndex: sampleItem.dataIndex,\n            seriesIndex: sampleItem.seriesIndex,\n            dataByCoordSys: dataByCoordSys.list\n        });\n    }\n\n    function dispatchHighDownActually(axesInfo, dispatchAction, api) {\n        // FIXME\n        // highlight status modification shoule be a stage of main process?\n        // (Consider confilct (e.g., legend and axisPointer) and setOption)\n\n        var zr = api.getZr();\n        var highDownKey = 'axisPointerLastHighlights';\n        var lastHighlights = get(zr)[highDownKey] || {};\n        var newHighlights = get(zr)[highDownKey] = {};\n\n        // Update highlight/downplay status according to axisPointer model.\n        // Build hash map and remove duplicate incidentally.\n        each(axesInfo, function (axisInfo, key) {\n            var option = axisInfo.axisPointerModel.option;\n            option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {\n                var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n                newHighlights[key] = batchItem;\n            });\n        });\n\n        // Diff.\n        var toHighlight = [];\n        var toDownplay = [];\n        zrUtil.each(lastHighlights, function (batchItem, key) {\n            !newHighlights[key] && toDownplay.push(batchItem);\n        });\n        zrUtil.each(newHighlights, function (batchItem, key) {\n            !lastHighlights[key] && toHighlight.push(batchItem);\n        });\n\n        toDownplay.length && api.dispatchAction({\n            type: 'downplay', escapeConnect: true, batch: toDownplay\n        });\n        toHighlight.length && api.dispatchAction({\n            type: 'highlight', escapeConnect: true, batch: toHighlight\n        });\n    }\n\n    function findInputAxisInfo(inputAxesInfo, axisInfo) {\n        for (var i = 0; i < (inputAxesInfo || []).length; i++) {\n            var inputAxisInfo = inputAxesInfo[i];\n            if (axisInfo.axis.dim === inputAxisInfo.axisDim\n                && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex\n            ) {\n                return inputAxisInfo;\n            }\n        }\n    }\n\n    function makeMapperParam(axisInfo) {\n        var axisModel = axisInfo.axis.model;\n        var item = {};\n        var dim = item.axisDim = axisInfo.axis.dim;\n        item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n        item.axisName = item[dim + 'AxisName'] = axisModel.name;\n        item.axisId = item[dim + 'AxisId'] = axisModel.id;\n        return item;\n    }\n\n    function illegalPoint(point) {\n        return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n    }\n\n    module.exports = axisTrigger;\n\n\n/***/ }),\n/* 322 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module echarts/component/tooltip/TooltipContent\n */\n\n\n    var zrUtil = __webpack_require__(190);\n    var zrColor = __webpack_require__(208);\n    var eventUtil = __webpack_require__(209);\n    var formatUtil = __webpack_require__(197);\n    var each = zrUtil.each;\n    var toCamelCase = formatUtil.toCamelCase;\n    var env = __webpack_require__(198);\n\n    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\n    /**\n     * @param {number} duration\n     * @return {string}\n     * @inner\n     */\n    function assembleTransition(duration) {\n        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n                            + 'top ' + duration + 's ' + transitionCurve;\n        return zrUtil.map(vendors, function (vendorPrefix) {\n            return vendorPrefix + 'transition:' + transitionText;\n        }).join(';');\n    }\n\n    /**\n     * @param {Object} textStyle\n     * @return {string}\n     * @inner\n     */\n    function assembleFont(textStyleModel) {\n        var cssText = [];\n\n        var fontSize = textStyleModel.get('fontSize');\n        var color = textStyleModel.getTextColor();\n\n        color && cssText.push('color:' + color);\n\n        cssText.push('font:' + textStyleModel.getFont());\n\n        fontSize &&\n            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\n        each(['decoration', 'align'], function (name) {\n            var val = textStyleModel.get(name);\n            val && cssText.push('text-' + name + ':' + val);\n        });\n\n        return cssText.join(';');\n    }\n\n    /**\n     * @param {Object} tooltipModel\n     * @return {string}\n     * @inner\n     */\n    function assembleCssText(tooltipModel) {\n\n        var cssText = [];\n\n        var transitionDuration = tooltipModel.get('transitionDuration');\n        var backgroundColor = tooltipModel.get('backgroundColor');\n        var textStyleModel = tooltipModel.getModel('textStyle');\n        var padding = tooltipModel.get('padding');\n\n        // Animation transition. Do not animate when transitionDuration is 0.\n        transitionDuration &&\n            cssText.push(assembleTransition(transitionDuration));\n\n        if (backgroundColor) {\n            if (env.canvasSupported) {\n                cssText.push('background-Color:' + backgroundColor);\n            }\n            else {\n                // for ie\n                cssText.push(\n                    'background-Color:#' + zrColor.toHex(backgroundColor)\n                );\n                cssText.push('filter:alpha(opacity=70)');\n            }\n        }\n\n        // Border style\n        each(['width', 'color', 'radius'], function (name) {\n            var borderName = 'border-' + name;\n            var camelCase = toCamelCase(borderName);\n            var val = tooltipModel.get(camelCase);\n            val != null &&\n                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n        });\n\n        // Text style\n        cssText.push(assembleFont(textStyleModel));\n\n        // Padding\n        if (padding != null) {\n            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n        }\n\n        return cssText.join(';') + ';';\n    }\n\n    /**\n     * @alias module:echarts/component/tooltip/TooltipContent\n     * @constructor\n     */\n    function TooltipContent(container, api) {\n        var el = document.createElement('div');\n        var zr = this._zr = api.getZr();\n\n        this.el = el;\n\n        this._x = api.getWidth() / 2;\n        this._y = api.getHeight() / 2;\n\n        container.appendChild(el);\n\n        this._container = container;\n\n        this._show = false;\n\n        /**\n         * @private\n         */\n        this._hideTimeout;\n\n        var self = this;\n        el.onmouseenter = function () {\n            // clear the timeout in hideLater and keep showing tooltip\n            if (self._enterable) {\n                clearTimeout(self._hideTimeout);\n                self._show = true;\n            }\n            self._inContent = true;\n        };\n        el.onmousemove = function (e) {\n            e = e || window.event;\n            if (!self._enterable) {\n                // Try trigger zrender event to avoid mouse\n                // in and out shape too frequently\n                var handler = zr.handler;\n                eventUtil.normalizeEvent(container, e, true);\n                handler.dispatch('mousemove', e);\n            }\n        };\n        el.onmouseleave = function () {\n            if (self._enterable) {\n                if (self._show) {\n                    self.hideLater(self._hideDelay);\n                }\n            }\n            self._inContent = false;\n        };\n    }\n\n    TooltipContent.prototype = {\n\n        constructor: TooltipContent,\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _enterable: true,\n\n        /**\n         * Update when tooltip is rendered\n         */\n        update: function () {\n            // FIXME\n            // Move this logic to ec main?\n            var container = this._container;\n            var stl = container.currentStyle\n                || document.defaultView.getComputedStyle(container);\n            var domStyle = container.style;\n            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n                domStyle.position = 'relative';\n            }\n            // Hide the tooltip\n            // PENDING\n            // this.hide();\n        },\n\n        show: function (tooltipModel) {\n            clearTimeout(this._hideTimeout);\n            var el = this.el;\n\n            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n                + (tooltipModel.get('extraCssText') || '');\n\n            el.style.display = el.innerHTML ?  'block' : 'none';\n\n            this._show = true;\n        },\n\n        setContent: function (content) {\n            this.el.innerHTML = content == null ? '' : content;\n        },\n\n        setEnterable: function (enterable) {\n            this._enterable = enterable;\n        },\n\n        getSize: function () {\n            var el = this.el;\n            return [el.clientWidth, el.clientHeight];\n        },\n\n        moveTo: function (x, y) {\n            // xy should be based on canvas root. But tooltipContent is\n            // the sibling of canvas root. So padding of ec container\n            // should be considered here.\n            var zr = this._zr;\n            var viewportRoot;\n            if (zr && zr.painter && (viewportRoot = zr.painter.getViewportRoot())) {\n                x += viewportRoot.offsetLeft || 0;\n                y += viewportRoot.offsetTop || 0;\n            }\n\n            var style = this.el.style;\n            style.left = x + 'px';\n            style.top = y + 'px';\n\n            this._x = x;\n            this._y = y;\n        },\n\n        hide: function () {\n            this.el.style.display = 'none';\n            this._show = false;\n        },\n\n        hideLater: function (time) {\n            if (this._show && !(this._inContent && this._enterable)) {\n                if (time) {\n                    this._hideDelay = time;\n                    // Set show false to avoid invoke hideLater mutiple times\n                    this._show = false;\n                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n                }\n                else {\n                    this.hide();\n                }\n            }\n        },\n\n        isShow: function () {\n            return this._show;\n        }\n    };\n\n    module.exports = TooltipContent;\n\n\n/***/ }),\n/* 323 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    __webpack_require__(191).extendComponentModel({\n\n        type: 'tooltip',\n\n        dependencies: ['axisPointer'],\n\n        defaultOption: {\n            zlevel: 0,\n\n            z: 8,\n\n            show: true,\n\n            // tooltip\n            showContent: true,\n\n            // 'trigger' only works on coordinate system.\n            // 'item' | 'axis' | 'none'\n            trigger: 'item',\n\n            // 'click' | 'mousemove' | 'none'\n            triggerOn: 'mousemove|click',\n\n            alwaysShowContent: false,\n\n            displayMode: 'single', // 'single' | 'multipleByCoordSys'\n\n            //  {Array} | {Function}\n            // position: null\n            // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\n            // align: null,\n            // verticalAlign: null,\n\n            //  content  viewRect  false \n            confine: false,\n\n            // {string}Template  {Function}\n            // formatter: null\n\n            showDelay: 0,\n\n            // ms\n            hideDelay: 100,\n\n            // s\n            transitionDuration: 0.4,\n\n            enterable: false,\n\n            // 0.7\n            backgroundColor: 'rgba(50,50,50,0.7)',\n\n            // \n            borderColor: '#333',\n\n            // px4\n            borderRadius: 4,\n\n            // px0\n            borderWidth: 0,\n\n            // px5\n            // css\n            padding: 5,\n\n            // Extra css text\n            extraCssText: '',\n\n            // \n            axisPointer: {\n                // \n                // 'line' | 'shadow' | 'cross'\n                type: 'line',\n\n                // type  line  tooltip line \n                //  'x' | 'y' | 'angle' | 'radius' | 'auto'\n                //  'auto' cateogry  x \n                //  angle \n                axis: 'auto',\n\n                animation: 'auto',\n                animationDurationUpdate: 200,\n                animationEasingUpdate: 'exponentialOut',\n\n                crossStyle: {\n                    color: '#999',\n                    width: 1,\n                    type: 'dashed',\n\n                    // TODO formatter\n                    textStyle: {}\n                }\n\n                // lineStyle and shadowStyle should not be specified here,\n                // otherwise it will always override those styles on option.axisPointer.\n            },\n            textStyle: {\n                color: '#fff',\n                fontSize: 14\n            }\n        }\n    });\n\n\n/***/ }),\n/* 324 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var TooltipContent = __webpack_require__(322);\n    var zrUtil = __webpack_require__(190);\n    var formatUtil = __webpack_require__(197);\n    var numberUtil = __webpack_require__(193);\n    var graphic = __webpack_require__(192);\n    var findPointFromSeries = __webpack_require__(250);\n    var layoutUtil = __webpack_require__(203);\n    var env = __webpack_require__(198);\n    var Model = __webpack_require__(199);\n    var globalListener = __webpack_require__(251);\n    var axisHelper = __webpack_require__(205);\n    var axisPointerViewHelper = __webpack_require__(249);\n\n    var bind = zrUtil.bind;\n    var each = zrUtil.each;\n    var parsePercent = numberUtil.parsePercent;\n\n\n    var proxyRect = new graphic.Rect({\n        shape: {x: -1, y: -1, width: 2, height: 2}\n    });\n\n    __webpack_require__(191).extendComponentView({\n\n        type: 'tooltip',\n\n        init: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var tooltipContent = new TooltipContent(api.getDom(), api);\n            this._tooltipContent = tooltipContent;\n        },\n\n        render: function (tooltipModel, ecModel, api) {\n            if (env.node) {\n                return;\n            }\n\n            // Reset\n            this.group.removeAll();\n\n            /**\n             * @private\n             * @type {module:echarts/component/tooltip/TooltipModel}\n             */\n            this._tooltipModel = tooltipModel;\n\n            /**\n             * @private\n             * @type {module:echarts/model/Global}\n             */\n            this._ecModel = ecModel;\n\n            /**\n             * @private\n             * @type {module:echarts/ExtensionAPI}\n             */\n            this._api = api;\n\n            /**\n             * Should be cleaned when render.\n             * @private\n             * @type {Array.<Array.<Object>>}\n             */\n            this._lastDataByCoordSys = null;\n\n            /**\n             * @private\n             * @type {boolean}\n             */\n            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\n            var tooltipContent = this._tooltipContent;\n            tooltipContent.update();\n            tooltipContent.setEnterable(tooltipModel.get('enterable'));\n\n            this._initGlobalListener();\n\n            this._keepShow();\n        },\n\n        _initGlobalListener: function () {\n            var tooltipModel = this._tooltipModel;\n            var triggerOn = tooltipModel.get('triggerOn');\n\n            globalListener.register(\n                'itemTooltip',\n                this._api,\n                bind(function (currTrigger, e, dispatchAction) {\n                    // If 'none', it is not controlled by mouse totally.\n                    if (triggerOn !== 'none') {\n                        if (triggerOn.indexOf(currTrigger) >= 0) {\n                            this._tryShow(e, dispatchAction);\n                        }\n                        else if (currTrigger === 'leave') {\n                            this._hide(dispatchAction);\n                        }\n                    }\n                }, this)\n            );\n        },\n\n        _keepShow: function () {\n            var tooltipModel = this._tooltipModel;\n            var ecModel = this._ecModel;\n            var api = this._api;\n\n            // Try to keep the tooltip show when refreshing\n            if (this._lastX != null\n                && this._lastY != null\n                // When user is willing to control tooltip totally using API,\n                // self.manuallyShowTip({x, y}) might cause tooltip hide,\n                // which is not expected.\n                && tooltipModel.get('triggerOn') !== 'none'\n            ) {\n                var self = this;\n                clearTimeout(this._refreshUpdateTimeout);\n                this._refreshUpdateTimeout = setTimeout(function () {\n                    // Show tip next tick after other charts are rendered\n                    // In case highlight action has wrong result\n                    // FIXME\n                    self.manuallyShowTip(tooltipModel, ecModel, api, {\n                        x: self._lastX,\n                        y: self._lastY\n                    });\n                });\n            }\n        },\n\n        /**\n         * Show tip manually by\n         * dispatchAction({\n         *     type: 'showTip',\n         *     x: 10,\n         *     y: 10\n         * });\n         * Or\n         * dispatchAction({\n         *      type: 'showTip',\n         *      seriesIndex: 0,\n         *      dataIndex or dataIndexInside or name\n         * });\n         *\n         *  TODO Batch\n         */\n        manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n            if (payload.from === this.uid || env.node) {\n                return;\n            }\n\n            var dispatchAction = makeDispatchAction(payload, api);\n\n            // Reset ticket\n            this._ticket = '';\n\n            // When triggered from axisPointer.\n            var dataByCoordSys = payload.dataByCoordSys;\n\n            if (payload.tooltip && payload.x != null && payload.y != null) {\n                var el = proxyRect;\n                el.position = [payload.x, payload.y];\n                el.update();\n                el.tooltip = payload.tooltip;\n                // Manually show tooltip while view is not using zrender elements.\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    target: el\n                }, dispatchAction);\n            }\n            else if (dataByCoordSys) {\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    event: {},\n                    dataByCoordSys: payload.dataByCoordSys,\n                    tooltipOption: payload.tooltipOption\n                }, dispatchAction);\n            }\n            else if (payload.seriesIndex != null) {\n\n                if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n                    return;\n                }\n\n                var pointInfo = findPointFromSeries(payload, ecModel);\n                var cx = pointInfo.point[0];\n                var cy = pointInfo.point[1];\n                if (cx != null && cy != null) {\n                    this._tryShow({\n                        offsetX: cx,\n                        offsetY: cy,\n                        position: payload.position,\n                        target: pointInfo.el,\n                        event: {}\n                    }, dispatchAction);\n                }\n            }\n            else if (payload.x != null && payload.y != null) {\n                // FIXME\n                // should wrap dispatchAction like `axisPointer/globalListener` ?\n                api.dispatchAction({\n                    type: 'updateAxisPointer',\n                    x: payload.x,\n                    y: payload.y\n                });\n\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    target: api.getZr().findHover(payload.x, payload.y).target,\n                    event: {}\n                }, dispatchAction);\n            }\n        },\n\n        manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n            var tooltipContent = this._tooltipContent;\n\n            if (!this._alwaysShowContent) {\n                tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n            }\n\n            this._lastX = this._lastY = null;\n\n            if (payload.from !== this.uid) {\n                this._hide(makeDispatchAction(payload, api));\n            }\n        },\n\n        // Be compatible with previous design, that is, when tooltip.type is 'axis' and\n        // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer\n        // and tooltip.\n        _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {\n            var seriesIndex = payload.seriesIndex;\n            var dataIndex = payload.dataIndex;\n            var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n            if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n                return;\n            }\n\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n            if (!seriesModel) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var tooltipModel = buildTooltipModel([\n                data.getItemModel(dataIndex),\n                seriesModel,\n                (seriesModel.coordinateSystem || {}).model,\n                tooltipModel\n            ]);\n\n            if (tooltipModel.get('trigger') !== 'axis') {\n                return;\n            }\n\n            api.dispatchAction({\n                type: 'updateAxisPointer',\n                seriesIndex: seriesIndex,\n                dataIndex: dataIndex,\n                position: payload.position\n            });\n\n            return true;\n        },\n\n        _tryShow: function (e, dispatchAction) {\n            var el = e.target;\n            var tooltipModel = this._tooltipModel;\n\n            if (!tooltipModel) {\n                return;\n            }\n\n            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n            this._lastX = e.offsetX;\n            this._lastY = e.offsetY;\n\n            var dataByCoordSys = e.dataByCoordSys;\n            if (dataByCoordSys && dataByCoordSys.length) {\n                this._showAxisTooltip(dataByCoordSys, e);\n            }\n            // Always show item tooltip if mouse is on the element with dataIndex\n            else if (el && el.dataIndex != null) {\n                this._lastDataByCoordSys = null;\n                this._showSeriesItemTooltip(e, el, dispatchAction);\n            }\n            // Tooltip provided directly. Like legend.\n            else if (el && el.tooltip) {\n                this._lastDataByCoordSys = null;\n                this._showComponentItemTooltip(e, el, dispatchAction);\n            }\n            else {\n                this._lastDataByCoordSys = null;\n                this._hide(dispatchAction);\n            }\n        },\n\n        _showOrMove: function (tooltipModel, cb) {\n            // showDelay is used in this case: tooltip.enterable is set\n            // as true. User intent to move mouse into tooltip and click\n            // something. `showDelay` makes it easyer to enter the content\n            // but tooltip do not move immediately.\n            var delay = tooltipModel.get('showDelay');\n            cb = zrUtil.bind(cb, this);\n            clearTimeout(this._showTimout);\n            delay > 0\n                ? (this._showTimout = setTimeout(cb, delay))\n                : cb();\n        },\n\n        _showAxisTooltip: function (dataByCoordSys, e) {\n            var ecModel = this._ecModel;\n            var globalTooltipModel = this._tooltipModel;\n            var point = [e.offsetX, e.offsetY];\n            var singleDefaultHTML = [];\n            var singleParamsList = [];\n            var singleTooltipModel = buildTooltipModel([\n                e.tooltipOption,\n                globalTooltipModel\n            ]);\n\n            each(dataByCoordSys, function (itemCoordSys) {\n                // var coordParamList = [];\n                // var coordDefaultHTML = [];\n                // var coordTooltipModel = buildTooltipModel([\n                //     e.tooltipOption,\n                //     itemCoordSys.tooltipOption,\n                //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),\n                //     globalTooltipModel\n                // ]);\n                // var displayMode = coordTooltipModel.get('displayMode');\n                // var paramsList = displayMode === 'single' ? singleParamsList : [];\n\n                each(itemCoordSys.dataByAxis, function (item) {\n                    var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);\n                    var axisValue = item.value;\n                    var seriesDefaultHTML = [];\n\n                    if (!axisModel || axisValue == null) {\n                        return;\n                    }\n\n                    var valueLabel = axisPointerViewHelper.getValueLabel(\n                        axisValue, axisModel.axis, ecModel,\n                        item.seriesDataIndices,\n                        item.valueLabelOpt\n                    );\n\n                    zrUtil.each(item.seriesDataIndices, function (idxItem) {\n                        var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n                        var dataIndex = idxItem.dataIndexInside;\n                        var dataParams = series && series.getDataParams(dataIndex);\n                        dataParams.axisDim = item.axisDim;\n                        dataParams.axisIndex = item.axisIndex;\n                        dataParams.axisType = item.axisType;\n                        dataParams.axisId = item.axisId;\n                        dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);\n                        dataParams.axisValueLabel = valueLabel;\n\n                        if (dataParams) {\n                            singleParamsList.push(dataParams);\n                            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));\n                        }\n                    });\n\n                    // Default tooltip content\n                    // FIXME\n                    // (1) shold be the first data which has name?\n                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n                    var firstLine = valueLabel;\n                    singleDefaultHTML.push(\n                        (firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '')\n                        + seriesDefaultHTML.join('<br />')\n                    );\n                });\n            }, this);\n\n            // In most case, the second axis is shown upper than the first one.\n            singleDefaultHTML.reverse();\n            singleDefaultHTML = singleDefaultHTML.join('<br /><br />');\n\n            var positionExpr = e.position;\n            this._showOrMove(singleTooltipModel, function () {\n                if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {\n                    this._updatePosition(\n                        singleTooltipModel,\n                        positionExpr,\n                        point[0], point[1],\n                        this._tooltipContent,\n                        singleParamsList\n                    );\n                }\n                else {\n                    this._showTooltipContent(\n                        singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(),\n                        point[0], point[1], positionExpr\n                    );\n                }\n            });\n\n            // Do not trigger events here, because this branch only be entered\n            // from dispatchAction.\n        },\n\n        _showSeriesItemTooltip: function (e, el, dispatchAction) {\n            var ecModel = this._ecModel;\n            // Use dataModel in element if possible\n            // Used when mouseover on a element like markPoint or edge\n            // In which case, the data is not main data in series.\n            var seriesIndex = el.seriesIndex;\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n            // For example, graph link.\n            var dataModel = el.dataModel || seriesModel;\n            var dataIndex = el.dataIndex;\n            var dataType = el.dataType;\n            var data = dataModel.getData();\n\n            var tooltipModel = buildTooltipModel([\n                data.getItemModel(dataIndex),\n                dataModel,\n                seriesModel && (seriesModel.coordinateSystem || {}).model,\n                this._tooltipModel\n            ]);\n\n            var tooltipTrigger = tooltipModel.get('trigger');\n            if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n                return;\n            }\n\n            var params = dataModel.getDataParams(dataIndex, dataType);\n            var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);\n            var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n\n            this._showOrMove(tooltipModel, function () {\n                this._showTooltipContent(\n                    tooltipModel, defaultHtml, params, asyncTicket,\n                    e.offsetX, e.offsetY, e.position, e.target\n                );\n            });\n\n            // FIXME\n            // duplicated showtip if manuallyShowTip is called from dispatchAction.\n            dispatchAction({\n                type: 'showTip',\n                dataIndexInside: dataIndex,\n                dataIndex: data.getRawIndex(dataIndex),\n                seriesIndex: seriesIndex,\n                from: this.uid\n            });\n        },\n\n        _showComponentItemTooltip: function (e, el, dispatchAction) {\n            var tooltipOpt = el.tooltip;\n            if (typeof tooltipOpt === 'string') {\n                var content = tooltipOpt;\n                tooltipOpt = {\n                    content: content,\n                    // Fixed formatter\n                    formatter: content\n                };\n            }\n            var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);\n            var defaultHtml = subTooltipModel.get('content');\n            var asyncTicket = Math.random();\n\n            // Do not check whether `trigger` is 'none' here, because `trigger`\n            // only works on cooridinate system. In fact, we have not found case\n            // that requires setting `trigger` nothing on component yet.\n\n            this._showOrMove(subTooltipModel, function () {\n                this._showTooltipContent(\n                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n                    asyncTicket, e.offsetX, e.offsetY, e.position, el\n                );\n            });\n\n            // If not dispatch showTip, tip may be hide triggered by axis.\n            dispatchAction({\n                type: 'showTip',\n                from: this.uid\n            });\n        },\n\n        _showTooltipContent: function (\n            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el\n        ) {\n            // Reset ticket\n            this._ticket = '';\n\n            if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n                return;\n            }\n\n            var tooltipContent = this._tooltipContent;\n\n            var formatter = tooltipModel.get('formatter');\n            positionExpr = positionExpr || tooltipModel.get('position');\n            var html = defaultHtml;\n\n            if (formatter && typeof formatter === 'string') {\n                html = formatUtil.formatTpl(formatter, params, true);\n            }\n            else if (typeof formatter === 'function') {\n                var callback = bind(function (cbTicket, html) {\n                    if (cbTicket === this._ticket) {\n                        tooltipContent.setContent(html);\n                        this._updatePosition(\n                            tooltipModel, positionExpr, x, y, tooltipContent, params, el\n                        );\n                    }\n                }, this);\n                this._ticket = asyncTicket;\n                html = formatter(params, asyncTicket, callback);\n            }\n\n            tooltipContent.setContent(html);\n            tooltipContent.show(tooltipModel);\n\n            this._updatePosition(\n                tooltipModel, positionExpr, x, y, tooltipContent, params, el\n            );\n        },\n\n        /**\n         * @param  {string|Function|Array.<number>} positionExpr\n         * @param  {number} x Mouse x\n         * @param  {number} y Mouse y\n         * @param  {boolean} confine Whether confine tooltip content in view rect.\n         * @param  {Object|<Array.<Object>} params\n         * @param  {module:zrender/Element} el target element\n         * @param  {module:echarts/ExtensionAPI} api\n         * @return {Array.<number>}\n         */\n        _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {\n            var viewWidth = this._api.getWidth();\n            var viewHeight = this._api.getHeight();\n            positionExpr = positionExpr || tooltipModel.get('position');\n\n            var contentSize = content.getSize();\n            var align = tooltipModel.get('align');\n            var vAlign = tooltipModel.get('verticalAlign');\n            var rect = el && el.getBoundingRect().clone();\n            el && rect.applyTransform(el.transform);\n\n            if (typeof positionExpr === 'function') {\n                // Callback of position can be an array or a string specify the position\n                positionExpr = positionExpr([x, y], params, content.el, rect, {\n                    viewSize: [viewWidth, viewHeight],\n                    contentSize: contentSize.slice()\n                });\n            }\n\n            if (zrUtil.isArray(positionExpr)) {\n                x = parsePercent(positionExpr[0], viewWidth);\n                y = parsePercent(positionExpr[1], viewHeight);\n            }\n            else if (zrUtil.isObject(positionExpr)) {\n                positionExpr.width = contentSize[0];\n                positionExpr.height = contentSize[1];\n                var layoutRect = layoutUtil.getLayoutRect(\n                    positionExpr, {width: viewWidth, height: viewHeight}\n                );\n                x = layoutRect.x;\n                y = layoutRect.y;\n                align = null;\n                // When positionExpr is left/top/right/bottom,\n                // align and verticalAlign will not work.\n                vAlign = null;\n            }\n            // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n            else if (typeof positionExpr === 'string' && el) {\n                var pos = calcTooltipPosition(\n                    positionExpr, rect, contentSize\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n            else {\n                var pos = refixTooltipPosition(\n                    x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n\n            align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n            vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n\n            if (tooltipModel.get('confine')) {\n                var pos = confineTooltipPosition(\n                    x, y, content.el, viewWidth, viewHeight\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n\n            content.moveTo(x, y);\n        },\n\n        // FIXME\n        // Should we remove this but leave this to user?\n        _updateContentNotChangedOnAxis: function (dataByCoordSys) {\n            var lastCoordSys = this._lastDataByCoordSys;\n            var contentNotChanged = !!lastCoordSys\n                && lastCoordSys.length === dataByCoordSys.length;\n\n            contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n                var lastDataByAxis = lastItemCoordSys.dataByAxis || {};\n                var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n                var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n                contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;\n\n                contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {\n                    var thisItem = thisDataByAxis[indexAxis] || {};\n                    var lastIndices = lastItem.seriesDataIndices || [];\n                    var newIndices = thisItem.seriesDataIndices || [];\n\n                    contentNotChanged &=\n                        lastItem.value === thisItem.value\n                        && lastItem.axisType === thisItem.axisType\n                        && lastItem.axisId === thisItem.axisId\n                        && lastIndices.length === newIndices.length;\n\n                    contentNotChanged && each(lastIndices, function (lastIdxItem, j) {\n                        var newIdxItem = newIndices[j];\n                        contentNotChanged &=\n                            lastIdxItem.seriesIndex === newIdxItem.seriesIndex\n                            && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n                    });\n                });\n            });\n\n            this._lastDataByCoordSys = dataByCoordSys;\n\n            return !!contentNotChanged;\n        },\n\n        _hide: function (dispatchAction) {\n            // Do not directly hideLater here, because this behavior may be prevented\n            // in dispatchAction when showTip is dispatched.\n\n            // FIXME\n            // duplicated hideTip if manuallyHideTip is called from dispatchAction.\n            this._lastDataByCoordSys = null;\n            dispatchAction({\n                type: 'hideTip',\n                from: this.uid\n            });\n        },\n\n        dispose: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            this._tooltipContent.hide();\n            globalListener.unregister('itemTooltip', api);\n        }\n    });\n\n\n    /**\n     * @param {Array.<Object|module:echarts/model/Model>} modelCascade\n     * From top to bottom. (the last one should be globalTooltipModel);\n     */\n    function buildTooltipModel(modelCascade) {\n        var resultModel = modelCascade.pop();\n        while (modelCascade.length) {\n            var tooltipOpt = modelCascade.pop();\n            if (tooltipOpt) {\n                if (tooltipOpt instanceof Model) {\n                    tooltipOpt = tooltipOpt.get('tooltip', true);\n                }\n                // In each data item tooltip can be simply write:\n                // {\n                //  value: 10,\n                //  tooltip: 'Something you need to know'\n                // }\n                if (typeof tooltipOpt === 'string') {\n                    tooltipOpt = {formatter: tooltipOpt};\n                }\n                resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);\n            }\n        }\n        return resultModel;\n    }\n\n    function makeDispatchAction(payload, api) {\n        return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n    }\n\n    function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        if (gapH != null) {\n            if (x + width + gapH > viewWidth) {\n                x -= width + gapH;\n            }\n            else {\n                x += gapH;\n            }\n        }\n        if (gapV != null) {\n            if (y + height + gapV > viewHeight) {\n                y -= height + gapV;\n            }\n            else {\n                y += gapV;\n            }\n        }\n        return [x, y];\n    }\n\n    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        x = Math.min(x + width, viewWidth) - width;\n        y = Math.min(y + height, viewHeight) - height;\n        x = Math.max(x, 0);\n        y = Math.max(y, 0);\n\n        return [x, y];\n    }\n\n    function calcTooltipPosition(position, rect, contentSize) {\n        var domWidth = contentSize[0];\n        var domHeight = contentSize[1];\n        var gap = 5;\n        var x = 0;\n        var y = 0;\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n        switch (position) {\n            case 'inside':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'top':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y - domHeight - gap;\n                break;\n            case 'bottom':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight + gap;\n                break;\n            case 'left':\n                x = rect.x - domWidth - gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'right':\n                x = rect.x + rectWidth + gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n        }\n        return [x, y];\n    }\n\n    function isCenterAlign(align) {\n        return align === 'center' || align === 'middle';\n    }\n\n\n\n/***/ }),\n/* 325 */,\n/* 326 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// TODO boundaryGap\n\n\n    __webpack_require__(258);\n\n    __webpack_require__(327);\n\n\n/***/ }),\n/* 327 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var graphic = __webpack_require__(192);\n    var AxisBuilder = __webpack_require__(229);\n    var AxisView = __webpack_require__(233);\n    var cartesianAxisHelper = __webpack_require__(253);\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n    var getInterval = AxisBuilder.getInterval;\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n    var selfBuilderAttrs = [\n        'splitArea', 'splitLine'\n    ];\n\n    // function getAlignWithLabel(model, axisModel) {\n    //     var alignWithLabel = model.get('alignWithLabel');\n    //     if (alignWithLabel === 'auto') {\n    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n    //     }\n    //     return alignWithLabel;\n    // }\n\n    var CartesianAxisView = AxisView.extend({\n\n        type: 'cartesianAxis',\n\n        axisPointerClass: 'CartesianAxisPointer',\n\n        /**\n         * @override\n         */\n        render: function (axisModel, ecModel, api, payload) {\n\n            this.group.removeAll();\n\n            var oldAxisGroup = this._axisGroup;\n            this._axisGroup = new graphic.Group();\n\n            this.group.add(this._axisGroup);\n\n            if (!axisModel.get('show')) {\n                return;\n            }\n\n            var gridModel = axisModel.getCoordSysModel();\n\n            var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n\n            var axisBuilder = new AxisBuilder(axisModel, layout);\n\n            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n            this._axisGroup.add(axisBuilder.getGroup());\n\n            zrUtil.each(selfBuilderAttrs, function (name) {\n                if (axisModel.get(name + '.show')) {\n                    this['_' + name](axisModel, gridModel, layout.labelInterval);\n                }\n            }, this);\n\n            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n\n            CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitLine: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.scale.isBlank()) {\n                return;\n            }\n\n            var splitLineModel = axisModel.getModel('splitLine');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var lineColors = lineStyleModel.get('color');\n\n            var lineInterval = getInterval(splitLineModel, labelInterval);\n\n            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n            var isHorizontal = axis.isHorizontal();\n\n            var lineCount = 0;\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitLineModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var p1 = [];\n            var p2 = [];\n            // Simple optimization\n            // Batching the lines if color are the same\n            var lineStyle = lineStyleModel.getLineStyle();\n            for (var i = 0; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, lineInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                if (isHorizontal) {\n                    p1[0] = tickCoord;\n                    p1[1] = gridRect.y;\n                    p2[0] = tickCoord;\n                    p2[1] = gridRect.y + gridRect.height;\n                }\n                else {\n                    p1[0] = gridRect.x;\n                    p1[1] = tickCoord;\n                    p2[0] = gridRect.x + gridRect.width;\n                    p2[1] = tickCoord;\n                }\n\n                var colorIndex = (lineCount++) % lineColors.length;\n                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                    anid: 'line_' + ticks[i],\n\n                    shape: {\n                        x1: p1[0],\n                        y1: p1[1],\n                        x2: p2[0],\n                        y2: p2[1]\n                    },\n                    style: zrUtil.defaults({\n                        stroke: lineColors[colorIndex]\n                    }, lineStyle),\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitArea: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.scale.isBlank()) {\n                return;\n            }\n\n            var splitAreaModel = axisModel.getModel('splitArea');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n            var areaColors = areaStyleModel.get('color');\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitAreaModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var prevX = axis.toGlobalCoord(ticksCoords[0]);\n            var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\n            var count = 0;\n\n            var areaInterval = getInterval(splitAreaModel, labelInterval);\n\n            var areaStyle = areaStyleModel.getAreaStyle();\n            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n            for (var i = 1; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, areaInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                var x;\n                var y;\n                var width;\n                var height;\n                if (axis.isHorizontal()) {\n                    x = prevX;\n                    y = gridRect.y;\n                    width = tickCoord - x;\n                    height = gridRect.height;\n                }\n                else {\n                    x = gridRect.x;\n                    y = prevY;\n                    width = gridRect.width;\n                    height = tickCoord - y;\n                }\n\n                var colorIndex = (count++) % areaColors.length;\n                this._axisGroup.add(new graphic.Rect({\n                    anid: 'area_' + ticks[i],\n\n                    shape: {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    },\n                    style: zrUtil.defaults({\n                        fill: areaColors[colorIndex]\n                    }, areaStyle),\n                    silent: true\n                }));\n\n                prevX = x + width;\n                prevY = y + height;\n            }\n        }\n    });\n\n    CartesianAxisView.extend({\n        type: 'xAxis'\n    });\n    CartesianAxisView.extend({\n        type: 'yAxis'\n    });\n\n\n\n/***/ }),\n/* 328 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    __webpack_require__(255);\n\n    __webpack_require__(254);\n\n    __webpack_require__(248);\n\n\n\n/***/ }),\n/* 329 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var Axis = __webpack_require__(227);\n\n    /**\n     * Extend axis 2d\n     * @constructor module:echarts/coord/cartesian/Axis2D\n     * @extends {module:echarts/coord/cartesian/Axis}\n     * @param {string} dim\n     * @param {*} scale\n     * @param {Array.<number>} coordExtent\n     * @param {string} axisType\n     * @param {string} position\n     */\n    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n        Axis.call(this, dim, scale, coordExtent);\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = axisType || 'value';\n\n        /**\n         * Axis position\n         *  - 'top'\n         *  - 'bottom'\n         *  - 'left'\n         *  - 'right'\n         */\n        this.position = position || 'bottom';\n    };\n\n    Axis2D.prototype = {\n\n        constructor: Axis2D,\n\n        /**\n         * Index of axis, can be used as key\n         */\n        index: 0,\n        /**\n         * If axis is on the zero position of the other axis\n         * @type {boolean}\n         */\n        onZero: false,\n\n        /**\n         * Axis model\n         * @param {module:echarts/coord/cartesian/AxisModel}\n         */\n        model: null,\n\n        isHorizontal: function () {\n            var position = this.position;\n            return position === 'top' || position === 'bottom';\n        },\n\n        /**\n         * Each item cooresponds to this.getExtent(), which\n         * means globalExtent[0] may greater than globalExtent[1],\n         * unless `asc` is input.\n         *\n         * @param {boolean} [asc]\n         * @return {Array.<number>}\n         */\n        getGlobalExtent: function (asc) {\n            var ret = this.getExtent();\n            ret[0] = this.toGlobalCoord(ret[0]);\n            ret[1] = this.toGlobalCoord(ret[1]);\n            asc && ret[0] > ret[1] && ret.reverse();\n            return ret;\n        },\n\n        getOtherAxis: function () {\n            this.grid.getOtherAxis();\n        },\n\n        /**\n         * If label is ignored.\n         * Automatically used when axis is category and label can not be all shown\n         * @param  {number}  idx\n         * @return {boolean}\n         */\n        isLabelIgnored: function (idx) {\n            if (this.type === 'category') {\n                var labelInterval = this.getLabelInterval();\n                return ((typeof labelInterval === 'function')\n                    && !labelInterval(idx, this.scale.getLabel(idx)))\n                    || idx % (labelInterval + 1);\n            }\n        },\n\n        /**\n         * @override\n         */\n        pointToData: function (point, clamp) {\n            return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n        },\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var localCoord = axis.toLocalCoord(80);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toLocalCoord: null,\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var globalCoord = axis.toLocalCoord(40);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toGlobalCoord: null\n\n    };\n    zrUtil.inherits(Axis2D, Axis);\n\n    module.exports = Axis2D;\n\n\n/***/ }),\n/* 330 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\n\n\n    var zrUtil = __webpack_require__(190);\n\n    function dimAxisMapper(dim) {\n        return this._axes[dim];\n    }\n\n    /**\n     * @alias module:echarts/coord/Cartesian\n     * @constructor\n     */\n    var Cartesian = function (name) {\n        this._axes = {};\n\n        this._dimList = [];\n\n        /**\n         * @type {string}\n         */\n        this.name = name || '';\n    };\n\n    Cartesian.prototype = {\n\n        constructor: Cartesian,\n\n        type: 'cartesian',\n\n        /**\n         * Get axis\n         * @param  {number|string} dim\n         * @return {module:echarts/coord/Cartesian~Axis}\n         */\n        getAxis: function (dim) {\n            return this._axes[dim];\n        },\n\n        /**\n         * Get axes list\n         * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n         */\n        getAxes: function () {\n            return zrUtil.map(this._dimList, dimAxisMapper, this);\n        },\n\n        /**\n         * Get axes list by given scale type\n         */\n        getAxesByScale: function (scaleType) {\n            scaleType = scaleType.toLowerCase();\n            return zrUtil.filter(\n                this.getAxes(),\n                function (axis) {\n                    return axis.scale.type === scaleType;\n                }\n            );\n        },\n\n        /**\n         * Add axis\n         * @param {module:echarts/coord/Cartesian.Axis}\n         */\n        addAxis: function (axis) {\n            var dim = axis.dim;\n\n            this._axes[dim] = axis;\n\n            this._dimList.push(dim);\n        },\n\n        /**\n         * Convert data to coord in nd space\n         * @param {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        dataToCoord: function (val) {\n            return this._dataCoordConvert(val, 'dataToCoord');\n        },\n\n        /**\n         * Convert coord in nd space to data\n         * @param  {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        coordToData: function (val) {\n            return this._dataCoordConvert(val, 'coordToData');\n        },\n\n        _dataCoordConvert: function (input, method) {\n            var dimList = this._dimList;\n\n            var output = input instanceof Array ? [] : {};\n\n            for (var i = 0; i < dimList.length; i++) {\n                var dim = dimList[i];\n                var axis = this._axes[dim];\n\n                output[dim] = axis[method](input[dim]);\n            }\n\n            return output;\n        }\n    };\n\n    module.exports = Cartesian;\n\n\n/***/ }),\n/* 331 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var Cartesian = __webpack_require__(330);\n\n    function Cartesian2D(name) {\n\n        Cartesian.call(this, name);\n    }\n\n    Cartesian2D.prototype = {\n\n        constructor: Cartesian2D,\n\n        type: 'cartesian2d',\n\n        /**\n         * @type {Array.<string>}\n         * @readOnly\n         */\n        dimensions: ['x', 'y'],\n\n        /**\n         * Base axis will be used on stacking.\n         *\n         * @return {module:echarts/coord/cartesian/Axis2D}\n         */\n        getBaseAxis: function () {\n            return this.getAxesByScale('ordinal')[0]\n                || this.getAxesByScale('time')[0]\n                || this.getAxis('x');\n        },\n\n        /**\n         * If contain point\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        containPoint: function (point) {\n            var axisX = this.getAxis('x');\n            var axisY = this.getAxis('y');\n            return axisX.contain(axisX.toLocalCoord(point[0]))\n                && axisY.contain(axisY.toLocalCoord(point[1]));\n        },\n\n        /**\n         * If contain data\n         * @param {Array.<number>} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.getAxis('x').containData(data[0])\n                && this.getAxis('y').containData(data[1]);\n        },\n\n        /**\n         * Convert series data to an array of points\n         * @param {module:echarts/data/List} data\n         * @param {boolean} stack\n         * @return {Array}\n         *  Return array of points. For example:\n         *  `[[10, 10], [20, 20], [30, 30]]`\n         */\n        dataToPoints: function (data, stack) {\n            return data.mapArray(['x', 'y'], function (x, y) {\n                return this.dataToPoint([x, y]);\n            }, stack, this);\n        },\n\n        /**\n         * @param {Array.<number>} data\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        dataToPoint: function (data, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n            ];\n        },\n\n        /**\n         * @param {Array.<number>} point\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        pointToData: function (point, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n            ];\n        },\n\n        /**\n         * Get other axis\n         * @param {module:echarts/coord/cartesian/Axis2D} axis\n         */\n        getOtherAxis: function (axis) {\n            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n        }\n\n    };\n\n    zrUtil.inherits(Cartesian2D, Cartesian);\n\n    module.exports = Cartesian2D;\n\n\n/***/ }),\n/* 332 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Grid \n//  Cartesian2D \n\n\n    __webpack_require__(258);\n\n    var ComponentModel = __webpack_require__(202);\n\n    module.exports = ComponentModel.extend({\n\n        type: 'grid',\n\n        dependencies: ['xAxis', 'yAxis'],\n\n        layoutMode: 'box',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Grid}\n         */\n        coordinateSystem: null,\n\n        defaultOption: {\n            show: false,\n            zlevel: 0,\n            z: 0,\n            left: '10%',\n            top: 60,\n            right: '10%',\n            bottom: 60,\n            // If grid size contain label\n            containLabel: false,\n            // width: {totalWidth} - left - right,\n            // height: {totalHeight} - top - bottom,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 1,\n            borderColor: '#ccc'\n        }\n    });\n\n\n/***/ }),\n/* 333 */,\n/* 334 */,\n/* 335 */,\n/* 336 */,\n/* 337 */,\n/* 338 */,\n/* 339 */,\n/* 340 */,\n/* 341 */,\n/* 342 */,\n/* 343 */,\n/* 344 */,\n/* 345 */,\n/* 346 */,\n/* 347 */,\n/* 348 */,\n/* 349 */,\n/* 350 */,\n/* 351 */,\n/* 352 */,\n/* 353 */,\n/* 354 */,\n/* 355 */,\n/* 356 */,\n/* 357 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var numberUtil = __webpack_require__(193);\n    var parsePercent = numberUtil.parsePercent;\n\n    var STACK_PREFIX = '__ec_stack_';\n\n    function getSeriesStackId(seriesModel) {\n        return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n    }\n\n    function getAxisKey(axis) {\n        return axis.dim + axis.index;\n    }\n\n    /**\n     * @param {Object} opt\n     * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n     * @param {number} opt.count Positive interger.\n     * @param {number} [opt.barWidth]\n     * @param {number} [opt.barMaxWidth]\n     * @param {number} [opt.barGap]\n     * @param {number} [opt.barCategoryGap]\n     * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n     */\n    function getLayoutOnAxis(opt, api) {\n        var params = [];\n        var baseAxis = opt.axis;\n        var axisKey = 'axis0';\n\n        if (baseAxis.type !== 'category') {\n            return;\n        }\n        var bandWidth = baseAxis.getBandWidth();\n\n        for (var i = 0; i < opt.count || 0; i++) {\n            params.push(zrUtil.defaults({\n                bandWidth: bandWidth,\n                axisKey: axisKey,\n                stackId: STACK_PREFIX + i\n            }, opt));\n        }\n        var widthAndOffsets = doCalBarWidthAndOffset(params, api);\n\n        var result = [];\n        for (var i = 0; i < opt.count; i++) {\n            var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n            item.offsetCenter = item.offset + item.width / 2;\n            result.push(item);\n        }\n\n        return result;\n    }\n\n    function calBarWidthAndOffset(barSeries, api) {\n        var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var axisExtent = baseAxis.getExtent();\n            var bandWidth = baseAxis.type === 'category'\n                ? baseAxis.getBandWidth()\n                : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());\n\n            var barWidth = parsePercent(\n                seriesModel.get('barWidth'), bandWidth\n            );\n            var barMaxWidth = parsePercent(\n                seriesModel.get('barMaxWidth'), bandWidth\n            );\n            var barGap = seriesModel.get('barGap');\n            var barCategoryGap = seriesModel.get('barCategoryGap');\n\n            return {\n                bandWidth: bandWidth,\n                barWidth: barWidth,\n                barMaxWidth: barMaxWidth,\n                barGap: barGap,\n                barCategoryGap: barCategoryGap,\n                axisKey: getAxisKey(baseAxis),\n                stackId: getSeriesStackId(seriesModel)\n            };\n        });\n\n        return doCalBarWidthAndOffset(seriesInfoList, api);\n    }\n\n    function doCalBarWidthAndOffset(seriesInfoList, api) {\n        // Columns info on each category axis. Key is cartesian name\n        var columnsMap = {};\n\n        zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n            var axisKey = seriesInfo.axisKey;\n            var bandWidth = seriesInfo.bandWidth;\n            var columnsOnAxis = columnsMap[axisKey] || {\n                bandWidth: bandWidth,\n                remainedWidth: bandWidth,\n                autoWidthCount: 0,\n                categoryGap: '20%',\n                gap: '30%',\n                stacks: {}\n            };\n            var stacks = columnsOnAxis.stacks;\n            columnsMap[axisKey] = columnsOnAxis;\n\n            var stackId = seriesInfo.stackId;\n\n            if (!stacks[stackId]) {\n                columnsOnAxis.autoWidthCount++;\n            }\n            stacks[stackId] = stacks[stackId] || {\n                width: 0,\n                maxWidth: 0\n            };\n\n            // Caution: In a single coordinate system, these barGrid attributes\n            // will be shared by series. Consider that they have default values,\n            // only the attributes set on the last series will work.\n            // Do not change this fact unless there will be a break change.\n\n            // TODO\n            var barWidth = seriesInfo.barWidth;\n            if (barWidth && !stacks[stackId].width) {\n                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n                stacks[stackId].width = barWidth;\n                columnsOnAxis.remainedWidth -= barWidth;\n            }\n\n            var barMaxWidth = seriesInfo.barMaxWidth;\n            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n            var barGap = seriesInfo.barGap;\n            (barGap != null) && (columnsOnAxis.gap = barGap);\n            var barCategoryGap = seriesInfo.barCategoryGap;\n            (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);\n        });\n\n        var result = {};\n\n        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\n            result[coordSysName] = {};\n\n            var stacks = columnsOnAxis.stacks;\n            var bandWidth = columnsOnAxis.bandWidth;\n            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\n            var remainedWidth = columnsOnAxis.remainedWidth;\n            var autoWidthCount = columnsOnAxis.autoWidthCount;\n            var autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            // Find if any auto calculated bar exceeded maxBarWidth\n            zrUtil.each(stacks, function (column, stack) {\n                var maxWidth = column.maxWidth;\n                if (maxWidth && maxWidth < autoWidth) {\n                    maxWidth = Math.min(maxWidth, remainedWidth);\n                    if (column.width) {\n                        maxWidth = Math.min(maxWidth, column.width);\n                    }\n                    remainedWidth -= maxWidth;\n                    column.width = maxWidth;\n                    autoWidthCount--;\n                }\n            });\n\n            // Recalculate width again\n            autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            var widthSum = 0;\n            var lastColumn;\n            zrUtil.each(stacks, function (column, idx) {\n                if (!column.width) {\n                    column.width = autoWidth;\n                }\n                lastColumn = column;\n                widthSum += column.width * (1 + barGapPercent);\n            });\n            if (lastColumn) {\n                widthSum -= lastColumn.width * barGapPercent;\n            }\n\n            var offset = -widthSum / 2;\n            zrUtil.each(stacks, function (column, stackId) {\n                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                    offset: offset,\n                    width: column.width\n                };\n\n                offset += column.width * (1 + barGapPercent);\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * @param {string} seriesType\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function barLayoutGrid(seriesType, ecModel, api) {\n\n        var barWidthAndOffset = calBarWidthAndOffset(\n            zrUtil.filter(\n                ecModel.getSeriesByType(seriesType),\n                function (seriesModel) {\n                    return !ecModel.isSeriesFiltered(seriesModel)\n                        && seriesModel.coordinateSystem\n                        && seriesModel.coordinateSystem.type === 'cartesian2d';\n                }\n            )\n        );\n\n        var lastStackCoords = {};\n        var lastStackCoordsOrigin = {};\n\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\n            // Check series coordinate, do layout for cartesian2d only\n            if (seriesModel.coordinateSystem.type !== 'cartesian2d') {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n\n            var stackId = getSeriesStackId(seriesModel);\n            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n            var columnOffset = columnLayoutInfo.offset;\n            var columnWidth = columnLayoutInfo.width;\n            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\n            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\n            var valueAxisStart = baseAxis.onZero\n                ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))\n                : valueAxis.getGlobalExtent()[0];\n\n            var coords = cartesian.dataToPoints(data, true);\n            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n            lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n            data.setLayout({\n                offset: columnOffset,\n                size: columnWidth\n            });\n\n            data.each(valueAxis.dim, function (value, idx) {\n                if (isNaN(value)) {\n                    return;\n                }\n\n                if (!lastStackCoords[stackId][idx]) {\n                    lastStackCoords[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                    lastStackCoordsOrigin[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                }\n                var sign = value >= 0 ? 'p' : 'n';\n                var coord = coords[idx];\n                var lastCoord = lastStackCoords[stackId][idx][sign];\n                var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n                var x;\n                var y;\n                var width;\n                var height;\n\n                if (valueAxis.isHorizontal()) {\n                    x = lastCoord;\n                    y = coord[1] + columnOffset;\n                    width = coord[0] - lastCoordOrigin;\n                    height = columnWidth;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += width;\n                    if (Math.abs(width) < barMinHeight) {\n                        width = (width < 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += width;\n                }\n                else {\n                    x = coord[0] + columnOffset;\n                    y = lastCoord;\n                    width = columnWidth;\n                    height = coord[1] - lastCoordOrigin;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += height;\n                    if (Math.abs(height) < barMinHeight) {\n                        // Include zero to has a positive bar\n                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += height;\n                }\n\n                data.setItemLayout(idx, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }, true);\n\n        }, this);\n    }\n\n    barLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;\n\n    module.exports = barLayoutGrid;\n\n\n/***/ }),\n/* 358 */,\n/* 359 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var SeriesModel = __webpack_require__(217);\n    var createListFromArray = __webpack_require__(228);\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.__base_bar__',\n\n        getInitialData: function (option, ecModel) {\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        getMarkerPosition: function (value) {\n            var coordSys = this.coordinateSystem;\n            if (coordSys) {\n                // PENDING if clamp ?\n                var pt = coordSys.dataToPoint(value, true);\n                var data = this.getData();\n                var offset = data.getLayout('offset');\n                var size = data.getLayout('size');\n                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n                pt[offsetIndex] += offset + size / 2;\n                return pt;\n            }\n            return [NaN, NaN];\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // \n            z: 2,                       // \n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n            // stack: null\n\n            // Cartesian coordinate system\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // 0\n            barMinHeight: 0,\n            // 0\n            barMinAngle: 0,\n            // cursor: null,\n\n            // barMaxWidth: null,\n            // \n            // barWidth: null,\n            // 30%\n            // barGap: '30%',\n            // 20%\n            // barCategoryGap: '20%',\n            // label: {\n            //     normal: {\n            //         show: false\n            //     }\n            // },\n            itemStyle: {\n                normal: {\n                    // color: ''\n                },\n                emphasis: {}\n            }\n        }\n    });\n\n\n/***/ }),\n/* 360 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var graphic = __webpack_require__(192);\n\n    var helper = {};\n\n    helper.setLabel = function (\n        normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside\n    ) {\n        var labelModel = itemModel.getModel('label.normal');\n        var hoverLabelModel = itemModel.getModel('label.emphasis');\n\n        if (labelModel.get('show')) {\n            setLabel(\n                normalStyle, labelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'normal'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            normalStyle.text = '';\n        }\n\n        if (hoverLabelModel.get('show')) {\n            setLabel(\n                hoverStyle, hoverLabelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'emphasis'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            hoverStyle.text = '';\n        }\n    };\n\n    function setLabel(style, model, color, labelText, labelPositionOutside) {\n        graphic.setText(style, model, color);\n        style.text = labelText;\n        if (style.textPosition === 'outside') {\n            style.textPosition = labelPositionOutside;\n        }\n    }\n\n    module.exports = helper;\n\n\n/***/ }),\n/* 361 */,\n/* 362 */,\n/* 363 */,\n/* 364 */,\n/* 365 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(190);\n\n    __webpack_require__(317);\n\n    __webpack_require__(366);\n    __webpack_require__(367);\n\n    var barLayoutGrid = __webpack_require__(357);\n    var echarts = __webpack_require__(191);\n\n    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n\n    // Visual coding for legend\n    echarts.registerVisual(function (ecModel) {\n        ecModel.eachSeriesByType('bar', function (seriesModel) {\n            var data = seriesModel.getData();\n            data.setVisual('legendSymbol', 'roundRect');\n        });\n    });\n\n    // In case developer forget to include grid component\n    __webpack_require__(255);\n\n\n/***/ }),\n/* 366 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    module.exports = __webpack_require__(359).extend({\n\n        type: 'series.bar',\n\n        dependencies: ['grid', 'polar'],\n\n        brushSelector: 'rect'\n    });\n\n\n/***/ }),\n/* 367 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(190);\n    var graphic = __webpack_require__(192);\n    var helper = __webpack_require__(360);\n\n    var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth'];\n\n    // FIXME\n    // Just for compatible with ec2.\n    zrUtil.extend(__webpack_require__(199).prototype, __webpack_require__(368));\n\n    var BarView = __webpack_require__(191).extendChartView({\n\n        type: 'bar',\n\n        render: function (seriesModel, ecModel, api) {\n            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n            if (coordinateSystemType === 'cartesian2d'\n                || coordinateSystemType === 'polar'\n            ) {\n                this._render(seriesModel, ecModel, api);\n            }\n            else if (__DEV__) {\n                console.warn('Only cartesian2d and polar supported for bar.');\n            }\n\n            return this.group;\n        },\n\n        dispose: zrUtil.noop,\n\n        _render: function (seriesModel, ecModel, api) {\n            var group = this.group;\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            var coord = seriesModel.coordinateSystem;\n            var baseAxis = coord.getBaseAxis();\n            var isHorizontalOrRadial;\n\n            if (coord.type === 'cartesian2d') {\n                isHorizontalOrRadial = baseAxis.isHorizontal();\n            }\n            else if (coord.type === 'polar') {\n                isHorizontalOrRadial = baseAxis.dim === 'angle';\n            }\n\n            var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n\n            data.diff(oldData)\n                .add(function (dataIndex) {\n                    if (!data.hasValue(dataIndex)) {\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(dataIndex);\n                    var layout = getLayout[coord.type](data, dataIndex, itemModel);\n                    var el = elementCreator[coord.type](\n                        data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel\n                    );\n                    data.setItemGraphicEl(dataIndex, el);\n                    group.add(el);\n\n                    updateStyle(\n                        el, data, dataIndex, itemModel, layout,\n                        seriesModel, isHorizontalOrRadial, coord.type === 'polar'\n                    );\n                })\n                .update(function (newIndex, oldIndex) {\n                    var el = oldData.getItemGraphicEl(oldIndex);\n\n                    if (!data.hasValue(newIndex)) {\n                        group.remove(el);\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(newIndex);\n                    var layout = getLayout[coord.type](data, newIndex, itemModel);\n\n                    if (el) {\n                        graphic.updateProps(el, {shape: layout}, animationModel, newIndex);\n                    }\n                    else {\n                        el = elementCreator[coord.type](\n                            data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true\n                        );\n                    }\n\n                    data.setItemGraphicEl(newIndex, el);\n                    // Add back\n                    group.add(el);\n\n                    updateStyle(\n                        el, data, newIndex, itemModel, layout,\n                        seriesModel, isHorizontalOrRadial, coord.type === 'polar'\n                    );\n                })\n                .remove(function (dataIndex) {\n                    var el = oldData.getItemGraphicEl(dataIndex);\n                    if (coord.type === 'cartesian2d') {\n                        el && removeRect(dataIndex, animationModel, el);\n                    }\n                    else {\n                        el && removeSector(dataIndex, animationModel, el);\n                    }\n                })\n                .execute();\n\n            this._data = data;\n        },\n\n        remove: function (ecModel, api) {\n            var group = this.group;\n            var data = this._data;\n            if (ecModel.get('animation')) {\n                if (data) {\n                    data.eachItemGraphicEl(function (el) {\n                        if (el.type === 'sector') {\n                            removeSector(el.dataIndex, ecModel, el);\n                        }\n                        else {\n                            removeRect(el.dataIndex, ecModel, el);\n                        }\n                    });\n                }\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    });\n\n    var elementCreator = {\n\n        cartesian2d: function (\n            data, dataIndex, itemModel, layout, isHorizontal,\n            animationModel, isUpdate\n        ) {\n            var rect = new graphic.Rect({shape: zrUtil.extend({}, layout)});\n\n            // Animation\n            if (animationModel) {\n                var rectShape = rect.shape;\n                var animateProperty = isHorizontal ? 'height' : 'width';\n                var animateTarget = {};\n                rectShape[animateProperty] = 0;\n                animateTarget[animateProperty] = layout[animateProperty];\n                graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n                    shape: animateTarget\n                }, animationModel, dataIndex);\n            }\n\n            return rect;\n        },\n\n        polar: function (\n            data, dataIndex, itemModel, layout, isRadial,\n            animationModel, isUpdate\n        ) {\n            var sector = new graphic.Sector({shape: zrUtil.extend({}, layout)});\n\n            // Animation\n            if (animationModel) {\n                var sectorShape = sector.shape;\n                var animateProperty = isRadial ? 'r' : 'endAngle';\n                var animateTarget = {};\n                sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n                animateTarget[animateProperty] = layout[animateProperty];\n                graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {\n                    shape: animateTarget\n                }, animationModel, dataIndex);\n            }\n\n            return sector;\n        }\n    };\n\n    function removeRect(dataIndex, animationModel, el) {\n        // Not show text when animating\n        el.style.text = '';\n        graphic.updateProps(el, {\n            shape: {\n                width: 0\n            }\n        }, animationModel, dataIndex, function () {\n            el.parent && el.parent.remove(el);\n        });\n    }\n\n    function removeSector(dataIndex, animationModel, el) {\n        // Not show text when animating\n        el.style.text = '';\n        graphic.updateProps(el, {\n            shape: {\n                r: el.shape.r0\n            }\n        }, animationModel, dataIndex, function () {\n            el.parent && el.parent.remove(el);\n        });\n    }\n\n    var getLayout = {\n        cartesian2d: function (data, dataIndex, itemModel) {\n            var layout = data.getItemLayout(dataIndex);\n            var fixedLineWidth = getLineWidth(itemModel, layout);\n\n            // fix layout with lineWidth\n            var signX = layout.width > 0 ? 1 : -1;\n            var signY = layout.height > 0 ? 1 : -1;\n            return {\n                x: layout.x + signX * fixedLineWidth / 2,\n                y: layout.y + signY * fixedLineWidth / 2,\n                width: layout.width - signX * fixedLineWidth,\n                height: layout.height - signY * fixedLineWidth\n            };\n        },\n\n        polar: function (data, dataIndex, itemModel) {\n            var layout = data.getItemLayout(dataIndex);\n            return {\n                cx: layout.cx,\n                cy: layout.cy,\n                r0: layout.r0,\n                r: layout.r,\n                startAngle: layout.startAngle,\n                endAngle: layout.endAngle\n            };\n        }\n    };\n\n    function updateStyle(\n        el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar\n    ) {\n        var color = data.getItemVisual(dataIndex, 'color');\n        var opacity = data.getItemVisual(dataIndex, 'opacity');\n        var itemStyleModel = itemModel.getModel('itemStyle.normal');\n        var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n        if (!isPolar) {\n            el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n        }\n\n        el.useStyle(zrUtil.defaults(\n            {\n                fill: color,\n                opacity: opacity\n            },\n            itemStyleModel.getBarItemStyle()\n        ));\n\n        var cursorStyle = itemModel.getShallow('cursor');\n        cursorStyle && el.attr('cursor', cursorStyle);\n\n        var labelPositionOutside = isHorizontal\n            ? (layout.height > 0 ? 'bottom' : 'top')\n            : (layout.width > 0 ? 'left' : 'right');\n\n        if (!isPolar) {\n            helper.setLabel(\n                el.style, hoverStyle, itemModel, color,\n                seriesModel, dataIndex, labelPositionOutside\n            );\n        }\n\n        graphic.setHoverStyle(el, hoverStyle);\n    }\n\n    // In case width or height are too small.\n    function getLineWidth(itemModel, rawLayout) {\n        var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n        return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n    }\n\n    module.exports = BarView;\n\n\n/***/ }),\n/* 368 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n\n    var getBarItemStyle = __webpack_require__(220)(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            // Compatitable with 2\n            ['stroke', 'barBorderColor'],\n            ['lineWidth', 'barBorderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getBarItemStyle: function (excludes) {\n            var style = getBarItemStyle.call(this, excludes);\n            if (this.getBorderLineDash) {\n                var lineDash = this.getBorderLineDash();\n                lineDash && (style.lineDash = lineDash);\n            }\n            return style;\n        }\n    };\n\n\n/***/ })\n]));\n\n\n// WEBPACK FOOTER //\n// static/js/BarReact.af9ef152.chunk.js","/**\n * Created by yongyuehuang on 2017/8/5.\n */\nimport React from 'react'\nimport echarts from 'echarts/lib/echarts' //\nimport 'echarts/lib/component/tooltip'\nimport 'echarts/lib/component/grid'\nimport 'echarts/lib/chart/bar'\n\nexport default class BarReact extends React.Component {\n  \n  constructor(props) {\n    super(props)\n    this.initPie = this.initPie.bind(this)\n  }\n  \n  initPie() {\n    const { option={} } = this.props //data\n    let myChart = echarts.init(this.ID) //echarts\n    \n    //options\n    myChart.setOption(option)\n    window.onresize = function() {\n      myChart.resize()\n    }\n  }\n  \n  componentDidMount() {\n    this.initPie()\n  }\n  \n  componentDidUpdate() {\n    this.initPie()\n  }\n  \n  render() {\n    const { width=\"100%\", height=\"200px\"} = this.props\n    return <div ref={ID => this.ID = ID} style={{width, height}}></div>\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/EchartsDemo/BarReact.js","/**\n * @module zrender/core/util\n */\n\n\n    // mergeDate\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuiltInObject(sourceProp)\n                    && !isBuiltInObject(targetProp)\n                    && !isPrimitive(sourceProp)\n                    && !isPrimitive(targetProp)\n                ) {\n                    // merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // overwritetrue\n                    // NOTE target[key] \n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * \n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz \n     * @param {Function} baseClazz \n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * Consider typed array.\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuiltInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * Whether is exactly NaN. Notice isNaN('a') returns true.\n     * @param {*} value\n     * @return {boolean}\n     */\n    function eqNaN(value) {\n        return value !== value;\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var primitiveKey = '__ec_primitive__';\n    /**\n     * Set an object as primitive to be ignored traversing children in clone or merge\n     */\n    function setAsPrimitive(obj) {\n        obj[primitiveKey] = true;\n    }\n\n    function isPrimitive(obj) {\n        return obj[primitiveKey];\n    }\n\n    /**\n     * @constructor\n     * @param {Object} obj Only apply `ownProperty`.\n     */\n    function HashMap(obj) {\n        obj && each(obj, function (value, key) {\n            this.set(key, value);\n        }, this);\n    }\n\n    // Add prefix to avoid conflict with Object.prototype.\n    var HASH_MAP_PREFIX = '_ec_';\n    var HASH_MAP_PREFIX_LENGTH = 4;\n\n    HashMap.prototype = {\n        constructor: HashMap,\n        // Do not provide `has` method to avoid defining what is `has`.\n        // (We usually treat `null` and `undefined` as the same, different\n        // from ES6 Map).\n        get: function (key) {\n            return this[HASH_MAP_PREFIX + key];\n        },\n        set: function (key, value) {\n            this[HASH_MAP_PREFIX + key] = value;\n            // Comparing with invocation chaining, `return value` is more commonly\n            // used in this case: `var someVal = map.set('a', genVal());`\n            return value;\n        },\n        // Although util.each can be performed on this hashMap directly, user\n        // should not use the exposed keys, who are prefixed.\n        each: function (cb, context) {\n            context !== void 0 && (cb = bind(cb, context));\n            for (var prefixedKey in this) {\n                this.hasOwnProperty(prefixedKey)\n                    && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n            }\n        },\n        // Do not use this method if performance sensitive.\n        removeKey: function (key) {\n            delete this[key];\n        }\n    };\n\n    function createHashMap(obj) {\n        return new HashMap(obj);\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuiltInObject: isBuiltInObject,\n        isDom: isDom,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        assert: assert,\n        setAsPrimitive: setAsPrimitive,\n        createHashMap: createHashMap,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/util.js\n// module id = 190\n// module chunks = 0 1 2 3 4 5 6","// Enable DEV mode when using source code without build. which has no __DEV__ variable\n// In build process 'typeof __DEV__' will be replace with 'boolean'\n// So this code will be removed or disabled anyway after built.\nif (typeof __DEV__ === 'undefined') {\n    // In browser\n    if (typeof window !== 'undefined') {\n        window.__DEV__ = true;\n    }\n    // In node\n    else if (typeof global !== 'undefined') {\n        global.__DEV__ = true;\n    }\n}\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\n/**\n * @module echarts\n */\n\n\n    var env = require('zrender/lib/core/env');\n\n    var GlobalModel = require('./model/Global');\n    var ExtensionAPI = require('./ExtensionAPI');\n    var CoordinateSystemManager = require('./CoordinateSystem');\n    var OptionManager = require('./model/OptionManager');\n\n    var ComponentModel = require('./model/Component');\n    var SeriesModel = require('./model/Series');\n\n    var ComponentView = require('./view/Component');\n    var ChartView = require('./view/Chart');\n    var graphic = require('./util/graphic');\n    var modelUtil = require('./util/model');\n    var throttle = require('./util/throttle');\n\n    var zrender = require('zrender');\n    var zrUtil = require('zrender/lib/core/util');\n    var colorTool = require('zrender/lib/tool/color');\n    var Eventful = require('zrender/lib/mixin/Eventful');\n    var timsort = require('zrender/lib/core/timsort');\n\n    var each = zrUtil.each;\n    var parseClassType = ComponentModel.parseClassType;\n\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\n\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    // FIXME\n    // necessary?\n    var PRIORITY_VISUAL_BRUSH = 5000;\n\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flagInMainProcess';\n    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\n    var OPTION_UPDATED = '__optionUpdated';\n    var ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts(dom, theme, opts) {\n        opts = opts || {};\n\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        var zr = this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height\n        });\n\n        /**\n         * Expect 60 pfs.\n         * @type {Function}\n         * @private\n         */\n        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = createExtensionAPI(this);\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n\n        // Init mouse events\n        this._initEvents();\n\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n\n        zr.animation.on('frame', this._onframe, this);\n\n        // ECharts instance can be used as value.\n        zrUtil.setAsPrimitive(this);\n    }\n\n    var echartsProto = ECharts.prototype;\n\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            var silent = this[OPTION_UPDATED].silent;\n\n            this[IN_MAIN_PROCESS] = true;\n\n            updateMethods.prepareAndUpdate.call(this);\n\n            this[IN_MAIN_PROCESS] = false;\n\n            this[OPTION_UPDATED] = false;\n\n            flushPendingActions.call(this, silent);\n\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n\n    /**\n     * Usage:\n     * chart.setOption(option, notMerge, lazyUpdate);\n     * chart.setOption(option, {\n     *     notMerge: ...,\n     *     lazyUpdate: ...,\n     *     silent: ...\n     * });\n     *\n     * @param {Object} option\n     * @param {Object|boolean} [opts] opts or notMerge.\n     * @param {boolean} [opts.notMerge=false]\n     * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n\n        var silent;\n        if (zrUtil.isObject(notMerge)) {\n            lazyUpdate = notMerge.lazyUpdate;\n            silent = notMerge.silent;\n            notMerge = notMerge.notMerge;\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n\n        this._model.setOption(option, optionPreprocessorFuncs);\n\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = {silent: silent};\n            this[IN_MAIN_PROCESS] = false;\n        }\n        else {\n            updateMethods.prepareAndUpdate.call(this);\n            // Ensure zr refresh sychronously, and then pixel in canvas can be\n            // fetched after `setOption`.\n            this._zr.flush();\n\n            this[OPTION_UPDATED] = false;\n            this[IN_MAIN_PROCESS] = false;\n\n            flushPendingActions.call(this, silent);\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getDevicePixelRatio = function () {\n        return this._zr.painter.dpr || window.devicePixelRatio || 1;\n    };\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     * @param {string} [opts.excludeComponents]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({\n                mainType: componentType\n            }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n\n        var url = this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n\n\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = (opts && opts.pixelRatio) || 1;\n\n            zrUtil.each(instances, function (chart, id) {\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(\n                        zrUtil.clone(opts)\n                    );\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            });\n\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                    style: {\n                        x: item.left * dpr - left,\n                        y: item.top * dpr - top,\n                        image: item.dom\n                    }\n                });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        }\n        else {\n            return this.getDataURL(opts);\n        }\n    };\n\n    /**\n     * Convert from logical coordinate system to pixel coordinate system.\n     * See CoordinateSystem#convertToPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId, geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\n    /**\n     * Convert from pixel coordinate system to logical coordinate system.\n     * See CoordinateSystem#convertFromPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\n    function doConvertPixel(methodName, finder, value) {\n        var ecModel = this._model;\n        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n            if (coordSys[methodName]\n                && (result = coordSys[methodName](ecModel, finder, value)) != null\n            ) {\n                return result;\n            }\n        }\n\n        if (__DEV__) {\n            console.warn(\n                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n            );\n        }\n    }\n\n    /**\n     * Is the specified coordinate systems or components contain the given pixel point.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {boolean} result\n     */\n    echartsProto.containPixel = function (finder, value) {\n        var ecModel = this._model;\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        zrUtil.each(finder, function (models, key) {\n            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n                var coordSys = model.coordinateSystem;\n                if (coordSys && coordSys.containPoint) {\n                    result |= !!coordSys.containPoint(value);\n                }\n                else if (key === 'seriesModels') {\n                    var view = this._chartsMap[model.__viewId];\n                    if (view && view.containPoint) {\n                        result |= view.containPoint(value, model);\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.warn(key + ': ' + (view\n                                ? 'The found component do not support containPoint.'\n                                : 'No view mapping to the found component.'\n                            ));\n                        }\n                    }\n                }\n                else {\n                    if (__DEV__) {\n                        console.warn(key + ': containPoint is not supported');\n                    }\n                }\n            }, this);\n        }, this);\n\n        return !!result;\n    };\n\n    /**\n     * Get visual from series or data.\n     * @param {string|Object} finder\n     *        If string, e.g., 'series', means {seriesIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            dataIndex / dataIndexInside\n     *        }\n     *        If dataIndex is not specified, series visual will be fetched,\n     *        but not data item visual.\n     *        If all of seriesIndex, seriesId, seriesName are not specified,\n     *        visual will be fetched from first series.\n     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n     */\n    echartsProto.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n\n        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n        var seriesModel = finder.seriesModel;\n\n        if (__DEV__) {\n            if (!seriesModel) {\n                console.warn('There is no specified seires model');\n            }\n        }\n\n        var data = seriesModel.getData();\n\n        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n            ? finder.dataIndexInside\n            : finder.hasOwnProperty('dataIndex')\n            ? data.indexOfRawIndex(finder.dataIndex)\n            : null;\n\n        return dataIndexInside != null\n            ? data.getItemVisual(dataIndexInside, visualType)\n            : data.getVisual(visualType);\n    };\n\n    /**\n     * Get view of corresponding component model\n     * @param  {module:echarts/model/Component} componentModel\n     * @return {module:echarts/view/Component}\n     */\n    echartsProto.getViewOfComponentModel = function (componentModel) {\n        return this._componentsMap[componentModel.__viewId];\n    };\n\n    /**\n     * Get view of corresponding series model\n     * @param  {module:echarts/model/Series} seriesModel\n     * @return {module:echarts/view/Chart}\n     */\n    echartsProto.getViewOfSeriesModel = function (seriesModel) {\n        return this._chartsMap[seriesModel.__viewId];\n    };\n\n\n    var updateMethods = {\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        update: function (payload) {\n            // console.profile && console.profile('update');\n\n            var ecModel = this._model;\n            var api = this._api;\n            var coordSysMgr = this._coordSysMgr;\n            var zr = this._zr;\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            // Fixme First time update ?\n            ecModel.restoreData();\n\n            // TODO\n            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n            // Create new coordinate system each update\n            // In LineView may save the old coordinate system and use it to get the orignal point\n            coordSysMgr.create(this._model, this._api);\n\n            processData.call(this, ecModel, api);\n\n            stackSeriesData.call(this, ecModel);\n\n            coordSysMgr.update(ecModel, api);\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            doRender.call(this, ecModel, payload);\n\n            // Set background\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n            var painter = zr.painter;\n            // TODO all use clearColor ?\n            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n            }\n            else {\n                // In IE8\n                if (!env.canvasSupported) {\n                    var colorArr = colorTool.parse(backgroundColor);\n                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                    if (colorArr[3] === 0) {\n                        backgroundColor = 'transparent';\n                    }\n                }\n                if (backgroundColor.colorStops || backgroundColor.image) {\n                    // Gradient background\n                    // FIXME Fixed layer\n                    zr.configLayer(0, {\n                        clearColor: backgroundColor\n                    });\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                    this._dom.style.background = 'transparent';\n                }\n                else {\n                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                        zr.configLayer(0, {\n                            clearColor: null\n                        });\n                    }\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                    this._dom.style.background = backgroundColor;\n                }\n            }\n\n            each(postUpdateFuncs, function (func) {\n                func(ecModel, api);\n            });\n\n            // console.profile && console.profileEnd('update');\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateView: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateVisual: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload, true);\n\n            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateLayout: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            doLayout.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        prepareAndUpdate: function (payload) {\n            var ecModel = this._model;\n\n            prepareView.call(this, 'component', ecModel);\n\n            prepareView.call(this, 'chart', ecModel);\n\n            updateMethods.update.call(this, payload);\n        }\n    };\n\n    /**\n     * @private\n     */\n    function updateDirectly(ecIns, method, payload, mainType, subType) {\n        var ecModel = ecIns._model;\n\n        // broadcast\n        if (!mainType) {\n            each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);\n            return;\n        }\n\n        var query = {};\n        query[mainType + 'Id'] = payload[mainType + 'Id'];\n        query[mainType + 'Index'] = payload[mainType + 'Index'];\n        query[mainType + 'Name'] = payload[mainType + 'Name'];\n\n        var condition = {mainType: mainType, query: query};\n        subType && (condition.subType = subType); // subType may be '' by parseClassType;\n\n        // If dispatchAction before setOption, do nothing.\n        ecModel && ecModel.eachComponent(condition, function (model, index) {\n            callView(ecIns[\n                mainType === 'series' ? '_chartsMap' : '_componentsMap'\n            ][model.__viewId]);\n        }, ecIns);\n\n        function callView(view) {\n            view && view.__alive && view[method] && view[method](\n                view.__model, ecModel, ecIns._api, payload\n            );\n        }\n    }\n\n    /**\n     * Resize the chart\n     * @param {Object} opts\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @param {boolean} [opts.silent=false]\n     */\n    echartsProto.resize = function (opts) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        this._zr.resize(opts);\n\n        var optionChanged = this._model && this._model.resetOption('media');\n        var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n\n        updateMethods[updateMethod].call(this);\n\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n\n        this[IN_MAIN_PROCESS] = false;\n\n        var silent = opts && opts.silent;\n\n        flushPendingActions.call(this, silent);\n\n        triggerUpdatedEvent.call(this, silent);\n    };\n\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (__DEV__) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n\n        zr.add(el);\n    };\n\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n     * @param {boolean} [opt.silent=false] Whether trigger events.\n     * @param {boolean} [opt.flush=undefined]\n     *                  true: Flush immediately, and then pixel in canvas can be fetched\n     *                      immediately. Caution: it might affect performance.\n     *                  false: Not not flush.\n     *                  undefined: Auto decide whether perform flush.\n     */\n    echartsProto.dispatchAction = function (payload, opt) {\n        if (!zrUtil.isObject(opt)) {\n            opt = {silent: !!opt};\n        }\n\n        if (!actions[payload.type]) {\n            return;\n        }\n\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n\n        doDispatchAction.call(this, payload, opt.silent);\n\n        if (opt.flush) {\n            this._zr.flush(true);\n        }\n        else if (opt.flush !== false && env.browser.weChat) {\n            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n            // hang when sliding page (on touch event), which cause that zr does not\n            // refresh util user interaction finished, which is not expected.\n            // But `dispatchAction` may be called too frequently when pan on touch\n            // screen, which impacts performance if do not throttle them.\n            this._throttledZrFlush();\n        }\n\n        flushPendingActions.call(this, opt.silent);\n\n        triggerUpdatedEvent.call(this, opt.silent);\n    };\n\n    function doDispatchAction(payload, silent) {\n        var payloadType = payload.type;\n        var escapeConnect = payload.escapeConnect;\n        var actionWrap = actions[payloadType];\n        var actionInfo = actionWrap.actionInfo;\n\n        var cptType = (actionInfo.update || 'update').split(':');\n        var updateMethod = cptType.pop();\n        cptType = cptType[0] != null && parseClassType(cptType[0]);\n\n        this[IN_MAIN_PROCESS] = true;\n\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n\n        each(payloads, function (batchItem) {\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model, this._api);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            // light update does not perform data process, layout and visual.\n            if (isHighDown) {\n                // method, payload, mainType, subType\n                updateDirectly(this, updateMethod, batchItem, 'series');\n            }\n            else if (cptType) {\n                updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n            }\n        }, this);\n\n        if (updateMethod !== 'none' && !isHighDown && !cptType) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            }\n            else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payloadType,\n                escapeConnect: escapeConnect,\n                batch: eventObjBatch\n            };\n        }\n        else {\n            eventObj = eventObjBatch[0];\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n    }\n\n    function flushPendingActions(silent) {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            doDispatchAction.call(this, payload, silent);\n        }\n    }\n\n    function triggerUpdatedEvent(silent) {\n        !silent && this.trigger('updated');\n    }\n\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, component);\n        }, this);\n\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n\n            updateZ(seriesModel, chart);\n\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Post render\n        each(postUpdateFuncs, function (func) {\n            func(ecModel, api);\n        });\n    }\n\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            }\n            else {\n                model = componentType;\n            }\n\n            // Consider: id same and type changed.\n            var viewId = '_ec_' + model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = parseClassType(model.type);\n                var Clazz = isComponent\n                    ? ComponentView.getClass(classType.main, classType.sub)\n                    : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                }\n                else {\n                    // Error\n                    return;\n                }\n            }\n\n            model.__viewId = view.__id = viewId;\n            view.__alive = true;\n            view.__model = model;\n            view.group.__ecComponentInfo = {\n                mainType: model.mainType,\n                index: model.componentIndex\n            };\n        }, this);\n\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n                view.__id = view.group.__ecComponentInfo = null;\n            }\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                // Avoid conflict with Object.prototype\n                if (stackedDataMap.hasOwnProperty(stack) && previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @param {object} layout\n     * @param {boolean} [excludesLayout]\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload, excludesLayout) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            (!excludesLayout || !visual.isLayout)\n                && visual.func(ecModel, api, payload);\n        });\n    }\n\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, componentView);\n        }, this);\n\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n\n            chartView.group.silent = !!seriesModel.get('silent');\n\n            updateZ(seriesModel, chartView);\n\n            updateProgressiveAndBlend(seriesModel, chartView);\n\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n\n    var MOUSE_EVENT_NAMES = [\n        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n    ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                var params;\n\n                // no e.target when 'globalout'.\n                if (eveName === 'globalout') {\n                    params = {};\n                }\n                else if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                }\n                // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    params = zrUtil.extend({}, el.eventData);\n                }\n\n                if (params) {\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }\n\n            }, this);\n        }, this);\n\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (__DEV__) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n\n        var api = this._api;\n        var ecModel = this._model;\n\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n\n        // Dispose after all views disposed\n        this._zr.dispose();\n\n        delete instances[this.id];\n    };\n\n    zrUtil.mixin(ECharts, Eventful);\n\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ?\n                        Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (__DEV__) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n\n    function createExtensionAPI(ecInstance) {\n        var coordSysMgr = ecInstance._coordSysMgr;\n        return zrUtil.extend(new ExtensionAPI(ecInstance), {\n            // Inject methods\n            getCoordinateSystems: zrUtil.bind(\n                coordSysMgr.getCoordinateSystems, coordSysMgr\n            ),\n            getComponentByElement: function (el) {\n                while (el) {\n                    var modelInfo = el.__ecComponentInfo;\n                    if (modelInfo != null) {\n                        return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);\n                    }\n                    el = el.parent;\n                }\n            }\n        });\n    }\n\n    /**\n     * @type {Object} key: actionType.\n     * @inner\n     */\n    var actions = {};\n\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var postUpdateFuncs = [];\n\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n\n\n    var instances = {};\n    var connectedGroups = {};\n\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n        /**\n         * @type {number}\n         */\n        version: '3.6.2',\n        dependencies: {\n            zrender: '3.5.2'\n        }\n    };\n\n    function enableConnect(chart) {\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    if (event && event.escapeConnect) {\n                        return;\n                    }\n\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n\n                    zrUtil.each(instances, function (otherChart) {\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    });\n\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n    }\n\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n     *                              Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n     *                               Can be 'auto' (the same as null/undefined)\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (__DEV__) {\n            // Check version\n            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n                throw new Error(\n                    'ZRender ' + zrender.version\n                    + ' is too old for ECharts ' + echarts.version\n                    + '. Current version need ZRender '\n                    + echarts.dependencies.zrender + '+'\n                );\n            }\n\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n        }\n\n        var existInstance = echarts.getInstanceByDom(dom);\n        if (existInstance) {\n            if (__DEV__) {\n                console.warn('There is a chart instance already initialized on the dom.');\n            }\n            return existInstance;\n        }\n\n        if (__DEV__) {\n            if (zrUtil.isDom(dom)\n                && dom.nodeName.toUpperCase() !== 'CANVAS'\n                && (\n                    (!dom.clientWidth && (!opts || opts.width == null))\n                    || (!dom.clientHeight && (!opts || opts.height == null))\n                )\n            ) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n\n        if (dom.setAttribute) {\n            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n        }\n        else {\n            dom[DOM_ATTRIBUTE_KEY] = chart.id;\n        }\n\n        enableConnect(chart);\n\n        return chart;\n    };\n\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || ('g_' + groupIdBase++);\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n\n    /**\n     * @DEPRECATED\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n\n    /**\n     * @return {string} groupId\n     */\n    echarts.disconnect = echarts.disConnect;\n\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        else if (!(chart instanceof ECharts)){\n            // Try to treat as dom\n            chart = echarts.getInstanceByDom(chart);\n        }\n        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key;\n        if (dom.getAttribute) {\n            key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        }\n        else {\n            key = dom[DOM_ATTRIBUTE_KEY];\n        }\n        return instances[key];\n    };\n\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n\n    /**\n     * Register postUpdater\n     * @param {Function} postUpdateFunc\n     */\n    echarts.registerPostUpdate = function (postUpdateFunc) {\n        postUpdateFuncs.push(postUpdateFunc);\n    };\n\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo)\n            ? actionInfo.type\n            : ([actionInfo, actionInfo = {\n                event: eventName\n            }][0]);\n\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n\n        // Validate action type and event name.\n        zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n        if (!actions[actionType]) {\n            actions[actionType] = {action: action, actionInfo: actionInfo};\n        }\n        eventActionMap[eventName] = actionType;\n    };\n\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n\n    /**\n     * Get dimensions of specified coordinate system.\n     * @param {string} type\n     * @return {Array.<string|Object>}\n     */\n    echarts.getCoordinateSystemDimensions = function (type) {\n        var coordSysCreator = CoordinateSystemManager.get(type);\n        if (coordSysCreator) {\n            return coordSysCreator.getDimensionsInfo\n                    ? coordSysCreator.getDimensionsInfo()\n                    : coordSysCreator.dimensions.slice();\n        }\n    };\n\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts/*, superClass*/) {\n        // var Clazz = ComponentModel;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts/*, superClass*/) {\n        // var Clazz = ComponentView;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentView.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts/*, superClass*/) {\n        // var Clazz = SeriesModel;\n        // if (superClass) {\n        //     superClass = 'series.' + superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return SeriesModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts/*, superClass*/) {\n        // var Clazz = ChartView;\n        // if (superClass) {\n        //     superClass = superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ChartView.getClass(classType.main, true);\n        // }\n        return ChartView.extend(opts);\n    };\n\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n    echarts.registerPreprocessor(require('./preprocessor/backwardCompat'));\n    echarts.registerLoading('default', require('./loading/default'));\n\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n\n\n    // --------\n    // Exports\n    // --------\n    echarts.zrender = zrender;\n\n    echarts.List = require('./data/List');\n    echarts.Model = require('./model/Model');\n\n    echarts.Axis = require('./coord/Axis');\n\n    echarts.graphic = require('./util/graphic');\n    echarts.number = require('./util/number');\n    echarts.format = require('./util/format');\n    echarts.throttle = throttle.throttle;\n    echarts.matrix = require('zrender/lib/core/matrix');\n    echarts.vector = require('zrender/lib/core/vector');\n    echarts.color = require('zrender/lib/tool/color');\n\n    echarts.util = {};\n    each([\n            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n            'extend', 'defaults', 'clone', 'merge'\n        ],\n        function (name) {\n            echarts.util[name] = zrUtil[name];\n        }\n    );\n\n    echarts.helper = require('./helper');\n\n\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n\n    module.exports = echarts;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/echarts.js\n// module id = 191\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var pathTool = require('zrender/lib/tool/path');\n    var Path = require('zrender/lib/graphic/Path');\n    var colorTool = require('zrender/lib/tool/color');\n    var matrix = require('zrender/lib/core/matrix');\n    var vector = require('zrender/lib/core/vector');\n    var Transformable = require('zrender/lib/mixin/Transformable');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    var round = Math.round;\n    var mathMax = Math.max;\n    var mathMin = Math.min;\n\n    var graphic = {};\n\n    graphic.Group = require('zrender/lib/container/Group');\n\n    graphic.Image = require('zrender/lib/graphic/Image');\n\n    graphic.Text = require('zrender/lib/graphic/Text');\n\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\n\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\n\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\n\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\n\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\n\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\n\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\n\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\n\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\n\n    graphic.CompoundPath = require('zrender/lib/graphic/CompoundPath');\n\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\n\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\n\n    graphic.BoundingRect = BoundingRect;\n\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                }\n                else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n\n            graphic.resizePath(path, rect);\n        }\n        return path;\n    };\n\n    graphic.mergePath = pathTool.mergePath,\n\n    /**\n     * Resize a path to fit the rect\n     * @param {module:zrender/graphic/Path} path\n     * @param {Object} rect\n     */\n    graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n\n        var pathRect = path.getBoundingRect();\n\n        var m = pathRect.calculateTransform(rect);\n\n        path.applyTransform(m);\n    };\n\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n            originWidth === 0 ? 0 : 1\n        );\n        shape.height = Math.max(\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n            originHeight === 0 ? 0 : 1\n        );\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill\n                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke\n                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n\n            el.__normalStl = normalStyle;\n\n            el.__hoverStlDirty = false;\n        }\n    }\n\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n\n        cacheElementStl(el);\n\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        }\n        else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n\n        el.__isHover = true;\n    }\n\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        }\n        else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n\n        el.__isHover = false;\n    }\n\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleEnterHover(child);\n                }\n            })\n            : doSingleEnterHover(el);\n    }\n\n    function doLeaveHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleLeaveHover(child);\n                }\n            })\n            : doSingleLeaveHover(el);\n    }\n\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOver(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOut(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n\n    /**\n     * Set hover style of element.\n     * This method can be called repeatly without side-effects.\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     * @param {Object} [opt]\n     * @param {boolean} [opt.hoverSilentOnTouch=false]\n     *        In touch device, mouseover event will be trigger on touchstart event\n     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n     *        conviniently use hoverStyle when tap on touch screen without additional\n     *        code for compatibility.\n     *        But if the chart/component has select feature, which usually also use\n     *        hoverStyle, there might be conflict between 'select-highlight' and\n     *        'hover-highlight' especially when roam is enabled (see geo for example).\n     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n     *        on touch device.\n     */\n    graphic.setHoverStyle = function (el, hoverStyle, opt) {\n        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    setElementHoverStl(child, hoverStyle);\n                }\n            })\n            : setElementHoverStl(el, hoverStyle);\n\n        // Duplicated function will be auto-ignored, see Eventful.js.\n        el.on('mouseover', onElementMouseOver)\n          .on('mouseout', onElementMouseOut);\n\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis)\n          .on('normal', leaveEmphasis);\n    };\n\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelOffset = labelModel.getShallow('offset');\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textOffset: labelOffset,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n\n    graphic.getFont = function (opt, ecModel) {\n        var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n        return [\n            // FIXME in node-canvas fontWeight is before fontStyle\n            opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '',\n            opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '',\n            (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px',\n            opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'\n        ].join(' ');\n    };\n\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        // Do not check 'animation' property directly here. Consider this case:\n        // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n        // but its parent model (`seriesModel`) does.\n        var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(\n                    dataIndex,\n                    animatableModel.getAnimationDelayParams\n                        ? animatableModel.getAnimationDelayParams(el, dataIndex)\n                        : null\n                );\n            }\n            if (typeof duration === 'function') {\n                duration = duration(dataIndex);\n            }\n\n            duration > 0\n                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n                : (el.stopAnimation(), el.attr(props), cb && cb());\n        }\n        else {\n            el.stopAnimation();\n            el.attr(props);\n            cb && cb();\n        }\n    }\n\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n\n        return mat;\n    };\n\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} target [x, y]\n     * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:\n     *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n     *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (target, transform, invert) {\n        if (transform && !zrUtil.isArrayLike(transform)) {\n            transform = Transformable.getLocalTransform(transform);\n        }\n\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], target, transform);\n    };\n\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n        var vertex = [\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n        ];\n\n        vertex = graphic.applyTransform(vertex, transform, invert);\n\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n            ? (vertex[0] > 0 ? 'right' : 'left')\n            : (vertex[1] > 0 ? 'bottom' : 'top');\n    };\n\n    /**\n     * Apply group transition animation from g1 to g2.\n     * If no animatableModel, no animation.\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                position: vector.clone(el.position),\n                rotation: el.rotation\n            };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }\n                // else {\n                //     if (el.previousProps) {\n                //         graphic.updateProps\n                //     }\n                // }\n            }\n        });\n    };\n\n    /**\n     * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]\n     * @param {Object} rect {x, y, width, height}\n     * @return {Array.<Array.<number>>} A new clipped points.\n     */\n    graphic.clipPointsByRect = function (points, rect) {\n        return zrUtil.map(points, function (point) {\n            var x = point[0];\n            x = mathMax(x, rect.x);\n            x = mathMin(x, rect.x + rect.width);\n            var y = point[1];\n            y = mathMax(y, rect.y);\n            y = mathMin(y, rect.y + rect.height);\n            return [x, y];\n        });\n    };\n\n    /**\n     * @param {Object} targetRect {x, y, width, height}\n     * @param {Object} rect {x, y, width, height}\n     * @return {Object} A new clipped rect. If rect size are negative, return undefined.\n     */\n    graphic.clipRectByRect = function (targetRect, rect) {\n        var x = mathMax(targetRect.x, rect.x);\n        var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n        var y = mathMax(targetRect.y, rect.y);\n        var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);\n\n        if (x2 >= x && y2 >= y) {\n            return {\n                x: x,\n                y: y,\n                width: x2 - x,\n                height: y2 - y\n            };\n        }\n    };\n\n    module.exports = graphic;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/graphic.js\n// module id = 192\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module echarts/util/number\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var number = {};\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n\n        if (subDomain === 0) {\n            return subRange === 0\n                ? range[0]\n                : (range[0] + range[1]) / 2;\n        }\n\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                }\n                else if (val >= domain[1]) {\n                    return range[1];\n                }\n            }\n            else {\n                if (val >= domain[0]) {\n                    return range[0];\n                }\n                else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        }\n        else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function(percent, all) {\n        switch (percent) {\n            case 'center':\n            case 'middle':\n                percent = '50%';\n                break;\n            case 'left':\n            case 'top':\n                percent = '0%';\n                break;\n            case 'right':\n            case 'bottom':\n                percent = '100%';\n                break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n\n            return parseFloat(percent);\n        }\n\n        return percent == null ? NaN : +percent;\n    };\n\n    /**\n     * (1) Fix rounding error of float numbers.\n     * (2) Support return string to avoid scientific notation like '3.5e-7'.\n     *\n     * @param {number} x\n     * @param {number} [precision]\n     * @param {boolean} [returnStr]\n     * @return {number|string}\n     */\n    number.round = function (x, precision, returnStr) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // Avoid range error\n        precision = Math.min(Math.max(0, precision), 20);\n        x = (+x).toFixed(precision);\n        return returnStr ? x : +x;\n    };\n\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n\n    /**\n     * @param {string|number} val\n     * @return {number}\n     */\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n\n        // Consider scientific notation: '3.4e-12' '3.4e+12'\n        var eIndex = str.indexOf('e');\n        if (eIndex > 0) {\n            var precision = +str.slice(eIndex + 1);\n            return precision < 0 ? -precision : 0;\n        }\n        else {\n            var dotIndex = str.indexOf('.');\n            return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n        }\n    };\n\n    /**\n     * Minimal dicernible data precisioin according to a single pixel.\n     *\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number} precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        // toFixed() digits argument must be between 0 and 20.\n        var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n        return !isFinite(precision) ? 20 : precision;\n    };\n\n    /**\n     * Get a data of given precision, assuring the sum of percentages\n     * in valueList is 1.\n     * The largest remainer method is used.\n     * https://en.wikipedia.org/wiki/Largest_remainder_method\n     *\n     * @param {Array.<number>} valueList a list of all data\n     * @param {number} idx index of the data to be processed in valueList\n     * @param {number} precision integer number showing digits of precision\n     * @return {number} percent ranging from 0 to 100\n     */\n    number.getPercentWithPrecision = function (valueList, idx, precision) {\n        if (!valueList[idx]) {\n            return 0;\n        }\n\n        var sum = zrUtil.reduce(valueList, function (acc, val) {\n            return acc + (isNaN(val) ? 0 : val);\n        }, 0);\n        if (sum === 0) {\n            return 0;\n        }\n\n        var digits = Math.pow(10, precision);\n        var votesPerQuota = zrUtil.map(valueList, function (val) {\n            return (isNaN(val) ? 0 : val) / sum * digits * 100;\n        });\n        var targetSeats = digits * 100;\n\n        var seats = zrUtil.map(votesPerQuota, function (votes) {\n            // Assign automatic seats.\n            return Math.floor(votes);\n        });\n        var currentSum = zrUtil.reduce(seats, function (acc, val) {\n            return acc + val;\n        }, 0);\n\n        var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {\n            return votes - seats[idx];\n        });\n\n        // Has remainding votes.\n        while (currentSum < targetSeats) {\n            // Find next largest remainder.\n            var max = Number.NEGATIVE_INFINITY;\n            var maxId = null;\n            for (var i = 0, len = remainder.length; i < len; ++i) {\n                if (remainder[i] > max) {\n                    max = remainder[i];\n                    maxId = i;\n                }\n            }\n\n            // Add a vote to max remainder.\n            ++seats[maxId];\n            remainder[maxId] = 0;\n            ++currentSum;\n        }\n\n        return seats[idx] / digits;\n    };\n\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n\n    var TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d\\d)(?::(\\d\\d)(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line\n\n    /**\n     * @return {number} in minutes\n     */\n    number.getTimezoneOffset = function () {\n        return (new Date()).getTimezoneOffset();\n    };\n\n    /**\n     * @param {string|Date|number} value These values can be accepted:\n     *   + An instance of Date, represent a time in its own time zone.\n     *   + Or string in a subset of ISO 8601, only including:\n     *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',\n     *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',\n     *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',\n     *     all of which will be treated as local time if time zone is not specified\n     *     (see <https://momentjs.com/>).\n     *   + Or other string format, including (all of which will be treated as loacal time):\n     *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',\n     *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'\n     *   + a timestamp, which represent a time in UTC.\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            // Different browsers parse date in different way, so we parse it manually.\n            // Some other issues:\n            // new Date('1970-01-01') is UTC,\n            // new Date('1970/01/01') and new Date('1970-1-01') is local.\n            // See issue #3623\n            var match = TIME_REG.exec(value);\n\n            if (!match) {\n                // return Invalid Date.\n                return new Date(NaN);\n            }\n\n            var timezoneOffset = number.getTimezoneOffset();\n            var timeOffset = !match[8]\n                ? 0\n                : match[8].toUpperCase() === 'Z'\n                ? timezoneOffset\n                : +match[8].slice(0, 3) * 60 + timezoneOffset;\n\n            // match[n] can only be string or undefined.\n            // But take care of '12' + 1 => '121'.\n            return new Date(\n                +match[1],\n                +(match[2] || 1) - 1,\n                +match[3] || 1,\n                +match[4] || 0,\n                +(match[5] || 0) - timeOffset,\n                +match[6] || 0,\n                +match[7] || 0\n            );\n        }\n        else if (value == null) {\n            return new Date(NaN);\n        }\n\n        return new Date(Math.round(value));\n    };\n\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     *\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, quantityExponent(val));\n    };\n\n    function quantityExponent(val) {\n        return Math.floor(Math.log(val) / Math.LN10);\n    }\n\n    /**\n     * find a nice number approximately equal to x. Round the number if round = true,\n     * take ceiling if round = false. The primary observation is that the nicest\n     * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     *\n     * See \"Nice Numbers for Graph Labels\" of Graphic Gems.\n     *\n     * @param  {number} val Non-negative value.\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exponent = quantityExponent(val);\n        var exp10 = Math.pow(10, exponent);\n        var f = val / exp10; // 1 <= f < 10\n        var nf;\n        if (round) {\n            if (f < 1.5) { nf = 1; }\n            else if (f < 2.5) { nf = 2; }\n            else if (f < 4) { nf = 3; }\n            else if (f < 7) { nf = 5; }\n            else { nf = 10; }\n        }\n        else {\n            if (f < 1) { nf = 1; }\n            else if (f < 2) { nf = 2; }\n            else if (f < 3) { nf = 3; }\n            else if (f < 5) { nf = 5; }\n            else { nf = 10; }\n        }\n        val = nf * exp10;\n\n        // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).\n        // 20 is the uppper bound of toFixed.\n        return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n    };\n\n    /**\n     * Order intervals asc, and split them when overlap.\n     * expect(numberUtil.reformIntervals([\n     *     {interval: [18, 62], close: [1, 1]},\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [1, 1]},\n     *     {interval: [62, 150], close: [1, 1]},\n     *     {interval: [106, 150], close: [1, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ])).toEqual([\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [0, 1]},\n     *     {interval: [18, 62], close: [0, 1]},\n     *     {interval: [62, 150], close: [0, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ]);\n     * @param {Array.<Object>} list, where `close` mean open or close\n     *        of the interval, and Infinity can be used.\n     * @return {Array.<Object>} The origin list, which has been reformed.\n     */\n    number.reformIntervals = function (list) {\n        list.sort(function (a, b) {\n            return littleThan(a, b, 0) ? -1 : 1;\n        });\n\n        var curr = -Infinity;\n        var currClose = 1;\n        for (var i = 0; i < list.length;) {\n            var interval = list[i].interval;\n            var close = list[i].close;\n\n            for (var lg = 0; lg < 2; lg++) {\n                if (interval[lg] <= curr) {\n                    interval[lg] = curr;\n                    close[lg] = !lg ? 1 - currClose : 1;\n                }\n                curr = interval[lg];\n                currClose = close[lg];\n            }\n\n            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n                list.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n\n        return list;\n\n        function littleThan(a, b, lg) {\n            return a.interval[lg] < b.interval[lg]\n                || (\n                    a.interval[lg] === b.interval[lg]\n                    && (\n                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n                        || (!lg && littleThan(a, b, 1))\n                    )\n                );\n        }\n    };\n\n    /**\n     * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n     * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n     * subtraction forces infinities to NaN\n     *\n     * @param {*} v\n     * @return {boolean}\n     */\n    number.isNumeric = function (v) {\n        return v - parseFloat(v) >= 0;\n    };\n\n    module.exports = number;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/number.js\n// module id = 193\n// module chunks = 0 1 2 3 4 5 6","\n\n    var formatUtil = require('./format');\n    var nubmerUtil = require('./number');\n    var Model = require('../model/Model');\n    var zrUtil = require('zrender/lib/core/util');\n    var each = zrUtil.each;\n    var isObject = zrUtil.isObject;\n\n    var modelUtil = {};\n\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array\n            ? value\n            : value == null\n            ? []\n            : [value];\n    };\n\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n     modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n\n            // Default emphasis option from normal\n            each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n\n    modelUtil.LABEL_OPTIONS = ['position', 'offset', 'show', 'textStyle', 'distance', 'formatter'];\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return isObject(dataItem)\n            && !(dataItem instanceof Array);\n            // // markLine data can be array\n            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n\n        if (dimType === 'time'\n            // spead up when using timestamp\n            && typeof value !== 'number'\n            && value != null\n            && value !== '-'\n        ) {\n            value = +nubmerUtil.parseDate(value);\n        }\n\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return (value == null || value === '')\n            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n    };\n\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        /**\n         * Get params for formatter\n         * @param {number} dataIndex\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n            var color = data.getItemVisual(dataIndex, 'color');\n\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: this.seriesIndex,\n                seriesId: this.id,\n                seriesName: this.name,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: color,\n                marker: formatUtil.getTooltipMarker(color),\n\n                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n                $vars: ['seriesName', 'name', 'value']\n            };\n        },\n\n        /**\n         * Format label\n         * @param {number} dataIndex\n         * @param {string} [status='normal'] 'normal' or 'emphasis'\n         * @param {string} [dataType]\n         * @param {number} [dimIndex]\n         * @param {string} [labelProp='label']\n         * @return {string}\n         */\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && (params.value instanceof Array)) {\n                params.value = params.value[dimIndex];\n            }\n\n            var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);\n\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            }\n            else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n\n        /**\n         * Get raw value in option\n         * @param {number} idx\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return (isObject(dataItem) && !(dataItem instanceof Array))\n                    ? dataItem.value : dataItem;\n            }\n        },\n\n        /**\n         * Should be implemented.\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         * @return {string} tooltip string\n         */\n        formatTooltip: zrUtil.noop\n    };\n\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          index of which is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n\n        var result = zrUtil.map(exists || [], function (obj, index) {\n            return {exist: obj};\n        });\n\n        // Mapping by id or name if specified.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option // Consider name: two map to one.\n                    && cptOption.id != null\n                    && result[i].exist.id === cptOption.id + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option // Consider name: two map to one.\n                    // Can not match when both ids exist but different.\n                    && (exist.id == null || cptOption.id == null)\n                    && cptOption.name != null\n                    && !modelUtil.isIdInner(cptOption)\n                    && !modelUtil.isIdInner(exist)\n                    && exist.name === cptOption.name + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n\n        // Otherwise mapping by index.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option\n                    // Existing model that already has id should be able to\n                    // mapped to (because after mapping performed model may\n                    // be assigned with a id, whish should not affect next\n                    // mapping), except those has inner id.\n                    && !modelUtil.isIdInner(exist)\n                    // Caution:\n                    // Do not overwrite id. But name can be overwritten,\n                    // because axis use name as 'show label text'.\n                    // 'exist' always has id and name and we dont\n                    // need to check it.\n                    && cptOption.id == null\n                ) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n\n            if (i >= result.length) {\n                result.push({option: cptOption});\n            }\n        });\n\n        return result;\n    };\n\n    /**\n     * Make id and name for mapping result (result of mappingToExists)\n     * into `keyInfo` field.\n     *\n     * @public\n     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     * @return {Array.<Object>} The input.\n     */\n    modelUtil.makeIdAndName = function (mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n\n        // Ensure that each id is distinct.\n        var idMap = zrUtil.createHashMap();\n\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && idMap.set(existCpt.id, item);\n        });\n\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n\n            zrUtil.assert(\n                !opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item,\n                'id duplicates: ' + (opt && opt.id)\n            );\n\n            opt && opt.id != null && idMap.set(opt.id, item);\n            !item.keyInfo && (item.keyInfo = {});\n        });\n\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n\n            if (!isObject(opt)) {\n                return;\n            }\n\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null\n                ? opt.name + ''\n                : existCpt\n                ? existCpt.name\n                : '\\0-'; // name may be displayed on screen, so use '-'.\n\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            }\n            else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            }\n            else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n                }\n                while (idMap.get(keyInfo.id));\n            }\n\n            idMap.set(keyInfo.id, item);\n        });\n    };\n\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return isObject(cptOption)\n            && cptOption.id\n            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n    };\n\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n\n        return [mapToArray(mapA), mapToArray(mapB)];\n\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    }\n                    else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    }\n                    else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                    }\n                }\n            }\n            return result;\n        }\n    };\n\n    /**\n     * @param {module:echarts/data/List} data\n     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n     *                         each of which can be Array or primary type.\n     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n     */\n    modelUtil.queryDataIndex = function (data, payload) {\n        if (payload.dataIndexInside != null) {\n            return payload.dataIndexInside;\n        }\n        else if (payload.dataIndex != null) {\n            return zrUtil.isArray(payload.dataIndex)\n                ? zrUtil.map(payload.dataIndex, function (value) {\n                    return data.indexOfRawIndex(value);\n                })\n                : data.indexOfRawIndex(payload.dataIndex);\n        }\n        else if (payload.name != null) {\n            return zrUtil.isArray(payload.name)\n                ? zrUtil.map(payload.name, function (value) {\n                    return data.indexOfName(value);\n                })\n                : data.indexOfName(payload.name);\n        }\n    };\n\n    /**\n     * Enable property storage to any host object.\n     * Notice: Serialization is not supported.\n     *\n     * For example:\n     * var get = modelUitl.makeGetter();\n     *\n     * function some(hostObj) {\n     *      get(hostObj)._someProperty = 1212;\n     *      ...\n     * }\n     *\n     * @return {Function}\n     */\n    modelUtil.makeGetter = (function () {\n        var index = 0;\n        return function () {\n            var key = '\\0__ec_prop_getter_' + index++;\n            return function (hostObj) {\n                return hostObj[key] || (hostObj[key] = {});\n            };\n        };\n    })();\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex, seriesId, seriesName,\n     *            geoIndex, geoId, geoName,\n     *            bmapIndex, bmapId, bmapName,\n     *            xAxisIndex, xAxisId, xAxisName,\n     *            yAxisIndex, yAxisId, yAxisName,\n     *            gridIndex, gridId, gridName,\n     *            ... (can be extended)\n     *        }\n     *        Each properties can be number|string|Array.<number>|Array.<string>\n     *        For example, a finder could be\n     *        {\n     *            seriesIndex: 3,\n     *            geoId: ['aa', 'cc'],\n     *            gridName: ['xx', 'rr']\n     *        }\n     *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)\n     *        If nothing or null/undefined specified, return nothing.\n     * @param {Object} [opt]\n     * @param {string} [opt.defaultMainType]\n     * @param {Array.<string>} [opt.includeMainTypes]\n     * @return {Object} result like:\n     *        {\n     *            seriesModels: [seriesModel1, seriesModel2],\n     *            seriesModel: seriesModel1, // The first model\n     *            geoModels: [geoModel1, geoModel2],\n     *            geoModel: geoModel1, // The first model\n     *            ...\n     *        }\n     */\n    modelUtil.parseFinder = function (ecModel, finder, opt) {\n        if (zrUtil.isString(finder)) {\n            var obj = {};\n            obj[finder + 'Index'] = 0;\n            finder = obj;\n        }\n\n        var defaultMainType = opt && opt.defaultMainType;\n        if (defaultMainType\n            && !has(finder, defaultMainType + 'Index')\n            && !has(finder, defaultMainType + 'Id')\n            && !has(finder, defaultMainType + 'Name')\n        ) {\n            finder[defaultMainType + 'Index'] = 0;\n        }\n\n        var result = {};\n\n        each(finder, function (value, key) {\n            var value = finder[key];\n\n            // Exclude 'dataIndex' and other illgal keys.\n            if (key === 'dataIndex' || key === 'dataIndexInside') {\n                result[key] = value;\n                return;\n            }\n\n            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n            var mainType = parsedKey[1];\n            var queryType = (parsedKey[2] || '').toLowerCase();\n\n            if (!mainType\n                || !queryType\n                || value == null\n                || (queryType === 'index' && value === 'none')\n                || (opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0)\n            ) {\n                return;\n            }\n\n            var queryParam = {mainType: mainType};\n            if (queryType !== 'index' || value !== 'all') {\n                queryParam[queryType] = value;\n            }\n\n            var models = ecModel.queryComponents(queryParam);\n            result[mainType + 'Models'] = models;\n            result[mainType + 'Model'] = models[0];\n        });\n\n        return result;\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string|number} dataDim\n     * @return {string}\n     */\n    modelUtil.dataDimToCoordDim = function (data, dataDim) {\n        var dimensions = data.dimensions;\n        dataDim = data.getDimension(dataDim);\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimItem = data.getDimensionInfo(dimensions[i]);\n            if (dimItem.name === dataDim) {\n                return dimItem.coordDim;\n            }\n        }\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string} coordDim\n     * @return {Array.<string>} data dimensions on the coordDim.\n     */\n    modelUtil.coordDimToDataDim = function (data, coordDim) {\n        var dataDim = [];\n        each(data.dimensions, function (dimName) {\n            var dimItem = data.getDimensionInfo(dimName);\n            if (dimItem.coordDim === coordDim) {\n                dataDim[dimItem.coordDimIndex] = dimItem.name;\n            }\n        });\n        return dataDim;\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string} otherDim Can be `otherDims`\n     *                        like 'label' or 'tooltip'.\n     * @return {Array.<string>} data dimensions on the otherDim.\n     */\n    modelUtil.otherDimToDataDim = function (data, otherDim) {\n        var dataDim = [];\n        each(data.dimensions, function (dimName) {\n            var dimItem = data.getDimensionInfo(dimName);\n            var otherDims = dimItem.otherDims;\n            var dimIndex = otherDims[otherDim];\n            if (dimIndex != null && dimIndex !== false) {\n                dataDim[dimIndex] = dimItem.name;\n            }\n        });\n        return dataDim;\n    };\n\n    function has(obj, prop) {\n        return obj && obj.hasOwnProperty(prop);\n    }\n\n    module.exports = modelUtil;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/model.js\n// module id = 194\n// module chunks = 0 1 2 3 4 5 6","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * \n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * \n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} \n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/vector.js\n// module id = 195\n// module chunks = 0 1 2 3 4 5 6","/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    var pathProxyForDraw = new PathProxy(true);\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = null;\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path || pathProxyForDraw;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect;\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath\n                || (lineDash && !ctxLineDash && hasStroke)\n            ) {\n                path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                if (this.path) {\n                    this.__dirtyPath = false;\n                }\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        createPathProxy: function () {\n            this.path = new PathProxy();\n        },\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (!path) {\n                    // Create path on demand.\n                    path = this.path = new PathProxy();\n                }\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     *  Path element, \n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME  extend position, rotation \n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Path.js\n// module id = 196\n// module chunks = 0 1 2 3 4 5 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('./number');\n    var textContain = require('zrender/lib/contain/text');\n\n    var formatUtil = {};\n\n    /**\n     * ,\n     * @param {string|number} x\n     * @return {string}\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n               + (x.length > 1 ? ('.' + x[1]) : '');\n    };\n\n    /**\n     * @param {string} str\n     * @param {boolean} [upperCaseFirst=false]\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str, upperCaseFirst) {\n        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n            return group1.toUpperCase();\n        });\n\n        if (upperCaseFirst && str) {\n            str = str.charAt(0).toUpperCase() + str.slice(1);\n        }\n\n        return str;\n    };\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        else if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    };\n\n    var encodeHTML = formatUtil.encodeHTML = function (source) {\n        return String(source)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    };\n\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    /**\n     * Template formatter\n     * @param {string} tpl\n     * @param {Array.<Object>|Object} paramsList\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList, encode) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            var val = wrapVar(alias, 0);\n            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                var val = paramsList[seriesIdx][$vars[k]];\n                tpl = tpl.replace(\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                    encode ? encodeHTML(val) : val\n                );\n            }\n        }\n\n        return tpl;\n    };\n\n    /**\n     * simple Template formatter\n     *\n     * @param {string} tpl\n     * @param {Object} param\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTplSimple = function (tpl, param, encode) {\n        zrUtil.each(param, function (value, key) {\n            tpl = tpl.replace(\n                '{' + key + '}',\n                encode ? encodeHTML(value) : value\n            );\n        });\n        return tpl;\n    };\n\n    /**\n     * @param {string} color\n     * @param {string} [extraCssText]\n     * @return {string}\n     */\n    formatUtil.getTooltipMarker = function (color, extraCssText) {\n        return color\n            ? '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:'\n                + formatUtil.encodeHTML(color) + ';' + (extraCssText || '') + '\"></span>'\n            : '';\n    };\n\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? ('0' + str) : str;\n    };\n\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @param {boolean} [isUTC=false] Default in local time.\n     *           see `module:echarts/scale/Time`\n     *           and `module:echarts/util/number#parseDate`.\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value, isUTC) {\n        if (tpl === 'week'\n            || tpl === 'month'\n            || tpl === 'quarter'\n            || tpl === 'half-year'\n            || tpl === 'year'\n        ) {\n            tpl = 'MM-dd\\nyyyy';\n        }\n\n        var date = numberUtil.parseDate(value);\n        var utc = isUTC ? 'UTC' : '';\n        var y = date['get' + utc + 'FullYear']();\n        var M = date['get' + utc + 'Month']() + 1;\n        var d = date['get' + utc + 'Date']();\n        var h = date['get' + utc + 'Hours']();\n        var m = date['get' + utc + 'Minutes']();\n        var s = date['get' + utc + 'Seconds']();\n\n        tpl = tpl.replace('MM', s2d(M))\n            .toLowerCase()\n            .replace('yyyy', y)\n            .replace('yy', y % 100)\n            .replace('dd', s2d(d))\n            .replace('d', d)\n            .replace('hh', s2d(h))\n            .replace('h', h)\n            .replace('mm', s2d(m))\n            .replace('m', m)\n            .replace('ss', s2d(s))\n            .replace('s', s);\n\n        return tpl;\n    };\n\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n\n    formatUtil.truncateText = textContain.truncateText;\n\n    module.exports = formatUtil;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/format.js\n// module id = 197\n// module chunks = 0 1 2 3 4 5 6","/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // canvas\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n                // events currently. So we dont use that on other browsers unless tested sufficiently.\n                // Although IE 10 supports pointer event, it use old style and is different from the\n                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n                && (browser.edge || (browser.ie && browser.version >= 11))\n        };\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/env.js\n// module id = 198\n// module chunks = 0 1 2 3 4 5 6","/**\n * @module echarts/model/Model\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazzUtil = require('../util/clazz');\n    var env = require('zrender/lib/core/env');\n\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;\n\n        // Simple optimization\n        // if (this.init) {\n        //     if (arguments.length <= 4) {\n        //         this.init(option, parentModel, ecModel, extraOpt);\n        //     }\n        //     else {\n        //         this.init.apply(this, arguments);\n        //     }\n        // }\n    }\n\n    Model.prototype = {\n\n        constructor: Model,\n\n        /**\n         * Model \n         * @param {Object} option\n         */\n        init: null,\n\n        /**\n         *  Option merge\n         */\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        get: function (path, ignoreParent) {\n            if (path == null) {\n                return this.option;\n            }\n\n            return doGet(\n                this.option,\n                this.parsePath(path),\n                !ignoreParent && getParent(this, path)\n            );\n        },\n\n        /**\n         * @param {string} key\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n\n            var val = option == null ? option : option[key];\n            var parentModel = !ignoreParent && getParent(this, key);\n            if (val == null && parentModel) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n\n        /**\n         * @param {string|Array.<string>} [path]\n         * @param {module:echarts/model/Model} [parentModel]\n         * @return {module:echarts/model/Model}\n         */\n        getModel: function (path, parentModel) {\n            var obj = path == null\n                ? this.option\n                : doGet(this.option, path = this.parsePath(path));\n\n            var thisParentModel;\n            parentModel = parentModel || (\n                (thisParentModel = getParent(this, path))\n                    && thisParentModel.getModel(path)\n            );\n\n            return new Model(obj, parentModel, this.ecModel);\n        },\n\n        /**\n         * If model has option\n         */\n        isEmpty: function () {\n            return this.option == null;\n        },\n\n        restoreData: function () {},\n\n        // Pending\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        },\n\n        // If path is null/undefined, return null/undefined.\n        parsePath: function(path) {\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            return path;\n        },\n\n        /**\n         * @param {Function} getParentMethod\n         *        param {Array.<string>|string} path\n         *        return {module:echarts/model/Model}\n         */\n        customizeGetParent: function (getParentMethod) {\n            clazzUtil.set(this, 'getParent', getParentMethod);\n        },\n\n        isAnimationEnabled: function () {\n            if (!env.node) {\n                if (this.option.animation != null) {\n                    return !!this.option.animation;\n                }\n                else if (this.parentModel) {\n                    return this.parentModel.isAnimationEnabled();\n                }\n            }\n        }\n    };\n\n    function doGet(obj, pathArr, parentModel) {\n        for (var i = 0; i < pathArr.length; i++) {\n            // Ignore empty\n            if (!pathArr[i]) {\n                continue;\n            }\n            // obj could be number/string/... (like 0)\n            obj = (obj && typeof obj === 'object') ? obj[pathArr[i]] : null;\n            if (obj == null) {\n                break;\n            }\n        }\n        if (obj == null && parentModel) {\n            obj = parentModel.get(pathArr);\n        }\n        return obj;\n    }\n\n    // `path` can be null/undefined\n    function getParent(model, path) {\n        var getParentMethod = clazzUtil.get(model, 'getParent');\n        return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n    }\n\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n\n    var mixin = zrUtil.mixin;\n    mixin(Model, require('./mixin/lineStyle'));\n    mixin(Model, require('./mixin/areaStyle'));\n    mixin(Model, require('./mixin/textStyle'));\n    mixin(Model, require('./mixin/itemStyle'));\n\n    module.exports = Model;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Model.js\n// module id = 199\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // \n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/BoundingRect.js\n// module id = 200\n// module chunks = 0 1 2 3 4 5 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var clazz = {};\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    var MEMBER_PRIFIX = '\\0ec_\\0';\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name] = value;` (can be right-value)\n     * @public\n     */\n    clazz.set = function (host, name, value) {\n        return (host[MEMBER_PRIFIX + name] = value);\n    };\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name];`\n     * @public\n     */\n    clazz.get = function (host, name) {\n        return host[MEMBER_PRIFIX + name];\n    };\n\n    /**\n     * For hidden private class member.\n     * The same behavior as `host.hasOwnProperty(name);`\n     * @public\n     */\n    clazz.hasOwn = function (host, name) {\n        return host.hasOwnProperty(MEMBER_PRIFIX + name);\n    };\n\n    /**\n     * Notice, parseClassType('') should returns {main: '', sub: ''}\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n        var ret = {main: '', sub: ''};\n        if (componentType) {\n            componentType = componentType.split(TYPE_DELIMITER);\n            ret.main = componentType[0] || '';\n            ret.sub = componentType[1] || '';\n        }\n        return ret;\n    };\n\n    /**\n     * @public\n     */\n    function checkClassType(componentType) {\n        zrUtil.assert(\n            /^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType),\n            'componentType \"' + componentType + '\" illegal'\n        );\n    }\n\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n\n            if (__DEV__) {\n                zrUtil.each(mandatoryMethods, function (method) {\n                    if (!proto[method]) {\n                        console.warn(\n                            'Method `' + method + '` should be implemented'\n                            + (proto.type ? ' in ' + proto.type : '') + '.'\n                        );\n                    }\n                });\n            }\n\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                }\n                else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n\n            zrUtil.extend(ExtendedClass.prototype, proto);\n\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n\n            return ExtendedClass;\n        };\n    };\n\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                checkClassType(componentType);\n                componentType = parseClassType(componentType);\n\n                if (!componentType.sub) {\n                    if (__DEV__) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                }\n                else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n\n        entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n            var Clazz = storage[componentMainType];\n\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error(\n                    !subType\n                        ? componentMainType + '.' + 'type should be specified.'\n                        : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.'\n                );\n            }\n\n            return Clazz;\n        };\n\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n\n            var result = [];\n            var obj = storage[componentType.main];\n\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            }\n            else {\n                result.push(obj);\n            }\n\n            return result;\n        };\n\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n\n        entity.parseClassType = parseClassType;\n\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n\n        return entity;\n    };\n\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n        // FIXME It seems broken in IE8 simulation of IE11\n        // if (!zrUtil.isArray(properties)) {\n        //     properties = properties != null ? [properties] : [];\n        // }\n        // zrUtil.each(properties, function (prop) {\n        //     var value = obj[prop];\n\n        //     Object.defineProperty\n        //         && Object.defineProperty(obj, prop, {\n        //             value: value, writable: false\n        //         });\n        //     zrUtil.isArray(obj[prop])\n        //         && Object.freeze\n        //         && Object.freeze(obj[prop]);\n        // });\n    };\n\n    module.exports = clazz;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/clazz.js\n// module id = 201\n// module chunks = 0 1 2 3 4 5 6","/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\n\n    var Model = require('./Model');\n    var zrUtil = require('zrender/lib/core/util');\n    var arrayPush = Array.prototype.push;\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var layout = require('../util/layout');\n\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n\n        type: 'component',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        id: '',\n\n        /**\n         * @readOnly\n         */\n        name: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        mainType: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        subType: '',\n\n        /**\n         * @readOnly\n         * @type {number}\n         */\n        componentIndex: 0,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        ecModel: null,\n\n        /**\n         * key: componentType\n         * value:  Component model list, can not be null.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @readOnly\n         */\n        dependentModels: [],\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        uid: null,\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        $constructor: function (option, parentModel, ecModel, extraOpt) {\n            Model.call(this, option, parentModel, ecModel, extraOpt);\n\n            this.uid = componentUtil.getUID('componentModel');\n        },\n\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n            this.mergeDefaultAndTheme(option, ecModel);\n        },\n\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            var themeModel = ecModel.getTheme();\n            zrUtil.merge(option, themeModel.get(this.mainType));\n            zrUtil.merge(option, this.getDefaultOption());\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (option, extraOpt) {\n            zrUtil.merge(this.option, option, true);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, option, layoutMode);\n            }\n        },\n\n        // Hooker after init or mergeOption\n        optionUpdated: function (newCptOption, isInit) {},\n\n        getDefaultOption: function () {\n            if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n                var optList = [];\n                var Class = this.constructor;\n                while (Class) {\n                    var opt = Class.prototype.defaultOption;\n                    opt && optList.push(opt);\n                    Class = Class.superClass;\n                }\n\n                var defaultOption = {};\n                for (var i = optList.length - 1; i >= 0; i--) {\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                }\n                clazzUtil.set(this, '__defaultOption', defaultOption);\n            }\n            return clazzUtil.get(this, '__defaultOption');\n        },\n\n        getReferringComponents: function (mainType) {\n            return this.ecModel.queryComponents({\n                mainType: mainType,\n                index: this.get(mainType + 'Index', true),\n                id: this.get(mainType + 'Id', true)\n            });\n        }\n\n    });\n\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n\n    //         this.uid = componentUtil.getUID('componentModel');\n\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(\n        ComponentModel, {registerWhenExtend: true}\n    );\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n\n    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n\n    module.exports = ComponentModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Component.js\n// module id = 202\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n// Layout helpers for each component positioning\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n    var numberUtil = require('./number');\n    var formatUtil = require('./format');\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n\n    var layout = {};\n\n    /**\n     * @public\n     */\n    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [\n        'left', 'right', 'top', 'bottom', 'width', 'height'\n    ];\n\n    /**\n     * @public\n     */\n    var HV_NAMES = layout.HV_NAMES = [\n        ['width', 'left', 'right'],\n        ['height', 'top', 'bottom']\n    ];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            }\n            else {\n                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n\n            if (child.newline) {\n                return;\n            }\n\n            position[0] = x;\n            position[1] = y;\n\n            orient === 'horizontal'\n                ? (x = nextX + gap)\n                : (y = nextY + gap);\n        });\n    }\n\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (\n        positionInfo, containerRect, margin\n    ) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            }\n            else {\n                height = containerHeight * 0.8;\n            }\n        }\n\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n            case 'center':\n                left = containerWidth / 2 - width / 2 - margin[3];\n                break;\n            case 'right':\n                left = containerWidth - width - horizontalMargin;\n                break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n            case 'middle':\n            case 'center':\n                top = containerHeight / 2 - height / 2 - margin[0];\n                break;\n            case 'bottom':\n                top = containerHeight - height - verticalMargin;\n                break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n\n\n    /**\n     * Position a zr element in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * Logic:\n     *     1. Scale (against origin point in parent coord)\n     *     2. Rotate (against origin point in parent coord)\n     *     3. Traslate (with el.position by this method)\n     * So this method only fixes the last step 'Traslate', which does not affect\n     * scaling and rotating.\n     *\n     * If be called repeatly with the same input el, the same result will be gotten.\n     *\n     * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @param {Object} [opt]\n     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n     * @param {Array.<number>} [opt.boundingMode='all']\n     *        Specify how to calculate boundingRect when locating.\n     *        'all': Position the boundingRect that is transformed and uioned\n     *               both itself and its descendants.\n     *               This mode simplies confine the elements in the bounding\n     *               of their container (e.g., using 'right: 0').\n     *        'raw': Position the boundingRect that is not transformed and only itself.\n     *               This mode is useful when you want a element can overflow its\n     *               container. (Consider a rotated circle needs to be located in a corner.)\n     *               In this mode positionInfo.width/height can only be number.\n     */\n    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\n        var h = !opt || !opt.hv || opt.hv[0];\n        var v = !opt || !opt.hv || opt.hv[1];\n        var boundingMode = opt && opt.boundingMode || 'all';\n\n        if (!h && !v) {\n            return;\n        }\n\n        var rect;\n        if (boundingMode === 'raw') {\n            rect = el.type === 'group'\n                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n                : el.getBoundingRect();\n        }\n        else {\n            rect = el.getBoundingRect();\n            if (el.needLocalTransform()) {\n                var transform = el.getLocalTransform();\n                // Notice: raw rect may be inner object of el,\n                // which should not be modified.\n                rect = rect.clone();\n                rect.applyTransform(transform);\n            }\n        }\n\n        positionInfo = layout.getLayoutRect(\n            zrUtil.defaults(\n                {width: rect.width, height: rect.height},\n                positionInfo\n            ),\n            containerRect,\n            margin\n        );\n\n        // Because 'tranlate' is the last step in transform\n        // (see zrender/core/Transformable#getLocalTransfrom),\n        // we can just only modify el.position to get final result.\n        var elPos = el.position;\n        var dx = h ? positionInfo.x - rect.x : 0;\n        var dy = v ? positionInfo.y - rect.y : 0;\n\n        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n    };\n\n    /**\n     * @param {Object} option Contains some of the properties in HV_NAMES.\n     * @param {number} hvIdx 0: horizontal; 1: vertical.\n     */\n    layout.sizeCalculable = function (option, hvIdx) {\n        return option[HV_NAMES[hvIdx][0]] != null\n            || (option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null);\n    };\n\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n\n        var ignoreSize = opt.ignoreSize;\n        !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n\n        var hResult = merge(HV_NAMES[0], 0);\n        var vResult = merge(HV_NAMES[1], 1);\n\n        copy(HV_NAMES[0], targetOption, hResult);\n        copy(HV_NAMES[1], targetOption, vResult);\n\n        function merge(names, hvIdx) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = 2;\n\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n\n            if (ignoreSize[hvIdx]) {\n                // Only one of left/right is premitted to exist.\n                if (hasValue(newOption, names[1])) {\n                    merged[names[2]] = null;\n                }\n                else if (hasValue(newOption, names[2])) {\n                    merged[names[1]] = null;\n                }\n                return merged;\n            }\n\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }\n            // Case: newOption: {width: ..., right: ...},\n            // Than we can make sure user only want those two, and ignore\n            // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            }\n            else {\n                // Chose another param from targetOption by priority.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n\n    module.exports = layout;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/layout.js\n// module id = 203\n// module chunks = 0 1 2 3 4 5 6","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * \n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/matrix.js\n// module id = 204\n// module chunks = 0 1 2 3 4 5 6","\n\n    var OrdinalScale = require('../scale/Ordinal');\n    var IntervalScale = require('../scale/Interval');\n    require('../scale/Time');\n    require('../scale/Log');\n    var Scale = require('../scale/Scale');\n\n    var numberUtil = require('../util/number');\n    var zrUtil = require('zrender/lib/core/util');\n    var textContain = require('zrender/lib/contain/text');\n    var axisHelper = {};\n\n    /**\n     * Get axis scale extent before niced.\n     * Item of returned array can only be number (including Infinity and NaN).\n     */\n    axisHelper.getScaleExtent = function (scale, model) {\n        var scaleType = scale.type;\n\n        var min = model.getMin();\n        var max = model.getMax();\n        var fixMin = min != null;\n        var fixMax = max != null;\n        var originalExtent = scale.getExtent();\n\n        var axisDataLen;\n        var boundaryGap;\n        var span;\n        if (scaleType === 'ordinal') {\n            axisDataLen = (model.get('data') || []).length;\n        }\n        else {\n            boundaryGap = model.get('boundaryGap');\n            if (!zrUtil.isArray(boundaryGap)) {\n                boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n            }\n            if (typeof boundaryGap[0] === 'boolean') {\n                if (__DEV__) {\n                    console.warn('Boolean type for boundaryGap is only '\n                        + 'allowed for ordinal axis. Please use string in '\n                        + 'percentage instead, e.g., \"20%\". Currently, '\n                        + 'boundaryGap is set to be 0.');\n                }\n                boundaryGap = [0, 0];\n            }\n            boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n            span = (originalExtent[1] - originalExtent[0])\n                || Math.abs(originalExtent[0]);\n        }\n\n        // Notice: When min/max is not set (that is, when there are null/undefined,\n        // which is the most common case), these cases should be ensured:\n        // (1) For 'ordinal', show all axis.data.\n        // (2) For others:\n        //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n        //      disabled).\n        //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n        //      be the result that originalExtent enlarged by boundaryGap.\n        // (3) If no data, it should be ensured that `scale.setBlank` is set.\n\n        // FIXME\n        // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n        // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n        // that the results processed by boundaryGap are positive/negative?\n\n        if (min == null) {\n            min = scaleType === 'ordinal'\n                ? (axisDataLen ? 0 : NaN)\n                : originalExtent[0] - boundaryGap[0] * span;\n        }\n        if (max == null) {\n            max = scaleType === 'ordinal'\n                ? (axisDataLen ? axisDataLen - 1 : NaN)\n                : originalExtent[1] + boundaryGap[1] * span;\n        }\n\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n\n        (min == null || !isFinite(min)) && (min = NaN);\n        (max == null || !isFinite(max)) && (max = NaN);\n\n        scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max));\n\n        // Evaluate if axis needs cross zero\n        if (model.getNeedCrossZero()) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n\n        return [min, max];\n    };\n\n    axisHelper.niceScaleExtent = function (scale, model) {\n        var extent = axisHelper.getScaleExtent(scale, model);\n        var fixMin = model.getMin() != null;\n        var fixMax = model.getMax() != null;\n        var splitNumber = model.get('splitNumber');\n\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent({\n            splitNumber: splitNumber,\n            fixMin: fixMin,\n            fixMax: fixMax,\n            minInterval: scale.type === 'interval' ? model.get('minInterval') : null\n        });\n\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function(model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n                // Buildin scale\n                case 'category':\n                    return new OrdinalScale(\n                        model.getCategories(), [Infinity, -Infinity]\n                    );\n                case 'value':\n                    return new IntervalScale();\n                // Extended scale, like time and log\n                default:\n                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n    };\n\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // axislabelhorizontalvertical.\n\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(\n                labels[i], font, 'center', 'top'\n            );\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }\n            // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            }\n            else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = (function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val != null ? val : '');\n                };\n            })(labelFormatter);\n            // Consider empty array\n            return zrUtil.map(labels, labelFormatter);\n        }\n        else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(\n                    axisHelper.getAxisRawValue(axis, tick),\n                    idx\n                );\n            }, this);\n        }\n        else {\n            return labels;\n        }\n    };\n\n    axisHelper.getAxisRawValue = function (axis, value) {\n        // In category axis with data zoom, tick is not the original\n        // index of axis.data. So tick should not be exposed to user\n        // in category axis.\n        return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n    };\n\n    module.exports = axisHelper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisHelper.js\n// module id = 205\n// module chunks = 0 1 2 3 4 5 6","\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText  Canvas \n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME \n        var lineHeight = getTextWidth('', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var lineHeight = textRect.lineHeight;\n        var halfHeight = height / 2 - textHeight / 2 + lineHeight;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight - lineHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance + lineHeight;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance + lineHeight;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance + lineHeight;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance + lineHeight;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'alphabetic'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/text.js\n// module id = 206\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // \n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} \n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] \n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out \n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/curve.js\n// module id = 207\n// module chunks = 0 1 2 3 4 5 6","/**\n * @module zrender/tool/color\n */\n\n\n    var LRU = require('../core/LRU');\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    function setRgba(out, r, g, b, a) {\n        out[0] = r; out[1] = g; out[2] = b; out[3] = a;\n        return out;\n    }\n    function copyRgba(out, a) {\n        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n        return out;\n    }\n    var colorCache = new LRU(20);\n    var lastRemovedArr = null;\n    function putToCache(colorStr, rgbaArr) {\n        // Reuse removed array\n        if (lastRemovedArr) {\n            copyRgba(lastRemovedArr, rgbaArr);\n        }\n        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n    }\n    /**\n     * @param {string} colorStr\n     * @param {Array.<number>} out\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr, rgbaArr) {\n        if (!colorStr) {\n            return;\n        }\n        rgbaArr = rgbaArr || [];\n\n        var cached = colorCache.get(colorStr);\n        if (cached) {\n            return copyRgba(rgbaArr, cached);\n        }\n\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            copyRgba(rgbaArr, kCSSColorTable[str]);\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    setRgba(rgbaArr,\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    );\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsla':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsl':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                default:\n                    return;\n            }\n        }\n\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla, rgba) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        rgba = rgba || [];\n        setRgba(rgba,\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),\n            1\n        );\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array.\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>} will be null/undefined if input illegal.\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        out = out || [];\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssFloat(lerp(leftColor[3], rightColor[3], dv));\n\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<number>} arrColor like [12,33,44,0.4]\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color. (If input illegal, return undefined).\n     */\n    function stringify(arrColor, type) {\n        if (!arrColor || !arrColor.length) {\n            return;\n        }\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/color.js\n// module id = 208\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = require('../mixin/Eventful');\n    var env = require('./env');\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * domtouch.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * preventDefault and stopPropagation.\n     * Notice: do not do that in zrender. Upper application\n     * do that if necessary.\n     *\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // \n        Dispatcher: Eventful\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/event.js\n// module id = 209\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * \n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * trigger\n         *\n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} [handler] \n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * \n         *\n         * @param {string} type \n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * context, context\n         * @param {string} type \n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    //  onxxxx \n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Eventful.js\n// module id = 210\n// module chunks = 0 1 2 3 4 5 6","/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array;\n\n    var dataCtors = {\n        'float': Float64Array,\n        'int': Int32Array,\n        // Ordinal data type can be string or int\n        'ordinal': Array,\n        'number': Array,\n        'time': Array\n    };\n\n    var Model = require('../model/Model');\n    var DataDiffer = require('./DataDiffer');\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var isObject = zrUtil.isObject;\n\n    var TRANSFERABLE_PROPERTIES = [\n        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n    ];\n\n    function transferProperties(a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n\n        a.__wrappedMethods = b.__wrappedMethods;\n    }\n\n    function DefaultDataProvider(dataArray) {\n        this._array = dataArray || [];\n    }\n\n    DefaultDataProvider.prototype.pure = false;\n\n    DefaultDataProvider.prototype.count = function () {\n        return this._array.length;\n    };\n    DefaultDataProvider.prototype.getItem = function (idx) {\n        return this._array[idx];\n    };\n\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string|Object>} dimensions\n     *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n     *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n\n        dimensions = dimensions || ['x', 'y'];\n\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    coordDim: dimensionName,\n                    coordDimIndex: 0,\n                    stackable: false,\n                    // Type can be 'float', 'int', 'number'\n                    // Default is number, Precision of float may not enough\n                    type: 'number'\n                };\n            }\n            else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n                if (!dimensionInfo.coordDim) {\n                    dimensionInfo.coordDim = dimensionName;\n                    dimensionInfo.coordDimIndex = 0;\n                }\n            }\n            dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n\n    var listProto = List.prototype;\n\n    listProto.type = 'list';\n\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n\n        var isDataArray = zrUtil.isArray(data);\n        if (isDataArray) {\n            data = new DefaultDataProvider(data);\n        }\n        if (__DEV__) {\n            if (!isDataArray && (typeof data.getItem != 'function' || typeof data.count != 'function')) {\n                throw new Error('Inavlid data provider.');\n            }\n        }\n\n        this._rawData = data;\n\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n\n        var dimensions = this.dimensions;\n        var dimensionInfoMap = this._dimensionInfos;\n\n        var size = data.count();\n\n        var idList = [];\n        var nameRepeatCount = {};\n        var nameDimIdx;\n\n        nameList = nameList || [];\n\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(\n                (value instanceof Array)\n                    ? value[dimIndex]\n                    // If value is a single number or something else not array.\n                    : value,\n                dimensionInfoMap[dimName]\n            );\n        };\n\n        for (var i = 0; i < size; i++) {\n            // NOTICE: Try not to write things into dataItem\n            var dataItem = data.getItem(i);\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[i] = dimValueGetter(dataItem, dim, i, k);\n            }\n\n            indices.push(i);\n        }\n\n        // Use the name in option and create id\n        for (var i = 0; i < size; i++) {\n            var dataItem = data.getItem(i);\n            if (!nameList[i] && dataItem) {\n                if (dataItem.name != null) {\n                    nameList[i] = dataItem.name;\n                }\n                else if (nameDimIdx != null) {\n                    nameList[i] = storage[dimensions[nameDimIdx]][i];\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = dataItem && dataItem.id;\n\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n\n        // If value not exists\n        if (dataIndex == null || !storage[dim]) {\n            return NaN;\n        }\n\n        var value = storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n                        || (value <= 0 && stackedValue < 0) // Negative stack\n                    ) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n\n        return values;\n    };\n\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (\n                // Ordinal type can be string or number\n                dimensionInfos[dimensions[i]].type !== 'ordinal'\n                && isNaN(this.get(dimensions[i], idx))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     * @param {Function} filter\n     */\n    listProto.getDataExtent = function (dim, stack, filter) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = (dimInfo && dimInfo.stackable) && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                if (!filter || filter(value, dim, i)) {\n                    value < min && (min = value);\n                    value > max && (max = value);\n                }\n            }\n            return (this._extent[dim + !!stack] = [min, max]);\n        }\n        else {\n            return [Infinity, -Infinity];\n        }\n    };\n\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n\n        // If rawIndex === dataIndex\n        var rawDataIndex = indices[rawIndex];\n        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n            return rawIndex;\n        }\n\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            }\n            else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {Array.<number>} Considere multiple points has the same value.\n     */\n    listProto.indicesOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var nearestIndices = [];\n\n        if (!dimData) {\n            return nearestIndices;\n        }\n\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n\n        var minDist = Number.MAX_VALUE;\n        var minDiff = -1;\n        for (var i = 0, len = this.count(); i < len; i++) {\n            var diff = value - this.get(dim, i, stack);\n            var dist = Math.abs(diff);\n            if (diff <= maxDistance && dist <= minDist) {\n                // For the case of two data are same on xAxis, which has sequence data.\n                // Show the nearest index\n                // https://github.com/ecomfe/echarts/issues/2869\n                if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                    minDist = dist;\n                    minDiff = diff;\n                    nearestIndices.length = 0;\n                }\n                nearestIndices.push(i);\n            }\n        }\n        return nearestIndices;\n    };\n\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData.getItem(this.getRawIndex(idx));\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n    };\n\n\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n                case 0:\n                    cb.call(context, i);\n                    break;\n                case 1:\n                    cb.call(context, this.get(dims[0], i, stack), i);\n                    break;\n                case 2:\n                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                    break;\n                default:\n                    for (var k = 0; k < dimSize; k++) {\n                        value[k] = this.get(dims[k], i, stack);\n                    }\n                    // Index\n                    value[k] = i;\n                    cb.apply(context, value);\n            }\n        }\n    };\n\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (!dimSize) {\n                keep = cb.call(context, i);\n            }\n            else if (dimSize === 1) {\n                keep = cb.call(\n                    context, this.get(dimensions[0], i, stack), i\n                );\n            }\n            else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n\n        this.indices = newIndices;\n\n        // Reset data extent\n        this._extent = {};\n\n        return this;\n    };\n\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(\n            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n            original.hostModel\n        );\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(\n                    originalStorage[dim].length\n                );\n            }\n            else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n\n        var storage = list._storage;\n\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n\n        return list;\n    };\n\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n\n        return list;\n    };\n\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);\n    };\n\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        var val;\n        // Use prefix to avoid index to be the same as otherIdList[idx],\n        // which will cause weird udpate animation.\n        var prefix = 'e\\0\\0';\n\n        return new DataDiffer(\n            otherList ? otherList.indices : [],\n            this.indices,\n            function (idx) {\n                return (val = otherIdList[idx]) != null ? val : prefix + idx;\n            },\n            function (idx) {\n                return (val = idList[idx]) != null ? val : prefix + idx;\n            }\n        );\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge\n            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n            : layout;\n    };\n\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} [ignoreParent=false]\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n\n        this._graphicEls[idx] = el;\n    };\n\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n\n        // FIXME\n        list._storage = this._storage;\n\n        transferProperties(list, this);\n\n\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n\n        return list;\n    };\n\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\n    module.exports = List;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/List.js\n// module id = 211\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    // var CMD_MEM_SIZE = {\n    //     M: 3,\n    //     L: 3,\n    //     C: 7,\n    //     Q: 5,\n    //     A: 9,\n    //     R: 5,\n    //     Z: 1\n    // };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function (notSaveData) {\n\n        this._saveData = !(notSaveData || false);\n\n        if (this._saveData) {\n            /**\n             * Path data. Stored as flat array\n             * @type {Array.<Object>}\n             */\n            this.data = [];\n        }\n\n        this._ctx = null;\n    };\n\n    /**\n     * Path\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _xi: 0,\n        _yi: 0,\n\n        _x0: 0,\n        _y0: 0,\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        _ux: 0,\n        _uy: 0,\n\n        _len: 0,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            if (this._saveData) {\n                this._len = 0;\n            }\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi  _dashedXXXXTo \n            // xi, yi , x0, y0  closePath \n            //  beginPath  lineTo x0, y0 \n            //  lineTo dashed line  IE10- \n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._yi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context  rebuildPath  fill\n         * stroke \n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         *  Path \n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * \n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         *  Path \n         * \n         */\n        addData: function (cmd) {\n            if (!this._saveData) {\n                return;\n            }\n\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                //  Float32Array\n                // \n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         *  Float32Array \n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo  subpath, \n                        //  closePath \n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc \n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc \n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/PathProxy.js\n// module id = 212\n// module chunks = 0 1 2 3 4 5 6","/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n\n    var clazzUtil = require('../util/clazz');\n\n    /**\n     * @param {Object} [setting]\n     */\n    function Scale(setting) {\n        this._setting = setting || {};\n\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [Infinity, -Infinity];\n\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n\n        this.init && this.init.apply(this, arguments);\n    }\n\n    var scaleProto = Scale.prototype;\n\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n\n    scaleProto.getSetting = function (name) {\n        return this._setting[name];\n    };\n\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        // not setExtent because in log axis it may transformed to power\n        // this.setExtent(extent[0], extent[1]);\n    };\n\n    /**\n     * Set extent from data\n     * @param {module:echarts/data/List} data\n     * @param {string} dim\n     */\n    scaleProto.unionExtentFromData = function (data, dim) {\n        this.unionExtent(data.getDataExtent(dim, true));\n    };\n\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.isBlank = function () {\n        return this._isBlank;\n    },\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.setBlank = function (isBlank) {\n        this._isBlank = isBlank;\n    };\n\n\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, {\n        registerWhenExtend: true\n    });\n\n    module.exports = Scale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Scale.js\n// module id = 213\n// module chunks = 0 1 2 3 4 5 6","\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config\n     * @exports zrender/config\n     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debugcatchBrushExceptiontrue\n         * 0 : debug\n         * 1 : \n         * 2 : \n         */\n        debugMode: 0,\n\n        // retina \n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/config.js\n// module id = 214\n// module chunks = 0 1 2 3 4 5 6","/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * \n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         *  index \n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * \n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         *  nextSibling \n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToStorage(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromStorage(child);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * \n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromStorage(child);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToStorage(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromStorage(child);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/container/Group.js\n// module id = 215\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var coordinateSystemCreators = {};\n\n    function CoordinateSystemManager() {\n\n        this._coordinateSystems = [];\n    }\n\n    CoordinateSystemManager.prototype = {\n\n        constructor: CoordinateSystemManager,\n\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n                var list = creater.create(ecModel, api);\n                coordinateSystems = coordinateSystems.concat(list || []);\n            });\n\n            this._coordinateSystems = coordinateSystems;\n        },\n\n        update: function (ecModel, api) {\n            zrUtil.each(this._coordinateSystems, function (coordSys) {\n                // FIXME MUST have\n                coordSys.update && coordSys.update(ecModel, api);\n            });\n        },\n\n        getCoordinateSystems: function () {\n            return this._coordinateSystems.slice();\n        }\n    };\n\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n\n    module.exports = CoordinateSystemManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/CoordinateSystem.js\n// module id = 216\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../util/format');\n    var classUtil = require('../util/clazz');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var colorPaletteMixin = require('./mixin/colorPalette');\n    var env = require('zrender/lib/core/env');\n    var layout = require('../util/layout');\n\n    var set = classUtil.set;\n    var get = classUtil.get;\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            var data = this.getInitialData(option, ecModel);\n            if (__DEV__) {\n                zrUtil.assert(data, 'getInitialData returned invalid data.');\n            }\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            set(this, 'dataBeforeProcessed', data);\n\n            // If we reverse the order (make data firstly, and then make\n            // dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause data.graph.data !== data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this.restoreData();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `position` and `show`\n            // FIXME Set label in mergeOption\n            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\n            this.fillDataTextStyle(option.data);\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n            }\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                set(this, 'data', data);\n                set(this, 'dataBeforeProcessed', data.cloneShallow());\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `position` and `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            var data = get(this, 'data');\n            return dataType == null ? data : data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            set(this, 'data', data);\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return get(this, 'dataBeforeProcessed');\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return modelUtil.coordDimToDataDim(this.getData(), coordDim);\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return modelUtil.dataDimToCoordDim(this.getData(), dataDim);\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var vertially = zrUtil.reduce(value, function (vertially, val, idx) {\n                    var dimItem = data.getDimensionInfo(idx);\n                    return vertially |= dimItem && dimItem.tooltip !== false && dimItem.tooltipName != null;\n                }, 0);\n\n                var result = [];\n                var tooltipDims = modelUtil.otherDimToDataDim(data, 'tooltip');\n\n                tooltipDims.length\n                    ? zrUtil.each(tooltipDims, function (dimIdx) {\n                        setEachItem(data.get(dimIdx, dataIndex), dimIdx);\n                    })\n                    // By default, all dims is used on tooltip.\n                    : zrUtil.each(value, setEachItem);\n\n                function setEachItem(val, dimIdx) {\n                    var dimInfo = data.getDimensionInfo(dimIdx);\n                    // If `dimInfo.tooltip` is not set, show tooltip.\n                    if (!dimInfo || dimInfo.otherDims.tooltip === false) {\n                        return;\n                    }\n                    var dimType = dimInfo.type;\n                    var valStr = (vertially ? '- ' + (dimInfo.tooltipName || dimInfo.name) + ': ' : '')\n                        + (dimType === 'ordinal'\n                            ? val + ''\n                            : dimType === 'time'\n                            ? (multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val))\n                            : addCommas(val)\n                        );\n                    valStr && result.push(encodeHTML(valStr));\n                }\n\n                return (vertially ? '<br/>' : '') + result.join(vertially ? '<br/>' : ', ');\n            }\n\n            var data = get(this, 'data');\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = zrUtil.isArray(value)\n                ? formatArrayValue(value) : encodeHTML(addCommas(value));\n            var name = data.getName(dataIndex);\n\n            var color = data.getItemVisual(dataIndex, 'color');\n            if (zrUtil.isObject(color) && color.colorStops) {\n                color = (color.colorStops[0] || {}).color;\n            }\n            color = color || 'transparent';\n\n            var colorEl = formatUtil.getTooltipMarker(color);\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            seriesName = seriesName\n                ? encodeHTML(seriesName) + (!multipleSeries ? '<br/>' : ': ')\n                : '';\n            return !multipleSeries\n                ? seriesName + colorEl\n                    + (name\n                        ? encodeHTML(name) + ': ' + formattedValue\n                        : formattedValue\n                    )\n                : colorEl + seriesName + formattedValue;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        isAnimationEnabled: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Object} {dataIndices, nestestValue}.\n         */\n        getAxisTooltipData: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Series.js\n// module id = 217\n// module chunks = 0 1 2 3 4 5 6","/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var each = zrUtil.each;\n    var isString = zrUtil.isString;\n    var defaults = zrUtil.defaults;\n    var normalizeToArray = modelUtil.normalizeToArray;\n\n    var OTHER_DIMS = {tooltip: 1, label: 1, itemName: 1};\n\n    /**\n     * Complete the dimensions array, by user defined `dimension` and `encode`,\n     * and guessing from the data structure.\n     * If no 'value' dimension specified, the first no-named dimension will be\n     * named as 'value'.\n     *\n     * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which\n     *      provides not only dim template, but also default order.\n     *      `name` of each item provides default coord name.\n     *      [{dimsDef: []}, ...] can be specified to give names.\n     * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].\n     * @param {Object} [opt]\n     * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions\n     *      For example: ['asdf', {name, type}, ...].\n     * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}\n     * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.\n     * @param {string} [opt.extraFromZero] If specified, extra dim names will be:\n     *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...\n     *                      If not specified, extra dim names will be:\n     *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...\n     * @param {number} [opt.dimCount] If not specified, guess by the first data item.\n     * @return {Array.<Object>} [{\n     *      name: string mandatory,\n     *      coordDim: string mandatory,\n     *      coordDimIndex: number mandatory,\n     *      type: string optional,\n     *      tooltipName: string optional,\n     *      otherDims: {\n     *          tooltip: number optional,\n     *          label: number optional\n     *      },\n     *      isExtraCoord: boolean true or undefined.\n     *      other props ...\n     * }]\n     */\n    function completeDimensions(sysDims, data, opt) {\n        data = data || [];\n        opt = opt || {};\n        sysDims = (sysDims || []).slice();\n        var dimsDef = (opt.dimsDef || []).slice();\n        var encodeDef = zrUtil.createHashMap(opt.encodeDef);\n        var dataDimNameMap = zrUtil.createHashMap();\n        var coordDimNameMap = zrUtil.createHashMap();\n        // var valueCandidate;\n        var result = [];\n\n        var dimCount = opt.dimCount;\n        if (dimCount == null) {\n            var value0 = retrieveValue(data[0]);\n            dimCount = Math.max(\n                zrUtil.isArray(value0) && value0.length || 1,\n                sysDims.length,\n                dimsDef.length\n            );\n            each(sysDims, function (sysDimItem) {\n                var sysDimItemDimsDef = sysDimItem.dimsDef;\n                sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));\n            });\n        }\n\n        // Apply user defined dims (`name` and `type`) and init result.\n        for (var i = 0; i < dimCount; i++) {\n            var dimDefItem = isString(dimsDef[i]) ? {name: dimsDef[i]} : (dimsDef[i] || {});\n            var userDimName = dimDefItem.name;\n            var resultItem = result[i] = {otherDims: {}};\n            // Name will be applied later for avoiding duplication.\n            if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n                // Only if `series.dimensions` is defined in option, tooltipName\n                // will be set, and dimension will be diplayed vertically in\n                // tooltip by default.\n                resultItem.name = resultItem.tooltipName = userDimName;\n                dataDimNameMap.set(userDimName, i);\n            }\n            dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n        }\n\n        // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.\n        encodeDef.each(function (dataDims, coordDim) {\n            dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice());\n            each(dataDims, function (resultDimIdx, coordDimIndex) {\n                // The input resultDimIdx can be dim name or index.\n                isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));\n                if (resultDimIdx != null && resultDimIdx < dimCount) {\n                    dataDims[coordDimIndex] = resultDimIdx;\n                    applyDim(result[resultDimIdx], coordDim, coordDimIndex);\n                }\n            });\n        });\n\n        // Apply templetes and default order from `sysDims`.\n        var availDimIdx = 0;\n        each(sysDims, function (sysDimItem, sysDimIndex) {\n            var coordDim;\n            var sysDimItem;\n            var sysDimItemDimsDef;\n            var sysDimItemOtherDims;\n            if (isString(sysDimItem)) {\n                coordDim = sysDimItem;\n                sysDimItem = {};\n            }\n            else {\n                coordDim = sysDimItem.name;\n                sysDimItem = zrUtil.clone(sysDimItem);\n                // `coordDimIndex` should not be set directly.\n                sysDimItemDimsDef = sysDimItem.dimsDef;\n                sysDimItemOtherDims = sysDimItem.otherDims;\n                sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex\n                    = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n            }\n\n            var dataDims = normalizeToArray(encodeDef.get(coordDim));\n            // dimensions provides default dim sequences.\n            if (!dataDims.length) {\n                for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n                    while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n                        availDimIdx++;\n                    }\n                    availDimIdx < result.length && dataDims.push(availDimIdx++);\n                }\n            }\n            // Apply templates.\n            each(dataDims, function (resultDimIdx, coordDimIndex) {\n                var resultItem = result[resultDimIdx];\n                applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n                if (resultItem.name == null && sysDimItemDimsDef) {\n                    resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];\n                }\n                sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n            });\n        });\n\n        // Make sure the first extra dim is 'value'.\n        var extra = opt.extraPrefix || 'value';\n\n        // Set dim `name` and other `coordDim` and other props.\n        for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n            var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};\n            var coordDim = resultItem.coordDim;\n\n            coordDim == null && (\n                resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero),\n                resultItem.coordDimIndex = 0,\n                resultItem.isExtraCoord = true\n            );\n\n            resultItem.name == null && (resultItem.name = genName(\n                resultItem.coordDim,\n                dataDimNameMap\n            ));\n\n            resultItem.type == null && guessOrdinal(data, resultDimIdx)\n                && (resultItem.type = 'ordinal');\n        }\n\n        return result;\n\n        function applyDim(resultItem, coordDim, coordDimIndex) {\n            if (OTHER_DIMS[coordDim]) {\n                resultItem.otherDims[coordDim] = coordDimIndex;\n            }\n            else {\n                resultItem.coordDim = coordDim;\n                resultItem.coordDimIndex = coordDimIndex;\n                coordDimNameMap.set(coordDim, true);\n            }\n        }\n\n        function genName(name, map, fromZero) {\n            if (fromZero || map.get(name) != null) {\n                var i = 0;\n                while (map.get(name + i) != null) {\n                    i++;\n                }\n                name += i;\n            }\n            map.set(name, true);\n            return name;\n        }\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            // Consider usage convenience, '1', '2' will be treated as \"number\".\n            if (value != null && isFinite(value)) {\n                return false;\n            }\n            else if (isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/helper/completeDimensions.js\n// module id = 218\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n// Symbol factory\n\n\n    var graphic = require('./graphic');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME  onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            // TODO Support image object, DynamicImage.\n\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/symbol.js\n// module id = 219\n// module chunks = 0 1 2 3 4 5 6","// TODO Parse shadow style\n// TODO Only shallow path support\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n               properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes, includes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if ((excludes && zrUtil.indexOf(excludes, propName) >= 0)\n                    || (includes && zrUtil.indexOf(includes, propName) < 0)\n                ) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/makeStyleMapper.js\n// module id = 220\n// module chunks = 0 1 2 3 4 5 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Model = require('../../model/Model');\n    var each = zrUtil.each;\n    var curry = zrUtil.curry;\n\n    var helper = {};\n\n    // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n    // allAxesInfo should be updated when setOption performed.\n    helper.collect = function (ecModel, api) {\n        var result = {\n            /**\n             * key: makeKey(axis.model)\n             * value: {\n             *      axis,\n             *      coordSys,\n             *      axisPointerModel,\n             *      triggerTooltip,\n             *      involveSeries,\n             *      snap,\n             *      seriesModels,\n             *      seriesDataCount\n             * }\n             */\n            axesInfo: {},\n            seriesInvolved: false,\n            /**\n             * key: makeKey(coordSys.model)\n             * value: Object: key makeKey(axis.model), value: axisInfo\n             */\n            coordSysAxesInfo: {},\n            coordSysMap: {}\n        };\n\n        collectAxesInfo(result, ecModel, api);\n\n        // Check seriesInvolved for performance, in case too many series in some chart.\n        result.seriesInvolved && collectSeriesInfo(result, ecModel);\n\n        return result;\n    };\n\n    function collectAxesInfo(result, ecModel, api) {\n        var globalTooltipModel = ecModel.getComponent('tooltip');\n        var globalAxisPointerModel = ecModel.getComponent('axisPointer');\n        // links can only be set on global.\n        var linksOption = globalAxisPointerModel.get('link', true) || [];\n        var linkGroups = [];\n\n        // Collect axes info.\n        each(api.getCoordinateSystems(), function (coordSys) {\n            // Some coordinate system do not support axes, like geo.\n            if (!coordSys.axisPointerEnabled) {\n                return;\n            }\n\n            var coordSysKey = makeKey(coordSys.model);\n            var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n            result.coordSysMap[coordSysKey] = coordSys;\n\n            // Set tooltip (like 'cross') is a convienent way to show axisPointer\n            // for user. So we enable seting tooltip on coordSys model.\n            var coordSysModel = coordSys.model;\n            var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n\n            each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null));\n\n            // If axis tooltip used, choose tooltip axis for each coordSys.\n            // Notice this case: coordSys is `grid` but not `cartesian2D` here.\n            if (coordSys.getTooltipAxes\n                && globalTooltipModel\n                // If tooltip.showContent is set as false, tooltip will not\n                // show but axisPointer will show as normal.\n                && baseTooltipModel.get('show')\n            ) {\n                // Compatible with previous logic. But series.tooltip.trigger: 'axis'\n                // or series.data[n].tooltip.trigger: 'axis' are not support any more.\n                var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n                var cross = baseTooltipModel.get('axisPointer.type') === 'cross';\n                var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));\n                if (triggerAxis || cross) {\n                    each(tooltipAxes.baseAxes, curry(\n                        saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis\n                    ));\n                }\n                if (cross) {\n                    each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));\n                }\n            }\n\n            // fromTooltip: true | false | 'cross'\n            // triggerTooltip: true | false | null\n            function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n                var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n\n                var axisPointerShow = axisPointerModel.get('show');\n                if (!axisPointerShow || (\n                    axisPointerShow === 'auto'\n                    && !fromTooltip\n                    && !isHandleTrigger(axisPointerModel)\n                )) {\n                    return;\n                }\n\n                if (triggerTooltip == null) {\n                    triggerTooltip = axisPointerModel.get('triggerTooltip');\n                }\n\n                axisPointerModel = fromTooltip\n                    ? makeAxisPointerModel(\n                        axis, baseTooltipModel, globalAxisPointerModel, ecModel,\n                        fromTooltip, triggerTooltip\n                    )\n                    : axisPointerModel;\n\n                var snap = axisPointerModel.get('snap');\n                var key = makeKey(axis.model);\n                var involveSeries = triggerTooltip || snap || axis.type === 'category';\n\n                // If result.axesInfo[key] exist, override it (tooltip has higher priority).\n                var axisInfo = result.axesInfo[key] = {\n                    key: key,\n                    axis: axis,\n                    coordSys: coordSys,\n                    axisPointerModel: axisPointerModel,\n                    triggerTooltip: triggerTooltip,\n                    involveSeries: involveSeries,\n                    snap: snap,\n                    useHandle: isHandleTrigger(axisPointerModel),\n                    seriesModels: []\n                };\n                axesInfoInCoordSys[key] = axisInfo;\n                result.seriesInvolved |= involveSeries;\n\n                var groupIndex = getLinkGroupIndex(linksOption, axis);\n                if (groupIndex != null) {\n                    var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {axesInfo: {}});\n                    linkGroup.axesInfo[key] = axisInfo;\n                    linkGroup.mapper = linksOption[groupIndex].mapper;\n                    axisInfo.linkGroup = linkGroup;\n                }\n            }\n        });\n    }\n\n    function makeAxisPointerModel(\n        axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip\n    ) {\n        var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n        var volatileOption = {};\n\n        each(\n            [\n                'type', 'snap', 'lineStyle', 'shadowStyle', 'label',\n                'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'\n            ],\n            function (field) {\n                volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));\n            }\n        );\n\n        // category axis do not auto snap, otherwise some tick that do not\n        // has value can not be hovered. value/time/log axis default snap if\n        // triggered from tooltip and trigger tooltip.\n        volatileOption.snap = axis.type !== 'category' && !!triggerTooltip;\n\n        // Compatibel with previous behavior, tooltip axis do not show label by default.\n        // Only these properties can be overrided from tooltip to axisPointer.\n        if (tooltipAxisPointerModel.get('type') === 'cross') {\n            volatileOption.type = 'line';\n        }\n        var labelOption = volatileOption.label || (volatileOption.label = {});\n        // Follow the convention, do not show label when triggered by tooltip by default.\n        labelOption.show == null && (labelOption.show = false);\n\n        if (fromTooltip === 'cross') {\n            // When 'cross', both axes show labels.\n            labelOption.show = true;\n            // If triggerTooltip, this is a base axis, which should better not use cross style\n            // (cross style is dashed by default)\n            if (!triggerTooltip) {\n                var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n                crossStyle && zrUtil.defaults(\n                    labelOption.textStyle || (labelOption.textStyle = {}),\n                    crossStyle.textStyle\n                );\n            }\n        }\n\n        return axis.model.getModel(\n            'axisPointer',\n            new Model(volatileOption, globalAxisPointerModel, ecModel)\n        );\n    }\n\n    function collectSeriesInfo(result, ecModel) {\n        // Prepare data for axis trigger\n        ecModel.eachSeries(function (seriesModel) {\n\n            // Notice this case: this coordSys is `cartesian2D` but not `grid`.\n            var coordSys = seriesModel.coordinateSystem;\n            var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);\n            var seriesTooltipShow = seriesModel.get('tooltip.show', true);\n            if (!coordSys\n                || seriesTooltipTrigger === 'none'\n                || seriesTooltipTrigger === false\n                || seriesTooltipTrigger === 'item'\n                || seriesTooltipShow === false\n                || seriesModel.get('axisPointer.show', true) === false\n            ) {\n                return;\n            }\n\n            each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n                var axis = axisInfo.axis;\n                if (coordSys.getAxis(axis.dim) === axis) {\n                    axisInfo.seriesModels.push(seriesModel);\n                    axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n                    axisInfo.seriesDataCount += seriesModel.getData().count();\n                }\n            });\n\n        }, this);\n    }\n\n    /**\n     * For example:\n     * {\n     *     axisPointer: {\n     *         links: [{\n     *             xAxisIndex: [2, 4],\n     *             yAxisIndex: 'all'\n     *         }, {\n     *             xAxisId: ['a5', 'a7'],\n     *             xAxisName: 'xxx'\n     *         }]\n     *     }\n     * }\n     */\n    function getLinkGroupIndex(linksOption, axis) {\n        var axisModel = axis.model;\n        var dim = axis.dim;\n        for (var i = 0; i < linksOption.length; i++) {\n            var linkOption = linksOption[i] || {};\n            if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id)\n                || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex)\n                || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)\n            ) {\n                return i;\n            }\n        }\n    }\n\n    function checkPropInLink(linkPropValue, axisPropValue) {\n        return linkPropValue === 'all'\n            || (zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0)\n            || linkPropValue === axisPropValue;\n    }\n\n    helper.fixValue = function (axisModel) {\n        var axisInfo = helper.getAxisInfo(axisModel);\n        if (!axisInfo) {\n            return;\n        }\n\n        var axisPointerModel = axisInfo.axisPointerModel;\n        var scale = axisInfo.axis.scale;\n        var option = axisPointerModel.option;\n        var status = axisPointerModel.get('status');\n        var value = axisPointerModel.get('value');\n\n        // Parse init value for category and time axis.\n        if (value != null) {\n            value = scale.parse(value);\n        }\n\n        var useHandle = isHandleTrigger(axisPointerModel);\n        // If `handle` used, `axisPointer` will always be displayed, so value\n        // and status should be initialized.\n        if (status == null) {\n            option.status = useHandle ? 'show' : 'hide';\n        }\n\n        var extent = scale.getExtent().slice();\n        extent[0] > extent[1] && extent.reverse();\n\n        if (// Pick a value on axis when initializing.\n            value == null\n            // If both `handle` and `dataZoom` are used, value may be out of axis extent,\n            // where we should re-pick a value to keep `handle` displaying normally.\n            || value > extent[1]\n        ) {\n            // Make handle displayed on the end of the axis when init, which looks better.\n            value = extent[1];\n        }\n        if (value < extent[0]) {\n            value = extent[0];\n        }\n\n        option.value = value;\n\n        if (useHandle) {\n            option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n        }\n    };\n\n    helper.getAxisInfo = function (axisModel) {\n        var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n        return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n    };\n\n    helper.getAxisPointerModel = function (axisModel) {\n        var axisInfo = helper.getAxisInfo(axisModel);\n        return axisInfo && axisInfo.axisPointerModel;\n    };\n\n    function isHandleTrigger(axisPointerModel) {\n        return !!axisPointerModel.get('handle.show');\n    }\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @return {string} unique key\n     */\n    var makeKey = helper.makeKey = function (model) {\n        return model.type + '||' + model.id;\n    };\n\n    module.exports = helper;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/modelHelper.js\n// module id = 221\n// module chunks = 0 1 2 3 4 5","/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\n\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var Scale = require('./Scale');\n    var helper = require('./helper');\n\n    var roundNumber = numberUtil.round;\n\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n\n        type: 'interval',\n\n        _interval: 0,\n\n        _intervalPrecision: 2,\n\n        setExtent: function (start, end) {\n            var thisExtent = this._extent;\n            //start,end may be a Number like '25',so...\n            if (!isNaN(start)) {\n                thisExtent[0] = parseFloat(start);\n            }\n            if (!isNaN(end)) {\n                thisExtent[1] = parseFloat(end);\n            }\n        },\n\n        unionExtent: function (other) {\n            var extent = this._extent;\n            other[0] < extent[0] && (extent[0] = other[0]);\n            other[1] > extent[1] && (extent[1] = other[1]);\n\n            // unionExtent may called by it's sub classes\n            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n        },\n        /**\n         * Get interval\n         */\n        getInterval: function () {\n            return this._interval;\n        },\n\n        /**\n         * Set interval\n         */\n        setInterval: function (interval) {\n            this._interval = interval;\n            // Dropped auto calculated niceExtent and use user setted extent\n            // We assume user wan't to set both interval, min, max to get a better result\n            this._niceExtent = this._extent.slice();\n\n            this._intervalPrecision = helper.getIntervalPrecision(interval);\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            return helper.intervalScaleGetTicks(\n                this._interval, this._extent, this._niceExtent, this._intervalPrecision\n            );\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getTicksLabels: function () {\n            var labels = [];\n            var ticks = this.getTicks();\n            for (var i = 0; i < ticks.length; i++) {\n                labels.push(this.getLabel(ticks[i]));\n            }\n            return labels;\n        },\n\n        /**\n         * @param {number} data\n         * @param {Object} [opt]\n         * @param {number|string} [opt.precision] If 'auto', use nice presision.\n         * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n         * @return {string}\n         */\n        getLabel: function (data, opt) {\n            if (data == null) {\n                return '';\n            }\n\n            var precision = opt && opt.precision;\n\n            if (precision == null) {\n                precision = numberUtil.getPrecisionSafe(data) || 0;\n            }\n            else if (precision === 'auto') {\n                // Should be more precise then tick.\n                precision = this._intervalPrecision;\n            }\n\n            // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n            // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n            data = roundNumber(data, precision, true);\n\n            return formatUtil.addCommas(data);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         *\n         * @param {number} [splitNumber = 5] Desired number of ticks\n         * @param {number} [minInterval]\n         */\n        niceTicks: function (splitNumber, minInterval) {\n            splitNumber = splitNumber || 5;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (!isFinite(span)) {\n                return;\n            }\n            // User may set axis min 0 and data are all negative\n            // FIXME If it needs to reverse ?\n            if (span < 0) {\n                span = -span;\n                extent.reverse();\n            }\n\n            var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval);\n\n            this._intervalPrecision = result.intervalPrecision;\n            this._interval = result.interval;\n            this._niceExtent = result.niceTickExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {Object} opt\n         * @param {number} [opt.splitNumber = 5] Given approx tick number\n         * @param {boolean} [opt.fixMin=false]\n         * @param {boolean} [opt.fixMax=false]\n         * @param {boolean} [opt.minInterval=false]\n         */\n        niceExtent: function (opt) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                if (extent[0] !== 0) {\n                    // Expand extent\n                    var expandSize = extent[0];\n                    // In the fowllowing case\n                    //      Axis has been fixed max 100\n                    //      Plus data are all 100 and axis extent are [100, 100].\n                    // Extend to the both side will cause expanded max is larger than fixed max.\n                    // So only expand to the smaller side.\n                    if (!opt.fixMax) {\n                        extent[1] += expandSize / 2;\n                        extent[0] -= expandSize / 2;\n                    }\n                    else {\n                        extent[0] -= expandSize / 2;\n                    }\n                }\n                else {\n                    extent[1] = 1;\n                }\n            }\n            var span = extent[1] - extent[0];\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (!isFinite(span)) {\n                extent[0] = 0;\n                extent[1] = 1;\n            }\n\n            this.niceTicks(opt.splitNumber, opt.minInterval);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!opt.fixMin) {\n                extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n            }\n            if (!opt.fixMax) {\n                extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n            }\n        }\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n\n    module.exports = IntervalScale;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Interval.js\n// module id = 222\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = require('../core/util');\n\n    var Style = require('./Style');\n\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable Painter \n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * true\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * zlevelcanvas\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * \n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * \n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         *  x, y \n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         *  x, y \n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * \n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * \n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO,  bind \n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Displayable.js\n// module id = 223\n// module chunks = 0 1 2 3 4 5 6","\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Gradient.js\n// module id = 224\n// module chunks = 0 1 2 3 4 5 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazz = require('./clazz');\n\n    var parseClassType = clazz.parseClassType;\n\n    var base = 0;\n\n    var componentUtil = {};\n\n    var DELIMITER = '_';\n\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [(type || ''), base++, Math.random()].join(DELIMITER);\n    };\n\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n\n        var subTypeDefaulters = {};\n\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n\n        return entity;\n    };\n\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(\n                    currVertex.successor,\n                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n                );\n            }\n\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n\n            zrUtil.each(fullNameList, function (name) {\n\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n\n            return {graph: graph, noEntryList: noEntryList};\n        }\n\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {predecessor: [], successor: []};\n            }\n            return graph[name];\n        }\n\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n\n    module.exports = componentUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/component.js\n// module id = 225\n// module chunks = 0 1 2 3 4 5 6","// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/timsort.js\n// module id = 226\n// module chunks = 0 1 2 3 4 5 6","\n\n    var numberUtil = require('../util/number');\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('./axisHelper');\n\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n\n    var normalizedExtent = [0, 1];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [0, 0];\n\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._labelInterval;\n    };\n\n    Axis.prototype = {\n\n        constructor: Axis,\n\n        /**\n         * If axis extent contain given coord\n         * @param {number} coord\n         * @return {boolean}\n         */\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n\n        /**\n         * If axis extent contain given data\n         * @param {number} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n\n        /**\n         * Get coord extent.\n         * @return {Array.<number>}\n         */\n        getExtent: function () {\n            return this._extent.slice();\n        },\n\n        /**\n         * Get precision used for formatting\n         * @param {Array.<number>} [dataExtent]\n         * @return {number}\n         */\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(\n                dataExtent || this.scale.getExtent(),\n                this._extent\n            );\n        },\n\n        /**\n         * Set coord extent\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n\n        /**\n         * Convert data to coord. Data is the rank if it has a ordinal scale\n         * @param {number} data\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n\n        /**\n         * Convert coord to data. Data is the rank if it has a ordinal scale\n         * @param {number} coord\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\n            return this.scale.scale(t);\n        },\n\n        /**\n         * Convert pixel point to data in axis\n         * @param {Array.<number>} point\n         * @param  {boolean} clamp\n         * @return {number} data\n         */\n        pointToData: function (point, clamp) {\n            // Should be implemented in derived class if necessary.\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            }\n            else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n\n        /**\n         * Coords of labels are on the ticks or on the middle of bands\n         * @return {Array.<number>}\n         */\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n\n        /**\n         * Get bands.\n         *\n         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n         * |---1---|---2---|---3---|---4---|.\n         *\n         * @return {Array}\n         */\n         // FIXME Situation when labels is on ticks\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n\n        /**\n         * Get width of band\n         * @return {number}\n         */\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n            return Math.abs(size) / len;\n        },\n\n        /**\n         * Get interval of the axis label.\n         * @return {number}\n         */\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                var axisModel = this.model;\n                var labelModel = axisModel.getModel('axisLabel');\n                var interval = labelModel.get('interval');\n                if (!(this.type === 'category' && interval === 'auto')) {\n                    labelInterval = interval === 'auto' ? 0 : interval;\n                }\n                else if (this.isHorizontal){\n                    labelInterval = axisHelper.getAxisLabelInterval(\n                        zrUtil.map(this.scale.getTicks(), this.dataToCoord, this),\n                        axisModel.getFormattedLabels(),\n                        labelModel.getModel('textStyle').getFont(),\n                        this.isHorizontal()\n                    );\n                }\n                this._labelInterval = labelInterval;\n            }\n            return labelInterval;\n        }\n\n    };\n\n    module.exports = Axis;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/Axis.js\n// module id = 227\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var List = require('../../data/List');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var CoordinateSystem = require('../../CoordinateSystem');\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null\n            && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        var completeDimOpt = {\n            encodeDef: seriesModel.get('encode'),\n            dimsDef: seriesModel.get('dimensions')\n        };\n\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = (registeredCoordSys && (\n                registeredCoordSys.getDimensionsInfo\n                    ? registeredCoordSys.getDimensionsInfo()\n                    : registeredCoordSys.dimensions.slice()\n            )) || ['x', 'y'];\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n        }\n\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n        var list = new List(dimensions, seriesModel);\n\n        var nameList = createNameList(axesInfo, data);\n\n        var categories = {};\n        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex\n                    ? dataIndex\n                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            }\n            : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName]\n                            || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n\n        return list;\n    }\n\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category'\n            ? 'ordinal'\n            : axisType === 'time'\n            ? 'time'\n            : 'float';\n    }\n\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n\n        cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) {\n\n            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n                return ecModel.queryComponents({\n                    mainType: name,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n            });\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (__DEV__) {\n                if (!xAxisModel) {\n                    throw new Error('xAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('xAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n                if (!yAxisModel) {\n                    throw new Error('yAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('yAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n\n            var xAxisType = xAxisModel.get('type');\n            var yAxisType = yAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'x',\n                    type: getDimTypeByAxis(xAxisType),\n                    stackable: isStackable(xAxisType)\n                },\n                {\n                    name: 'y',\n                    // If two category axes\n                    type: getDimTypeByAxis(yAxisType),\n                    stackable: isStackable(yAxisType)\n                }\n            ];\n\n            var isXAxisCateogry = xAxisType === 'category';\n            var isYAxisCategory = yAxisType === 'category';\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isXAxisCateogry) {\n                categoryAxesModels.x = xAxisModel;\n            }\n            if (isYAxisCategory) {\n                categoryAxesModels.y = yAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        singleAxis: function (data, seriesModel, ecModel, completeDimOpt) {\n\n            var singleAxisModel = ecModel.queryComponents({\n                mainType: 'singleAxis',\n                index: seriesModel.get('singleAxisIndex'),\n                id: seriesModel.get('singleAxisId')\n            })[0];\n\n            if (__DEV__) {\n                if (!singleAxisModel) {\n                    throw new Error('singleAxis should be specified.');\n                }\n            }\n\n            var singleAxisType = singleAxisModel.get('type');\n            var isCategory = singleAxisType === 'category';\n\n            var dimensions = [{\n                name: 'single',\n                type: getDimTypeByAxis(singleAxisType),\n                stackable: isStackable(singleAxisType)\n            }];\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isCategory) {\n                categoryAxesModels.single = singleAxisModel;\n            }\n\n            return {\n                dimensions: dimensions,\n                categoryIndex: isCategory ? 0 : -1,\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        polar: function (data, seriesModel, ecModel, completeDimOpt) {\n            var polarModel = ecModel.queryComponents({\n                mainType: 'polar',\n                index: seriesModel.get('polarIndex'),\n                id: seriesModel.get('polarId')\n            })[0];\n\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n            if (__DEV__) {\n                if (!angleAxisModel) {\n                    throw new Error('angleAxis option not found');\n                }\n                if (!radiusAxisModel) {\n                    throw new Error('radiusAxis option not found');\n                }\n            }\n\n            var radiusAxisType = radiusAxisModel.get('type');\n            var angleAxisType = angleAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'radius',\n                    type: getDimTypeByAxis(radiusAxisType),\n                    stackable: isStackable(radiusAxisType)\n                },\n                {\n                    name: 'angle',\n                    type: getDimTypeByAxis(angleAxisType),\n                    stackable: isStackable(angleAxisType)\n                }\n            ];\n            var isAngleAxisCateogry = angleAxisType === 'category';\n            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isRadiusAxisCateogry) {\n                categoryAxesModels.radius = radiusAxisModel;\n            }\n            if (isAngleAxisCateogry) {\n                categoryAxesModels.angle = angleAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        geo: function (data, seriesModel, ecModel, completeDimOpt) {\n            // TODO Region\n            // \n            return {\n                dimensions: completeDimensions([\n                    {name: 'lng'},\n                    {name: 'lat'}\n                ], data, completeDimOpt)\n            };\n        }\n    };\n\n    function createNameList(result, data) {\n        var nameList = [];\n\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                }\n                else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n\n        return nameList;\n    }\n\n    module.exports = createListFromArray;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/helper/createListFromArray.js\n// module id = 228\n// module chunks = 0 1 2 3 4 5 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n    var Model = require('../../model/Model');\n    var numberUtil = require('../../util/number');\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = require('zrender/lib/core/vector');\n    var matrix = require('zrender/lib/core/matrix');\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n\n    var PI = Math.PI;\n\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = {\n            componentType: axisModel.mainType\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     * @param {number} [opt.nameTruncateMaxWidth]\n     */\n    var AxisBuilder = function (axisModel, opt) {\n\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n\n        // Default value\n        zrUtil.defaults(\n            opt,\n            {\n                labelOffset: 0,\n                nameDirection: 1,\n                tickDirection: 1,\n                labelDirection: 1,\n                silent: true\n            }\n        );\n\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n            position: opt.position.slice(),\n            rotation: opt.rotation\n        });\n\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n\n        this._dumbGroup = dumbGroup;\n    };\n\n    AxisBuilder.prototype = {\n\n        constructor: AxisBuilder,\n\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n\n        add: function (name) {\n            builders[name].call(this);\n        },\n\n        getGroup: function () {\n            return this.group;\n        }\n\n    };\n\n    var builders = {\n\n        /**\n         * @private\n         */\n        axisLine: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisLine.show')) {\n                return;\n            }\n\n            var extent = this.axisModel.axis.getExtent();\n\n            var matrix = this._transform;\n            var pt1 = [extent[0], 0];\n            var pt2 = [extent[1], 0];\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n\n            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                // Id for animation\n                anid: 'line',\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.extend(\n                    {lineCap: 'round'},\n                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n                ),\n                strokeContainThreshold: opt.strokeContainThreshold || 5,\n                silent: true,\n                z2: 1\n            })));\n        },\n\n        /**\n         * @private\n         */\n        axisTick: function () {\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n\n            if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n                return;\n            }\n\n            var tickModel = axisModel.getModel('axisTick');\n            var opt = this.opt;\n\n            var lineStyleModel = tickModel.getModel('lineStyle');\n            var tickLen = tickModel.get('length');\n\n            var tickInterval = getInterval(tickModel, opt.labelInterval);\n            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n            var ticks = axis.scale.getTicks();\n\n            var pt1 = [];\n            var pt2 = [];\n            var matrix = this._transform;\n\n            for (var i = 0; i < ticksCoords.length; i++) {\n                // Only ordinal scale support tick interval\n                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                     continue;\n                }\n\n                var tickCoord = ticksCoords[i];\n\n                pt1[0] = tickCoord;\n                pt1[1] = 0;\n                pt2[0] = tickCoord;\n                pt2[1] = opt.tickDirection * tickLen;\n\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                // Tick line, Not use group transform to have better line draw\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                    // Id for animation\n                    anid: 'tick_' + ticks[i],\n\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.defaults(\n                        lineStyleModel.getLineStyle(),\n                        {\n                            stroke: axisModel.get('axisLine.lineStyle.color')\n                        }\n                    ),\n                    z2: 2,\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @private\n         */\n        axisLabel: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n            if (!show || axis.scale.isBlank()) {\n                return;\n            }\n\n            var labelModel = axisModel.getModel('axisLabel');\n            var textStyleModel = labelModel.getModel('textStyle');\n            var labelMargin = labelModel.get('margin');\n            var ticks = axis.scale.getTicks();\n            var labels = axisModel.getFormattedLabels();\n\n            // Special label rotate.\n            var labelRotation = (\n                retrieve(opt.labelRotate, labelModel.get('rotate')) || 0\n            ) * PI / 180;\n\n            var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n            var categoryData = axisModel.get('data');\n\n            var textEls = [];\n            var silent = isSilent(axisModel);\n            var triggerEvent = axisModel.get('triggerEvent');\n\n            zrUtil.each(ticks, function (tickVal, index) {\n                if (ifIgnoreOnTick(axis, index, opt.labelInterval)) {\n                     return;\n                }\n\n                var itemTextStyleModel = textStyleModel;\n                if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n                    itemTextStyleModel = new Model(\n                        categoryData[tickVal].textStyle, textStyleModel, axisModel.ecModel\n                    );\n                }\n                var textColor = itemTextStyleModel.getTextColor()\n                    || axisModel.get('axisLine.lineStyle.color');\n\n                var tickCoord = axis.dataToCoord(tickVal);\n                var pos = [\n                    tickCoord,\n                    opt.labelOffset + opt.labelDirection * labelMargin\n                ];\n                var labelStr = axis.scale.getLabel(tickVal);\n\n                var textEl = new graphic.Text({\n\n                    // Id for animation\n                    anid: 'label_' + tickVal,\n\n                    style: {\n                        text: labels[index],\n                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.textVerticalAlign,\n                        textFont: itemTextStyleModel.getFont(),\n                        fill: typeof textColor === 'function'\n                            ? textColor(\n                                // (1) In category axis with data zoom, tick is not the original\n                                // index of axis.data. So tick should not be exposed to user\n                                // in category axis.\n                                // (2) Compatible with previous version, which always returns labelStr.\n                                // But in interval scale labelStr is like '223,445', which maked\n                                // user repalce ','. So we modify it to return original val but remain\n                                // it as 'string' to avoid error in replacing.\n                                axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal,\n                                index\n                            )\n                            : textColor\n                    },\n                    position: pos,\n                    rotation: labelLayout.rotation,\n                    silent: silent,\n                    z2: 10\n                });\n\n                // Pack data for mouse event\n                if (triggerEvent) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisLabel';\n                    textEl.eventData.value = labelStr;\n                }\n\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n\n                textEls.push(textEl);\n                this.group.add(textEl);\n\n                textEl.decomposeTransform();\n\n            }, this);\n\n            fixMinMaxLabelShow(axisModel, textEls);\n        },\n\n        /**\n         * @private\n         */\n        axisName: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var name = retrieve(opt.axisName, axisModel.get('name'));\n\n            if (!name) {\n                return;\n            }\n\n            var nameLocation = axisModel.get('nameLocation');\n            var nameDirection = opt.nameDirection;\n            var textStyleModel = axisModel.getModel('nameTextStyle');\n            var gap = axisModel.get('nameGap') || 0;\n\n            var extent = this.axisModel.axis.getExtent();\n            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n            var pos = [\n                nameLocation === 'start'\n                    ? extent[0] - gapSignal * gap\n                    : nameLocation === 'end'\n                    ? extent[1] + gapSignal * gap\n                    : (extent[0] + extent[1]) / 2, // 'middle'\n                // Reuse labelOffset.\n                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n            ];\n\n            var labelLayout;\n\n            var nameRotation = axisModel.get('nameRotate');\n            if (nameRotation != null) {\n                nameRotation = nameRotation * PI / 180; // To radian.\n            }\n\n            var axisNameAvailableWidth;\n\n            if (nameLocation === 'middle') {\n                labelLayout = innerTextLayout(\n                    opt.rotation,\n                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                    nameDirection\n                );\n            }\n            else {\n                labelLayout = endTextLayout(\n                    opt, nameLocation, nameRotation || 0, extent\n                );\n\n                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                if (axisNameAvailableWidth != null) {\n                    axisNameAvailableWidth = Math.abs(\n                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                    );\n                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                }\n            }\n\n            var textFont = textStyleModel.getFont();\n\n            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n            var ellipsis = truncateOpt.ellipsis;\n            var maxWidth = retrieve(\n                opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth\n            );\n            var truncatedText = (ellipsis != null && maxWidth != null)\n                ? formatUtil.truncateText(\n                    name, maxWidth, textFont, ellipsis,\n                    {minChar: 2, placeholder: truncateOpt.placeholder}\n                )\n                : name;\n\n            var tooltipOpt = axisModel.get('tooltip', true);\n\n            var mainType = axisModel.mainType;\n            var formatterParams = {\n                componentType: mainType,\n                name: name,\n                $vars: ['name']\n            };\n            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n            var textEl = new graphic.Text({\n\n                // Id for animation\n                anid: 'name',\n\n                __fullText: name,\n                __truncatedText: truncatedText,\n\n                style: {\n                    text: truncatedText,\n                    textFont: textFont,\n                    fill: textStyleModel.getTextColor()\n                        || axisModel.get('axisLine.lineStyle.color'),\n                    textAlign: labelLayout.textAlign,\n                    textVerticalAlign: labelLayout.textVerticalAlign\n                },\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: isSilent(axisModel),\n                z2: 1,\n                tooltip: (tooltipOpt && tooltipOpt.show)\n                    ? zrUtil.extend({\n                        content: name,\n                        formatter: function () {\n                            return name;\n                        },\n                        formatterParams: formatterParams\n                    }, tooltipOpt)\n                    : null\n            });\n\n            if (axisModel.get('triggerEvent')) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisName';\n                textEl.eventData.name = name;\n            }\n\n            // FIXME\n            this._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            this.group.add(textEl);\n\n            textEl.decomposeTransform();\n        }\n\n    };\n\n    /**\n     * @public\n     * @static\n     * @param {Object} opt\n     * @param {number} axisRotation in radian\n     * @param {number} textRotation in radian\n     * @param {number} direction\n     * @return {Object} {\n     *  rotation, // according to axis\n     *  textAlign,\n     *  textVerticalAlign\n     * }\n     */\n    var innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - axisRotation);\n        var textAlign;\n        var textVerticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            }\n            else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    };\n\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var textVerticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = (textPosition === 'start' && !inverse)\n            || (textPosition !== 'start' && inverse);\n\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            textVerticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            textVerticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            }\n            else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    }\n\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent')\n            // Consider mouse cursor, add these restrictions.\n            || !(\n                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n            );\n    }\n\n    function fixMinMaxLabelShow(axisModel, textEls) {\n        // If min or max are user set, we need to check\n        // If the tick on min(max) are overlap on their neighbour tick\n        // If they are overlapped, we need to hide the min(max) tick label\n        var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n        var firstLabel = textEls[0];\n        var nextLabel = textEls[1];\n        var lastLabel = textEls[textEls.length - 1];\n        var prevLabel = textEls[textEls.length - 2];\n\n        if (showMinLabel === false) {\n            firstLabel.ignore = true;\n        }\n        else if (axisModel.getMin() != null && isTwoLabelOverlapped(firstLabel, nextLabel)) {\n            showMinLabel ? (nextLabel.ignore = true) : (firstLabel.ignore = true);\n        }\n\n        if (showMaxLabel === false) {\n            lastLabel.ignore = true;\n        }\n        else if (axisModel.getMax() != null && isTwoLabelOverlapped(prevLabel, lastLabel)) {\n            showMaxLabel ? (prevLabel.ignore = true) : (lastLabel.ignore = true);\n        }\n    }\n\n    function isTwoLabelOverlapped(current, next, labelLayout) {\n        // current and next has the same rotation.\n        var firstRect = current && current.getBoundingRect().clone();\n        var nextRect = next && next.getBoundingRect().clone();\n\n        if (!firstRect || !nextRect) {\n            return;\n        }\n\n        // When checking intersect of two rotated labels, we use mRotationBack\n        // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n        var mRotationBack = matrix.identity([]);\n        matrix.rotate(mRotationBack, mRotationBack, -current.rotation);\n\n        firstRect.applyTransform(matrix.mul([], mRotationBack, current.getLocalTransform()));\n        nextRect.applyTransform(matrix.mul([], mRotationBack, next.getLocalTransform()));\n\n        return firstRect.intersect(nextRect);\n    }\n\n\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n        var rawTick;\n        var scale = axis.scale;\n        return scale.type === 'ordinal'\n            && (\n                typeof interval === 'function'\n                    ? (\n                        rawTick = scale.getTicks()[i],\n                        !interval(rawTick, scale.getLabel(rawTick))\n                    )\n                    : i % (interval + 1)\n            );\n    };\n\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n        var interval = model.get('interval');\n        if (interval == null || interval == 'auto') {\n            interval = labelInterval;\n        }\n        return interval;\n    };\n\n    module.exports = AxisBuilder;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/AxisBuilder.js\n// module id = 229\n// module chunks = 0 1 2 3 4 5 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('./axisHelper');\n\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        }\n        else {\n            return obj + '';\n        }\n    }\n\n    module.exports = {\n\n        /**\n         * Format labels\n         * @return {Array.<string>}\n         */\n        getFormattedLabels: function () {\n            return axisHelper.getFormattedLabels(\n                this.axis,\n                this.get('axisLabel.formatter')\n            );\n        },\n\n        /**\n         * Get categories\n         */\n        getCategories: function () {\n            return this.get('type') === 'category'\n                && zrUtil.map(this.get('data'), getName);\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n         */\n        getMin: function (origin) {\n            var option = this.option;\n            var min = (!origin && option.rangeStart != null)\n                ? option.rangeStart : option.min;\n\n            if (this.axis && min != null && min !== 'dataMin' && !zrUtil.eqNaN(min)) {\n                min = this.axis.scale.parse(min);\n            }\n            return min;\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n         */\n        getMax: function (origin) {\n            var option = this.option;\n            var max = (!origin && option.rangeEnd != null)\n                ? option.rangeEnd : option.max;\n\n            if (this.axis && max != null && max !== 'dataMax' && !zrUtil.eqNaN(max)) {\n                max = this.axis.scale.parse(max);\n            }\n            return max;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        getNeedCrossZero: function () {\n            var option = this.option;\n            return (option.rangeStart != null || option.rangeEnd != null)\n                ? false : !option.scale;\n        },\n\n        /**\n         * Should be implemented by each axis model if necessary.\n         * @return {module:echarts/model/Component} coordinate system model\n         */\n        getCoordSysModel: zrUtil.noop,\n\n        /**\n         * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n         * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n         */\n        setRange: function (rangeStart, rangeEnd) {\n            this.option.rangeStart = rangeStart;\n            this.option.rangeEnd = rangeEnd;\n        },\n\n        /**\n         * Reset range\n         */\n        resetRange: function () {\n            // rangeStart and rangeEnd is readonly.\n            this.option.rangeStart = this.option.rangeEnd = null;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisModelCommonMixin.js\n// module id = 230\n// module chunks = 0 1 2 3 4 5 6","\n\n    var lib = {};\n\n    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n    var RATE = '\\0__throttleRate';\n    var THROTTLE_TYPE = '\\0__throttleType';\n\n    /**\n     * @public\n     * @param {(Function)} fn\n     * @param {number} [delay=0] Unit: ms.\n     * @param {boolean} [debounce=false]\n     *        true: If call interval less than `delay`, only the last call works.\n     *        false: If call interval less than `delay, call works on fixed rate.\n     * @return {(Function)} throttled fn.\n     */\n    lib.throttle = function (fn, delay, debounce) {\n\n        var currCall;\n        var lastCall = 0;\n        var lastExec = 0;\n        var timer = null;\n        var diff;\n        var scope;\n        var args;\n        var debounceNextCall;\n\n        delay = delay || 0;\n\n        function exec() {\n            lastExec = (new Date()).getTime();\n            timer = null;\n            fn.apply(scope, args || []);\n        }\n\n        var cb = function () {\n            currCall = (new Date()).getTime();\n            scope = this;\n            args = arguments;\n            var thisDelay = debounceNextCall || delay;\n            var thisDebounce = debounceNextCall || debounce;\n            debounceNextCall = null;\n            diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;\n\n            clearTimeout(timer);\n\n            if (thisDebounce) {\n                timer = setTimeout(exec, thisDelay);\n            }\n            else {\n                if (diff >= 0) {\n                    exec();\n                }\n                else {\n                    timer = setTimeout(exec, -diff);\n                }\n            }\n\n            lastCall = currCall;\n        };\n\n        /**\n         * Clear throttle.\n         * @public\n         */\n        cb.clear = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n\n        /**\n         * Enable debounce once.\n         */\n        cb.debounceNextCall = function (debounceDelay) {\n            debounceNextCall = debounceDelay;\n        };\n\n        return cb;\n    };\n\n    /**\n     * Create throttle method or update throttle rate.\n     *\n     * @example\n     * ComponentView.prototype.render = function () {\n     *     ...\n     *     throttle.createOrUpdate(\n     *         this,\n     *         '_dispatchAction',\n     *         this.model.get('throttle'),\n     *         'fixRate'\n     *     );\n     * };\n     * ComponentView.prototype.remove = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     * ComponentView.prototype.dispose = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     * @param {number} [rate]\n     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n     * @return {Function} throttled function.\n     */\n    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n        var fn = obj[fnAttr];\n\n        if (!fn) {\n            return;\n        }\n\n        var originFn = fn[ORIGIN_METHOD] || fn;\n        var lastThrottleType = fn[THROTTLE_TYPE];\n        var lastRate = fn[RATE];\n\n        if (lastRate !== rate || lastThrottleType !== throttleType) {\n            if (rate == null || !throttleType) {\n                return (obj[fnAttr] = originFn);\n            }\n\n            fn = obj[fnAttr] = lib.throttle(\n                originFn, rate, throttleType === 'debounce'\n            );\n            fn[ORIGIN_METHOD] = originFn;\n            fn[THROTTLE_TYPE] = throttleType;\n            fn[RATE] = rate;\n        }\n\n        return fn;\n    };\n\n    /**\n     * Clear throttle. Example see throttle.createOrUpdate.\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     */\n    lib.clear = function (obj, fnAttr) {\n        var fn = obj[fnAttr];\n        if (fn && fn[ORIGIN_METHOD]) {\n            obj[fnAttr] = fn[ORIGIN_METHOD];\n        }\n    };\n\n    module.exports = lib;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/throttle.js\n// module id = 231\n// module chunks = 0 1 2 3 4 5 6","\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var modelUtil = require('../util/model');\n    var zrUtil = require('zrender/lib/core/util');\n\n    function Chart() {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n\n    Chart.prototype = {\n\n        type: 'chart',\n\n        /**\n         * Init the chart\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        init: function (ecModel, api) {},\n\n        /**\n         * Render the chart\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        render: function (seriesModel, ecModel, api, payload) {},\n\n        /**\n         * Highlight series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n\n        /**\n         * Downplay series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n\n        /**\n         * Remove self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n\n        /**\n         * Dispose self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        dispose: function () {}\n\n        /**\n         * The view contains the given point.\n         * @interface\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        // containPoint: function () {}\n\n    };\n\n    var chartProto = Chart.prototype;\n    chartProto.updateView\n        = chartProto.updateLayout\n        = chartProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            this.render(seriesModel, ecModel, api, payload);\n        };\n\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n        if (dataIndex != null) {\n            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n                elSetState(data.getItemGraphicEl(dataIdx), state);\n            });\n        }\n        else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\n    module.exports = Chart;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/view/Chart.js\n// module id = 232\n// module chunks = 0 1 2 3 4 5 6","\n\n    var axisPointerModelHelper = require('../axisPointer/modelHelper');\n\n    /**\n     * Base class of AxisView.\n     */\n    var AxisView = require('../../echarts').extendComponentView({\n\n        type: 'axis',\n\n        /**\n         * @private\n         */\n        _axisPointer: null,\n\n        /**\n         * @protected\n         * @type {string}\n         */\n        axisPointerClass: null,\n\n        /**\n         * @override\n         */\n        render: function (axisModel, ecModel, api, payload) {\n            // FIXME\n            // This process should proformed after coordinate systems updated\n            // (axis scale updated), and should be performed each time update.\n            // So put it here temporarily, although it is not appropriate to\n            // put a model-writing procedure in `view`.\n            this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);\n\n            AxisView.superApply(this, 'render', arguments);\n\n            updateAxisPointer(this, axisModel, ecModel, api, payload, true);\n        },\n\n        /**\n         * Action handler.\n         * @public\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/model/Global} ecModel\n         * @param {module:echarts/ExtensionAPI} api\n         * @param {Object} payload\n         */\n        updateAxisPointer: function (axisModel, ecModel, api, payload, force) {\n            updateAxisPointer(this, axisModel, ecModel, api, payload, false);\n        },\n\n        /**\n         * @override\n         */\n        remove: function (ecModel, api) {\n            var axisPointer = this._axisPointer;\n            axisPointer && axisPointer.remove(api);\n            AxisView.superApply(this, 'remove', arguments);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function (ecModel, api) {\n            disposeAxisPointer(this, api);\n            AxisView.superApply(this, 'dispose', arguments);\n        }\n\n    });\n\n    function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {\n        var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);\n        if (!Clazz) {\n            return;\n        }\n        var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);\n        axisPointerModel\n            ? (axisView._axisPointer || (axisView._axisPointer = new Clazz()))\n                .render(axisModel, axisPointerModel, api, forceRender)\n            : disposeAxisPointer(axisView, api);\n    }\n\n    function disposeAxisPointer(axisView, ecModel, api) {\n        var axisPointer = axisView._axisPointer;\n        axisPointer && axisPointer.dispose(ecModel, api);\n        axisView._axisPointer = null;\n    }\n\n    var axisPointerClazz = [];\n\n    AxisView.registerAxisPointerClass = function (type, clazz) {\n        if (__DEV__) {\n            if (axisPointerClazz[type]) {\n                throw new Error('axisPointer ' + type + ' exists');\n            }\n        }\n        axisPointerClazz[type] = clazz;\n    };\n\n    AxisView.getAxisPointerClass = function (type) {\n        return type && axisPointerClazz[type];\n    };\n\n    module.exports = AxisView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/AxisView.js\n// module id = 233\n// module chunks = 0 1 2 3 4 5","\n        var config = require('../config');\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/log.js\n// module id = 234\n// module chunks = 0 1 2 3 4 5 6","/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // \n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // \n                if (!image.width || !image.height) {\n                    return;\n                }\n                var width = style.width;\n                var height = style.height;\n                var aspect = image.width / image.height;\n                if (width == null && height != null) {\n                    // Keep image/height ratio\n                    width = height * aspect;\n                }\n                else if (height == null && width != null) {\n                    height = width / aspect;\n                }\n                else if (width == null && height == null) {\n                    width = image.width;\n                    height = image.height;\n                }\n\n                // transform\n                this.setTransform(ctx);\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Image.js\n// module id = 235\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * \n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * \n     * , position, rotation, scaletransformtransform\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // \n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // \n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        return Transformable.getLocalTransform(this, m);\n    };\n\n    /**\n     * transformcontext\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    };\n\n    var tmpTransform = [];\n\n    /**\n     * `transform``position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     *  shape \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    /**\n     * @static\n     * @param {Object} target\n     * @param {Array.<number>} target.origin\n     * @param {number} target.rotation\n     * @param {Array.<number>} target.position\n     * @param {Array.<number>} [m]\n     */\n    Transformable.getLocalTransform = function (target, m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = target.origin;\n        var scale = target.scale || [1, 1];\n        var rotation = target.rotation || 0;\n        var position = target.position || [0, 0];\n\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n\n    module.exports = Transformable;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Transformable.js\n// module id = 236\n// module chunks = 0 1 2 3 4 5 6","\n\n    var classUtil = require('../../util/clazz');\n    var set = classUtil.set;\n    var get = classUtil.get;\n\n    module.exports = {\n        clearColorPalette: function () {\n            set(this, 'colorIdx', 0);\n            set(this, 'colorNameMap', {});\n        },\n\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = get(scope, 'colorIdx') || 0;\n            var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {});\n            // Use `hasOwnProperty` to avoid conflict with Object.prototype.\n            if (colorNameMap.hasOwnProperty(name)) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n\n            return color;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/colorPalette.js\n// module id = 237\n// module chunks = 0 1 2 3 4 5 6","/**\n * For testable.\n */\n\n\n    var numberUtil = require('../util/number');\n\n    var roundNumber = numberUtil.round;\n\n    var helper = {};\n\n    /**\n     * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n     *                                Should be extent[0] < extent[1].\n     * @param {number} splitNumber splitNumber should be >= 1.\n     * @param {number} [minInterval]\n     * @return {Object} {interval, intervalPrecision, niceTickExtent}\n     */\n    helper.intervalScaleNiceTicks = function (extent, splitNumber, minInterval) {\n        var result = {};\n        var span = extent[1] - extent[0];\n\n        var interval = result.interval = numberUtil.nice(span / splitNumber, true);\n        if (minInterval != null && interval < minInterval) {\n            interval = result.interval = minInterval;\n        }\n        // Tow more digital for tick.\n        var precision = result.intervalPrecision = helper.getIntervalPrecision(interval);\n        // Niced extent inside original extent\n        var niceTickExtent = result.niceTickExtent = [\n            roundNumber(Math.ceil(extent[0] / interval) * interval, precision),\n            roundNumber(Math.floor(extent[1] / interval) * interval, precision)\n        ];\n\n        helper.fixExtent(niceTickExtent, extent);\n\n        return result;\n    };\n\n    /**\n     * @param {number} interval\n     * @return {number} interval precision\n     */\n    helper.getIntervalPrecision = function (interval) {\n        // Tow more digital for tick.\n        return numberUtil.getPrecisionSafe(interval) + 2;\n    };\n\n    function clamp(niceTickExtent, idx, extent) {\n        niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n    }\n\n    // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\n    helper.fixExtent = function (niceTickExtent, extent) {\n        !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n        !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n        clamp(niceTickExtent, 0, extent);\n        clamp(niceTickExtent, 1, extent);\n        if (niceTickExtent[0] > niceTickExtent[1]) {\n            niceTickExtent[0] = niceTickExtent[1];\n        }\n    };\n\n    helper.intervalScaleGetTicks = function (interval, extent, niceTickExtent, intervalPrecision) {\n        var ticks = [];\n\n        // If interval is 0, return [];\n        if (!interval) {\n            return ticks;\n        }\n\n        // Consider this case: using dataZoom toolbox, zoom and zoom.\n        var safeLimit = 10000;\n\n        if (extent[0] < niceTickExtent[0]) {\n            ticks.push(extent[0]);\n        }\n        var tick = niceTickExtent[0];\n\n        while (tick <= niceTickExtent[1]) {\n            ticks.push(tick);\n            // Avoid rounding error\n            tick = roundNumber(tick + interval, intervalPrecision);\n            if (tick === ticks[ticks.length - 1]) {\n                // Consider out of safe float point, e.g.,\n                // -3711126.9907707 + 2e-10 === -3711126.9907707\n                break;\n            }\n            if (ticks.length > safeLimit) {\n                return [];\n            }\n        }\n        // Consider this case: the last item of ticks is smaller\n        // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n        if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {\n            ticks.push(extent[1]);\n        }\n\n        return ticks;\n    };\n\n    module.exports = helper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/helper.js\n// module id = 238\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * \n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * \n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender  element  zrender \n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * true\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * (shape) Group \n         * \n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Element.js\n// module id = 239\n// module chunks = 0 1 2 3 4 5 6","/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = len && p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function getArrayDim(keyframes) {\n        var lastValue = keyframes[keyframes.length - 1].value;\n        return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * \n         * @param  {number} time ms\n         * @param  {Object} props key-value\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        pause: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].pause();\n            }\n            this._paused = true;\n        },\n\n        resume: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].resume();\n            }\n            this._paused = false;\n        },\n\n        isPaused: function () {\n            return !!this._paused;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * \n         * @param  {string|Function} easing\n         *         {@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * \n         * @param  {number} time ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animator.js\n// module id = 240\n// module chunks = 0 1 2 3 4 5 6","\n\n    module.exports = (typeof window !== 'undefined' &&\n                ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window))\n                // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\n                || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))\n                || window.mozRequestAnimationFrame\n                || window.webkitRequestAnimationFrame)\n            )\n            || function (func) {\n                setTimeout(func, 16);\n            };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/requestAnimationFrame.js\n// module id = 241\n// module chunks = 0 1 2 3 4 5 6","\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/util.js\n// module id = 242\n// module chunks = 0 1 2 3 4 5 6","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function () {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function (val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function (entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            entry.next = null;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function (entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function () {\n        return this._len;\n    };\n\n    /**\n     * Clear list\n     */\n    linkedListProto.clear = function () {\n        this.head = this.tail = null;\n        this._len = 0;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function (val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function (maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n\n        this._lastRemovedEntry = null;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     * @return {} Removed value\n     */\n    LRUProto.put = function (key, value) {\n        var list = this._list;\n        var map = this._map;\n        var removed = null;\n        if (map[key] == null) {\n            var len = list.len();\n            // Reuse last removed entry\n            var entry = this._lastRemovedEntry;\n\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n\n                removed = leastUsedEntry.value;\n                this._lastRemovedEntry = leastUsedEntry;\n            }\n\n            if (entry) {\n                entry.value = value;\n            }\n            else {\n                entry = new Entry(value);\n            }\n            entry.key = key;\n            list.insertEntry(entry);\n            map[key] = entry;\n        }\n\n        return removed;\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function (key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function () {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/LRU.js\n// module id = 243\n// module chunks = 0 1 2 3 4 5 6","/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/guid.js\n// module id = 244\n// module chunks = 0 1 2 3 4 5 6","\n\n    var Pattern = function (image, repeat) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {image: ...}`, where this constructor will not be called.\n\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n        return ctx.createPattern(this.image, this.repeat || 'repeat');\n    };\n\n    module.exports = Pattern;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Pattern.js\n// module id = 245\n// module chunks = 0 1 2 3 4 5 6","/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        var x = obj.x == null ? 0 : obj.x;\n        var x2 = obj.x2 == null ? 1 : obj.x2;\n        var y = obj.y == null ? 0 : obj.y;\n        var y2 = obj.y2 == null ? 0 : obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x == null ? 0.5 : obj.x;\n        var y = obj.y == null ? 0.5 : obj.y;\n        var r = obj.r == null ? 0.5 : obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * If not specified, use the boundingRect of a `displayable`.\n         * @type {Object}\n         */\n        textPositionRect: null,\n\n        /**\n         * [x, y]\n         * @type {Array.<number>}\n         */\n        textOffset: null,\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Style.js\n// module id = 246\n// module chunks = 0 1 2 3 4 5 6","\n\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/poly.js\n// module id = 247\n// module chunks = 0 1 2 3 4 5 6","\n\n    var echarts = require('../echarts');\n    var axisPointerModelHelper = require('./axisPointer/modelHelper');\n    var axisTrigger = require('./axisPointer/axisTrigger');\n    var zrUtil = require('zrender/lib/core/util');\n\n    require('./axisPointer/AxisPointerModel');\n    require('./axisPointer/AxisPointerView');\n\n    // CartesianAxisPointer is not supposed to be required here. But consider\n    // echarts.simple.js and online build tooltip, which only require gridSimple,\n    // CartesianAxisPointer should be able to required somewhere.\n    require('./axisPointer/CartesianAxisPointer');\n\n    echarts.registerPreprocessor(function (option) {\n        // Always has a global axisPointerModel for default setting.\n        if (option) {\n            (!option.axisPointer || option.axisPointer.length === 0)\n                && (option.axisPointer = {});\n\n            var link = option.axisPointer.link;\n            // Normalize to array to avoid object mergin. But if link\n            // is not set, remain null/undefined, otherwise it will\n            // override existent link setting.\n            if (link && !zrUtil.isArray(link)) {\n                option.axisPointer.link = [link];\n            }\n        }\n    });\n\n    // This process should proformed after coordinate systems created\n    // and series data processed. So put it on statistic processing stage.\n    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n        // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n        // allAxesInfo should be updated when setOption performed.\n        ecModel.getComponent('axisPointer').coordSysAxesInfo\n            = axisPointerModelHelper.collect(ecModel, api);\n    });\n\n    // Broadcast to all views.\n    echarts.registerAction({\n        type: 'updateAxisPointer',\n        event: 'updateAxisPointer',\n        update: ':updateAxisPointer'\n    }, axisTrigger);\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer.js\n// module id = 248\n// module chunks = 0 1 2 3 4 5","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var textContain = require('zrender/lib/contain/text');\n    var formatUtil = require('../../util/format');\n    var matrix = require('zrender/lib/core/matrix');\n    var axisHelper = require('../../coord/axisHelper');\n    var AxisBuilder = require('../axis/AxisBuilder');\n\n    var helper = {};\n\n    /**\n     * @param {module:echarts/model/Model} axisPointerModel\n     */\n    helper.buildElStyle = function (axisPointerModel) {\n        var axisPointerType = axisPointerModel.get('type');\n        var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n        var style;\n        if (axisPointerType === 'line') {\n            style = styleModel.getLineStyle();\n            style.fill = null;\n        }\n        else if (axisPointerType === 'shadow') {\n            style = styleModel.getAreaStyle();\n            style.stroke = null;\n        }\n        return style;\n    };\n\n    /**\n     * @param {Function} labelPos {align, verticalAlign, position}\n     */\n    helper.buildLabelElOption = function (\n        elOption, axisModel, axisPointerModel, api, labelPos\n    ) {\n        var value = axisPointerModel.get('value');\n        var text = helper.getValueLabel(\n            value, axisModel.axis, axisModel.ecModel,\n            axisPointerModel.get('seriesDataIndices'),\n            {\n                precision: axisPointerModel.get('label.precision'),\n                formatter: axisPointerModel.get('label.formatter')\n            }\n        );\n        var labelModel = axisPointerModel.getModel('label');\n        var textStyleModel = labelModel.getModel('textStyle');\n        var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n\n        var font = textStyleModel.getFont();\n        var textRect = textContain.getBoundingRect(\n            text, font, labelPos.textAlign, labelPos.textBaseline\n        );\n\n        var position = labelPos.position;\n        var width = textRect.width + paddings[1] + paddings[3];\n        var height = textRect.height + paddings[0] + paddings[2];\n\n        // Adjust by align.\n        var align = labelPos.align;\n        align === 'right' && (position[0] -= width);\n        align === 'center' && (position[0] -= width / 2);\n        var verticalAlign = labelPos.verticalAlign;\n        verticalAlign === 'bottom' && (position[1] -= height);\n        verticalAlign === 'middle' && (position[1] -= height / 2);\n\n        // Not overflow ec container\n        confineInContainer(position, width, height, api);\n\n        var bgColor = labelModel.get('backgroundColor');\n        if (!bgColor || bgColor === 'auto') {\n            bgColor = axisModel.get('axisLine.lineStyle.color');\n        }\n\n        elOption.label = {\n            shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},\n            position: position.slice(),\n            style: {\n                text: text,\n                textFont: font,\n                textFill: textStyleModel.getTextColor(),\n                textPosition: 'inside',\n                fill: bgColor,\n                stroke: labelModel.get('borderColor') || 'transparent',\n                lineWidth: labelModel.get('borderWidth') || 0,\n                shadowBlur: labelModel.get('shadowBlur'),\n                shadowColor: labelModel.get('shadowColor'),\n                shadowOffsetX: labelModel.get('shadowOffsetX'),\n                shadowOffsetY: labelModel.get('shadowOffsetY')\n            },\n            // Lable should be over axisPointer.\n            z2: 10\n        };\n    };\n\n    // Do not overflow ec container\n    function confineInContainer(position, width, height, api) {\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n        position[0] = Math.min(position[0] + width, viewWidth) - width;\n        position[1] = Math.min(position[1] + height, viewHeight) - height;\n        position[0] = Math.max(position[0], 0);\n        position[1] = Math.max(position[1], 0);\n    }\n\n    /**\n     * @param {number} value\n     * @param {module:echarts/coord/Axis} axis\n     * @param {module:echarts/model/Global} ecModel\n     * @param {Object} opt\n     * @param {Array.<Object>} seriesDataIndices\n     * @param {number|string} opt.precision 'auto' or a number\n     * @param {string|Function} opt.formatter label formatter\n     */\n    helper.getValueLabel = function (value, axis, ecModel, seriesDataIndices, opt) {\n        var text = axis.scale.getLabel(\n            // If `precision` is set, width can be fixed (like '12.00500'), which\n            // helps to debounce when when moving label.\n            value, {precision: opt.precision}\n        );\n        var formatter = opt.formatter;\n\n        if (formatter) {\n            var params = {\n                value: axisHelper.getAxisRawValue(axis, value),\n                seriesData: []\n            };\n            zrUtil.each(seriesDataIndices, function (idxItem) {\n                var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n                var dataIndex = idxItem.dataIndexInside;\n                var dataParams = series && series.getDataParams(dataIndex);\n                dataParams && params.seriesData.push(dataParams);\n            });\n\n            if (zrUtil.isString(formatter)) {\n                text = formatter.replace('{value}', text);\n            }\n            else if (zrUtil.isFunction(formatter)) {\n                text = formatter(params);\n            }\n        }\n\n        return text;\n    };\n\n    /**\n     * @param {module:echarts/coord/Axis} axis\n     * @param {number} value\n     * @param {Object} layoutInfo {\n     *  rotation, position, labelOffset, labelDirection, labelMargin\n     * }\n     */\n    helper.getTransformedPosition = function (axis, value, layoutInfo) {\n        var transform = matrix.create();\n        matrix.rotate(transform, transform, layoutInfo.rotation);\n        matrix.translate(transform, transform, layoutInfo.position);\n\n        return graphic.applyTransform([\n            axis.dataToCoord(value),\n            (layoutInfo.labelOffset || 0)\n                + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)\n        ], transform);\n    };\n\n    helper.buildCartesianSingleLabelElOption = function (\n        value, elOption, layoutInfo, axisModel, axisPointerModel, api\n    ) {\n        var textLayout = AxisBuilder.innerTextLayout(\n            layoutInfo.rotation, 0, layoutInfo.labelDirection\n        );\n        layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n        helper.buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n            position: helper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n            align: textLayout.textAlign,\n            verticalAlign: textLayout.textVerticalAlign\n        });\n    };\n\n    /**\n     * @param {Array.<number>} p1\n     * @param {Array.<number>} p2\n     * @param {number} [xDimIndex=0] or 1\n     */\n    helper.makeLineShape = function (p1, p2, xDimIndex) {\n        xDimIndex = xDimIndex || 0;\n        return {\n            x1: p1[xDimIndex],\n            y1: p1[1 - xDimIndex],\n            x2: p2[xDimIndex],\n            y2: p2[1 - xDimIndex]\n        };\n    };\n\n    /**\n     * @param {Array.<number>} xy\n     * @param {Array.<number>} wh\n     * @param {number} [xDimIndex=0] or 1\n     */\n    helper.makeRectShape = function (xy, wh, xDimIndex) {\n        xDimIndex = xDimIndex || 0;\n        return {\n            x: xy[xDimIndex],\n            y: xy[1 - xDimIndex],\n            width: wh[xDimIndex],\n            height: wh[1 - xDimIndex]\n        };\n    };\n\n    helper.makeSectorShape = function (cx, cy, r0, r, startAngle, endAngle) {\n        return {\n            cx: cx,\n            cy: cy,\n            r0: r0,\n            r: r,\n            startAngle: startAngle,\n            endAngle: endAngle,\n            clockwise: true\n        };\n    };\n\n    module.exports = helper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/viewHelper.js\n// module id = 249\n// module chunks = 0 1 2 3 4 5","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n\n    /**\n     * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}\n     * @param {module:echarts/model/Global} ecModel\n     * @return {Object} {point: [x, y], el: ...} point Will not be null.\n     */\n    module.exports = function (finder, ecModel) {\n        var point = [];\n        var seriesIndex = finder.seriesIndex;\n        var seriesModel;\n        if (seriesIndex == null || !(\n            seriesModel = ecModel.getSeriesByIndex(seriesIndex)\n        )) {\n            return {point: []};\n        }\n\n        var data = seriesModel.getData();\n        var dataIndex = modelUtil.queryDataIndex(data, finder);\n        if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n            return {point: []};\n        }\n\n        var el = data.getItemGraphicEl(dataIndex);\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (seriesModel.getTooltipPosition) {\n            point = seriesModel.getTooltipPosition(dataIndex) || [];\n        }\n        else if (coordSys && coordSys.dataToPoint) {\n            point = coordSys.dataToPoint(\n                data.getValues(\n                    zrUtil.map(coordSys.dimensions, function (dim) {\n                        return seriesModel.coordDimToDataDim(dim)[0];\n                    }), dataIndex, true\n                )\n            ) || [];\n        }\n        else if (el) {\n            // Use graphic bounding rect\n            var rect = el.getBoundingRect().clone();\n            rect.applyTransform(el.transform);\n            point = [\n                rect.x + rect.width / 2,\n                rect.y + rect.height / 2\n            ];\n        }\n\n        return {point: point, el: el};\n    };\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/findPointFromSeries.js\n// module id = 250\n// module chunks = 0 1 2 3 4 5","\n\n    var env = require('zrender/lib/core/env');\n    var zrUtil = require('zrender/lib/core/util');\n    var get = require('../../util/model').makeGetter();\n\n    var each = zrUtil.each;\n\n    var globalListener = {};\n\n    /**\n     * @param {string} key\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Function} handler\n     *      param: {string} currTrigger\n     *      param: {Array.<number>} point\n     */\n    globalListener.register = function (key, api, handler) {\n        if (env.node) {\n            return;\n        }\n\n        var zr = api.getZr();\n        get(zr).records || (get(zr).records = {});\n\n        initGlobalListeners(zr, api);\n\n        var record = get(zr).records[key] || (get(zr).records[key] = {});\n        record.handler = handler;\n    };\n\n    function initGlobalListeners(zr, api) {\n        if (get(zr).initialized) {\n            return;\n        }\n\n        get(zr).initialized = true;\n\n        useHandler('click', zrUtil.curry(doEnter, 'click'));\n        useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove'));\n        // useHandler('mouseout', onLeave);\n        useHandler('globalout', onLeave);\n\n        function useHandler(eventType, cb) {\n            zr.on(eventType, function (e) {\n                var dis = makeDispatchAction(api);\n\n                each(get(zr).records, function (record) {\n                    record && cb(record, e, dis.dispatchAction);\n                });\n\n                dispatchTooltipFinally(dis.pendings, api);\n            });\n        }\n    }\n\n    function dispatchTooltipFinally(pendings, api) {\n        var showLen = pendings.showTip.length;\n        var hideLen = pendings.hideTip.length;\n\n        var actuallyPayload;\n        if (showLen) {\n            actuallyPayload = pendings.showTip[showLen - 1];\n        }\n        else if (hideLen) {\n            actuallyPayload = pendings.hideTip[hideLen - 1];\n        }\n        if (actuallyPayload) {\n            actuallyPayload.dispatchAction = null;\n            api.dispatchAction(actuallyPayload);\n        }\n    }\n\n    function onLeave(record, e, dispatchAction) {\n        record.handler('leave', null, dispatchAction);\n    }\n\n    function doEnter(currTrigger, record, e, dispatchAction) {\n        record.handler(currTrigger, e, dispatchAction);\n    }\n\n    function makeDispatchAction(api) {\n        var pendings = {\n            showTip: [],\n            hideTip: []\n        };\n        // FIXME\n        // better approach?\n        // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\n        // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\n        // So we have to add \"final stage\" to merge those dispatched actions.\n        var dispatchAction = function (payload) {\n            var pendingList = pendings[payload.type];\n            if (pendingList) {\n                pendingList.push(payload);\n            }\n            else {\n                payload.dispatchAction = dispatchAction;\n                api.dispatchAction(payload);\n            }\n        };\n\n        return {\n            dispatchAction: dispatchAction,\n            pendings: pendings\n        };\n    }\n\n    /**\n     * @param {string} key\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    globalListener.unregister = function (key, api) {\n        if (env.node) {\n            return;\n        }\n        var zr = api.getZr();\n        var record = (get(zr).records || {})[key];\n        if (record) {\n            get(zr).records[key] = null;\n        }\n    };\n\n    module.exports = globalListener;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/globalListener.js\n// module id = 251\n// module chunks = 0 1 2 3 4 5","'use strict';\n\n\n    function defaultKeyGetter(item) {\n        return item;\n    }\n\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n\n    DataDiffer.prototype = {\n\n        constructor: DataDiffer,\n\n        /**\n         * Callback function when add a data\n         */\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n\n        /**\n         * Callback function when update a data\n         */\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n\n        /**\n         * Callback function when remove a data\n         */\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    }\n                    else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                }\n                else {\n                    this._remove && this._remove(i);\n                }\n            }\n\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    }\n                    else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            // Add prefix to avoid conflict with Object.prototype.\n            var key = '_ec_' + keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            }\n            else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n\n    module.exports = DataDiffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/DataDiffer.js\n// module id = 252\n// module chunks = 0 1 2 3 4 5 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var helper = {};\n\n    /**\n     * @param {Object} opt {labelInside}\n     * @return {Object} {\n     *  position, rotation, labelDirection, labelOffset,\n     *  tickDirection, labelRotate, labelInterval, z2\n     * }\n     */\n    helper.layout = function (gridModel, axisModel, opt) {\n        opt = opt || {};\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n\n        // [left, right, top, bottom]\n        var rect = grid.getRect();\n        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\n        var axisOffset = axisModel.get('offset') || 0;\n\n        var posMap = {\n            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },\n            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }\n        };\n\n        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\n        function getZero(dim, val) {\n            var theAxis = grid.getAxis(dim);\n            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n        }\n\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n        ];\n\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\n        // Tick and label direction, x y is axisDim\n        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        layout.labelOffset = axis.onZero ? posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero : 0;\n\n        if (axisModel.get('axisTick.inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n\n        // Special label rotation\n        var labelRotate = axisModel.get('axisLabel.rotate');\n        layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate;\n\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n\n        return layout;\n    };\n\n    module.exports = helper;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/cartesianAxisHelper.js\n// module id = 253\n// module chunks = 0 1 2 3 4 5","'use strict';\n\n\n    var graphic = require('../../util/graphic');\n    var BaseAxisPointer = require('./BaseAxisPointer');\n    var viewHelper = require('./viewHelper');\n    var cartesianAxisHelper = require('../axis/cartesianAxisHelper');\n    var AxisView = require('../axis/AxisView');\n\n    var CartesianAxisPointer = BaseAxisPointer.extend({\n\n        /**\n         * @override\n         */\n        makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n            var axis = axisModel.axis;\n            var grid = axis.grid;\n            var axisPointerType = axisPointerModel.get('type');\n            var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n            var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n\n            if (axisPointerType && axisPointerType !== 'none') {\n                var elStyle = viewHelper.buildElStyle(axisPointerModel);\n                var pointerOption = pointerShapeBuilder[axisPointerType](\n                    axis, pixelValue, otherExtent, elStyle\n                );\n                pointerOption.style = elStyle;\n                elOption.graphicKey = pointerOption.type;\n                elOption.pointer = pointerOption;\n            }\n\n            var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);\n            viewHelper.buildCartesianSingleLabelElOption(\n                value, elOption, layoutInfo, axisModel, axisPointerModel, api\n            );\n        },\n\n        /**\n         * @override\n         */\n        getHandleTransform: function (value, axisModel, axisPointerModel) {\n            var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {\n                labelInside: false\n            });\n            layoutInfo.labelMargin = axisPointerModel.get('handle.margin');\n            return {\n                position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n                rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n            };\n        },\n\n        /**\n         * @override\n         */\n        updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {\n            var axis = axisModel.axis;\n            var grid = axis.grid;\n            var axisExtent = axis.getGlobalExtent(true);\n            var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n            var dimIndex = axis.dim === 'x' ? 0 : 1;\n\n            var currPosition = transform.position;\n            currPosition[dimIndex] += delta[dimIndex];\n            currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n            currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n\n            var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n            var cursorPoint = [cursorOtherValue, cursorOtherValue];\n            cursorPoint[dimIndex] = currPosition[dimIndex];\n\n            // Make tooltip do not overlap axisPointer and in the middle of the grid.\n            var tooltipOptions = [{verticalAlign: 'middle'}, {align: 'center'}];\n\n            return {\n                position: currPosition,\n                rotation: transform.rotation,\n                cursorPoint: cursorPoint,\n                tooltipOption: tooltipOptions[dimIndex]\n            };\n        }\n\n    });\n\n    function getCartesian(grid, axis) {\n        var opt = {};\n        opt[axis.dim + 'AxisIndex'] = axis.index;\n        return grid.getCartesian(opt);\n    }\n\n    var pointerShapeBuilder = {\n\n        line: function (axis, pixelValue, otherExtent, elStyle) {\n            var targetShape = viewHelper.makeLineShape(\n                [pixelValue, otherExtent[0]],\n                [pixelValue, otherExtent[1]],\n                getAxisDimIndex(axis)\n            );\n            graphic.subPixelOptimizeLine({\n                shape: targetShape,\n                style: elStyle\n            });\n            return {\n                type: 'Line',\n                shape: targetShape\n            };\n        },\n\n        shadow: function (axis, pixelValue, otherExtent, elStyle) {\n            var bandWidth = axis.getBandWidth();\n            var span = otherExtent[1] - otherExtent[0];\n            return {\n                type: 'Rect',\n                shape: viewHelper.makeRectShape(\n                    [pixelValue - bandWidth / 2, otherExtent[0]],\n                    [bandWidth, span],\n                    getAxisDimIndex(axis)\n                )\n            };\n        }\n    };\n\n    function getAxisDimIndex(axis) {\n        return axis.dim === 'x' ? 0 : 1;\n    }\n\n    AxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);\n\n    module.exports = CartesianAxisPointer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/CartesianAxisPointer.js\n// module id = 254\n// module chunks = 0 1 2 3 4 5","'use strict';\n\n\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('../coord/cartesian/Grid');\n\n    require('./axis');\n\n    // Grid view\n    echarts.extendComponentView({\n\n        type: 'grid',\n\n        render: function (gridModel, ecModel) {\n            this.group.removeAll();\n            if (gridModel.get('show')) {\n                this.group.add(new graphic.Rect({\n                    shape: gridModel.coordinateSystem.getRect(),\n                    style: zrUtil.defaults({\n                        fill: gridModel.get('backgroundColor')\n                    }, gridModel.getItemStyle()),\n                    silent: true,\n                    z2: -1\n                }));\n            }\n        }\n\n    });\n\n    echarts.registerPreprocessor(function (option) {\n        // Only create grid when need\n        if (option.xAxis && option.yAxis && !option.grid) {\n            option.grid = {};\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/gridSimple.js\n// module id = 255\n// module chunks = 0 1 2 3 4","\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n\n    Component.prototype = {\n\n        constructor: Component,\n\n        init: function (ecModel, api) {},\n\n        render: function (componentModel, ecModel, api, payload) {},\n\n        dispose: function () {}\n\n    };\n\n    var componentProto = Component.prototype;\n    componentProto.updateView\n        = componentProto.updateLayout\n        = componentProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            // Do nothing;\n        };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\n    module.exports = Component;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/view/Component.js\n// module id = 256\n// module chunks = 0 1 2 3 4 5 6","/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * `min``max`\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points \n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * (p0, p1, p2, p3)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * (p0, p1, p2)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * `min``max`\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/bbox.js\n// module id = 257\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var ComponentModel = require('../../model/Component');\n    var zrUtil = require('zrender/lib/core/util');\n    var axisModelCreator = require('../axisModelCreator');\n\n    var AxisModel = ComponentModel.extend({\n\n        type: 'cartesian2dAxis',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Axis2D}\n         */\n        axis: null,\n\n        /**\n         * @override\n         */\n        init: function () {\n            AxisModel.superApply(this, 'init', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function () {\n            AxisModel.superApply(this, 'mergeOption', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        restoreData: function () {\n            AxisModel.superApply(this, 'restoreData', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         * @return {module:echarts/model/Component}\n         */\n        getCoordSysModel: function () {\n            return this.ecModel.queryComponents({\n                mainType: 'grid',\n                index: this.option.gridIndex,\n                id: this.option.gridId\n            })[0];\n        }\n\n    });\n\n    function getAxisType(axisDim, option) {\n        // Default axis with data is category axis\n        return option.type || (option.data ? 'category' : 'value');\n    }\n\n    zrUtil.merge(AxisModel.prototype, require('../axisModelCommonMixin'));\n\n    var extraOption = {\n        // gridIndex: 0,\n        // gridId: '',\n\n        // Offset is for multiple axis on the same position\n        offset: 0\n    };\n\n    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\n    module.exports = AxisModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/AxisModel.js\n// module id = 258\n// module chunks = 0 1 2 3 4","\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/line.js\n// module id = 259\n// module chunks = 0 1 2 3 4 5 6","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/quadratic.js\n// module id = 260\n// module chunks = 0 1 2 3 4 5 6","\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/windingLine.js\n// module id = 261\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'linear', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/LinearGradient.js\n// module id = 262\n// module chunks = 0 1 2 3 4 5 6","/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                // FIXME in text contain default is top\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    // Fill after stroke so the outline will not cover the main part.\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (!this._rect) {\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                if (style.hasStroke()) {\n                    var w = style.lineWidth;\n                    rect.x -= w / 2;\n                    rect.y -= w / 2;\n                    rect.width += w;\n                    rect.height += w;\n                }\n                this._rect = rect;\n            }\n\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Text.js\n// module id = 263\n// module chunks = 0 1 2 3 4 5 6","/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var textOffset = style.textOffset;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n            rect = style.textPositionRect || rect;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            if (textOffset) {\n                x += textOffset[0];\n                y += textOffset[1];\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                // Fill after stroke so the outline will not cover the main part.\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                textFill && ctx.fillText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/mixin/RectText.js\n// module id = 264\n// module chunks = 0 1 2 3 4 5 6","/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n    var zrUtil = require('./core/util');\n\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: require('./Painter')\n    };\n\n    var instances = {};    // ZRendermap\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.5.2';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        // TODO WebGL\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        //  storage.delFromStorage, \n        // FIXME ugly\n        var oldDelFromStorage = storage.delFromStorage;\n        var oldAddToStorage = storage.addToStorage;\n\n        storage.delFromStorage = function (el) {\n            oldDelFromStorage.call(storage, el);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToStorage = function (el) {\n            oldAddToStorage.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * \n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, dpr) {\n            return this.painter.pathToImage(e, dpr);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Find hovered element\n         * @param {number} x\n         * @param {number} y\n         * @return {Object} {target, topTarget}\n         */\n        findHover: function (x, y) {\n            return this.handler.findHover(x, y);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/zrender.js\n// module id = 265\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var echartsAPIList = [\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed',\n        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',\n        'getViewOfComponentModel', 'getViewOfSeriesModel'\n    ];\n    // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js\n\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n\n    module.exports = ExtensionAPI;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/ExtensionAPI.js\n// module id = 266\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazzUtil = require('../../util/clazz');\n    var graphic = require('../../util/graphic');\n    var get = require('../../util/model').makeGetter();\n    var axisPointerModelHelper = require('./modelHelper');\n    var eventTool = require('zrender/lib/core/event');\n    var throttle = require('../../util/throttle');\n\n    var clone = zrUtil.clone;\n    var bind = zrUtil.bind;\n\n    /**\n     * Base axis pointer class in 2D.\n     * Implemenents {module:echarts/component/axis/IAxisPointer}.\n     */\n    function BaseAxisPointer () {\n    }\n\n    BaseAxisPointer.prototype = {\n\n        /**\n         * @private\n         */\n        _group: null,\n\n        /**\n         * @private\n         */\n        _lastGraphicKey: null,\n\n        /**\n         * @private\n         */\n        _handle: null,\n\n        /**\n         * @private\n         */\n        _dragging: false,\n\n        /**\n         * @private\n         */\n        _lastValue: null,\n\n        /**\n         * @private\n         */\n        _lastStatus: null,\n\n        /**\n         * @private\n         */\n        _payloadInfo: null,\n\n        /**\n         * In px, arbitrary value. Do not set too small,\n         * no animation is ok for most cases.\n         * @protected\n         */\n        animationThreshold: 15,\n\n        /**\n         * @implement\n         */\n        render: function (axisModel, axisPointerModel, api, forceRender) {\n            var value = axisPointerModel.get('value');\n            var status = axisPointerModel.get('status');\n\n            // Bind them to `this`, not in closure, otherwise they will not\n            // be replaced when user calling setOption in not merge mode.\n            this._axisModel = axisModel;\n            this._axisPointerModel = axisPointerModel;\n            this._api = api;\n\n            // Optimize: `render` will be called repeatly during mouse move.\n            // So it is power consuming if performing `render` each time,\n            // especially on mobile device.\n            if (!forceRender\n                && this._lastValue === value\n                && this._lastStatus === status\n            ) {\n                return;\n            }\n            this._lastValue = value;\n            this._lastStatus = status;\n\n            var group = this._group;\n            var handle = this._handle;\n\n            if (!status || status === 'hide') {\n                // Do not clear here, for animation better.\n                group && group.hide();\n                handle && handle.hide();\n                return;\n            }\n            group && group.show();\n            handle && handle.show();\n\n            // Otherwise status is 'show'\n            var elOption = {};\n            this.makeElOption(elOption, value, axisModel, axisPointerModel, api);\n\n            // Enable change axis pointer type.\n            var graphicKey = elOption.graphicKey;\n            if (graphicKey !== this._lastGraphicKey) {\n                this.clear(api);\n            }\n            this._lastGraphicKey = graphicKey;\n\n            var moveAnimation = this._moveAnimation =\n                this.determineAnimation(axisModel, axisPointerModel);\n\n            if (!group) {\n                group = this._group = new graphic.Group();\n                this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n                this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n                api.getZr().add(group);\n            }\n            else {\n                var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);\n                this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);\n                this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n            }\n\n            updateMandatoryProps(group, axisPointerModel, true);\n\n            this._renderHandle(value);\n        },\n\n        /**\n         * @implement\n         */\n        remove: function (api) {\n            this.clear(api);\n        },\n\n        /**\n         * @implement\n         */\n        dispose: function (api) {\n            this.clear(api);\n        },\n\n        /**\n         * @protected\n         */\n        determineAnimation: function (axisModel, axisPointerModel) {\n            var animation = axisPointerModel.get('animation');\n            var axis = axisModel.axis;\n            var isCategoryAxis = axis.type === 'category';\n            var useSnap = axisPointerModel.get('snap');\n\n            // Value axis without snap always do not snap.\n            if (!useSnap && !isCategoryAxis) {\n                return false;\n            }\n\n            if (animation === 'auto' || animation == null) {\n                var animationThreshold = this.animationThreshold;\n                if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n                    return true;\n                }\n\n                // It is important to auto animation when snap used. Consider if there is\n                // a dataZoom, animation will be disabled when too many points exist, while\n                // it will be enabled for better visual effect when little points exist.\n                if (useSnap) {\n                    var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;\n                    var axisExtent = axis.getExtent();\n                    // Approximate band width\n                    return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n                }\n\n                return false;\n            }\n\n            return animation === true;\n        },\n\n        /**\n         * add {pointer, label, graphicKey} to elOption\n         * @protected\n         */\n        makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n            // Shoule be implemenented by sub-class.\n        },\n\n        /**\n         * @protected\n         */\n        createPointerEl: function (group, elOption, axisModel, axisPointerModel) {\n            var pointerOption = elOption.pointer;\n            if (pointerOption) {\n                var pointerEl = get(group).pointerEl = new graphic[pointerOption.type](\n                    clone(elOption.pointer)\n                );\n                group.add(pointerEl);\n            }\n        },\n\n        /**\n         * @protected\n         */\n        createLabelEl: function (group, elOption, axisModel, axisPointerModel) {\n            if (elOption.label) {\n                var labelEl = get(group).labelEl = new graphic.Rect(\n                    clone(elOption.label)\n                );\n\n                group.add(labelEl);\n                updateLabelShowHide(labelEl, axisPointerModel);\n            }\n        },\n\n        /**\n         * @protected\n         */\n        updatePointerEl: function (group, elOption, updateProps) {\n            var pointerEl = get(group).pointerEl;\n            if (pointerEl) {\n                pointerEl.setStyle(elOption.pointer.style);\n                updateProps(pointerEl, {shape: elOption.pointer.shape});\n            }\n        },\n\n        /**\n         * @protected\n         */\n        updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {\n            var labelEl = get(group).labelEl;\n            if (labelEl) {\n                labelEl.setStyle(elOption.label.style);\n                updateProps(labelEl, {\n                    // Consider text length change in vertical axis, animation should\n                    // be used on shape, otherwise the effect will be weird.\n                    shape: elOption.label.shape,\n                    position: elOption.label.position\n                });\n\n                updateLabelShowHide(labelEl, axisPointerModel);\n            }\n        },\n\n        /**\n         * @private\n         */\n        _renderHandle: function (value) {\n            if (this._dragging || !this.updateHandleTransform) {\n                return;\n            }\n\n            var axisPointerModel = this._axisPointerModel;\n            var zr = this._api.getZr();\n            var handle = this._handle;\n            var handleModel = axisPointerModel.getModel('handle');\n\n            var status = axisPointerModel.get('status');\n            if (!handleModel.get('show') || !status || status === 'hide') {\n                handle && zr.remove(handle);\n                this._handle = null;\n                return;\n            }\n\n            var isInit;\n            if (!this._handle) {\n                isInit = true;\n                handle = this._handle = createIcon(handleModel, {\n                    onmousemove: function (e) {\n                        // Fot mobile devicem, prevent screen slider on the button.\n                        eventTool.stop(e.event);\n                    },\n                    onmousedown: bind(this._onHandleDragMove, this, 0, 0),\n                    drift: bind(this._onHandleDragMove, this),\n                    ondragend: bind(this._onHandleDragEnd, this)\n                });\n                zr.add(handle);\n            }\n\n            updateMandatoryProps(handle, axisPointerModel, false);\n\n            // update style\n            var includeStyles = [\n                'color', 'borderColor', 'borderWidth', 'opacity',\n                'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'\n            ];\n            handle.setStyle(handleModel.getItemStyle(null, includeStyles));\n\n            // update position\n            var handleSize = handleModel.get('size');\n            if (!zrUtil.isArray(handleSize)) {\n                handleSize = [handleSize, handleSize];\n            }\n            handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);\n\n            throttle.createOrUpdate(\n                this,\n                '_doDispatchAxisPointer',\n                handleModel.get('throttle') || 0,\n                'fixRate'\n            );\n\n            this._moveHandleToValue(value, isInit);\n        },\n\n        /**\n         * @private\n         */\n        _moveHandleToValue: function (value, isInit) {\n            updateProps(\n                this._axisPointerModel,\n                !isInit && this._moveAnimation,\n                this._handle,\n                getHandleTransProps(this.getHandleTransform(\n                    value, this._axisModel, this._axisPointerModel\n                ))\n            );\n        },\n\n        /**\n         * @private\n         */\n        _onHandleDragMove: function (dx, dy) {\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            this._dragging = true;\n\n            // Persistent for throttle.\n            var trans = this.updateHandleTransform(\n                getHandleTransProps(handle),\n                [dx, dy],\n                this._axisModel,\n                this._axisPointerModel\n            );\n            this._payloadInfo = trans;\n\n            handle.stopAnimation();\n            handle.attr(getHandleTransProps(trans));\n            get(handle).lastProp = null;\n\n            this._doDispatchAxisPointer();\n        },\n\n        /**\n         * Throttled method.\n         * @private\n         */\n        _doDispatchAxisPointer: function () {\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            var payloadInfo = this._payloadInfo;\n            var axisModel = this._axisModel;\n            this._api.dispatchAction({\n                type: 'updateAxisPointer',\n                x: payloadInfo.cursorPoint[0],\n                y: payloadInfo.cursorPoint[1],\n                tooltipOption: payloadInfo.tooltipOption,\n                axesInfo: [{\n                    axisDim: axisModel.axis.dim,\n                    axisIndex: axisModel.componentIndex\n                }]\n            });\n        },\n\n        /**\n         * @private\n         */\n        _onHandleDragEnd: function (moveAnimation) {\n            this._dragging = false;\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            var value = this._axisPointerModel.get('value');\n            // Consider snap or categroy axis, handle may be not consistent with\n            // axisPointer. So move handle to align the exact value position when\n            // drag ended.\n            this._moveHandleToValue(value);\n\n            // For the effect: tooltip will be shown when finger holding on handle\n            // button, and will be hidden after finger left handle button.\n            this._api.dispatchAction({\n                type: 'hideTip'\n            });\n        },\n\n        /**\n         * Should be implemenented by sub-class if support `handle`.\n         * @protected\n         * @param {number} value\n         * @param {module:echarts/model/Model} axisModel\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @return {Object} {position: [x, y], rotation: 0}\n         */\n        getHandleTransform: null,\n\n        /**\n         * * Should be implemenented by sub-class if support `handle`.\n         * @protected\n         * @param {Object} transform {position, rotation}\n         * @param {Array.<number>} delta [dx, dy]\n         * @param {module:echarts/model/Model} axisModel\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}\n         */\n        updateHandleTransform: null,\n\n        /**\n         * @private\n         */\n        clear: function (api) {\n            this._lastValue = null;\n            this._lastStatus = null;\n\n            var zr = api.getZr();\n            var group = this._group;\n            var handle = this._handle;\n            if (zr && group) {\n                this._lastGraphicKey = null;\n                group && zr.remove(group);\n                handle && zr.remove(handle);\n                this._group = null;\n                this._handle = null;\n                this._payloadInfo = null;\n            }\n        },\n\n        /**\n         * @protected\n         */\n        doClear: function () {\n            // Implemented by sub-class if necessary.\n        },\n\n        /**\n         * @protected\n         * @param {Array.<number>} xy\n         * @param {Array.<number>} wh\n         * @param {number} [xDimIndex=0] or 1\n         */\n        buildLabel: function (xy, wh, xDimIndex) {\n            xDimIndex = xDimIndex || 0;\n            return {\n                x: xy[xDimIndex],\n                y: xy[1 - xDimIndex],\n                width: wh[xDimIndex],\n                height: wh[1 - xDimIndex]\n            };\n        }\n    };\n\n    BaseAxisPointer.prototype.constructor = BaseAxisPointer;\n\n\n    function updateProps(animationModel, moveAnimation, el, props) {\n        // Animation optimize.\n        if (!propsEqual(get(el).lastProp, props)) {\n            get(el).lastProp = props;\n            moveAnimation\n                ? graphic.updateProps(el, props, animationModel)\n                : (el.stopAnimation(), el.attr(props));\n        }\n    }\n\n    function propsEqual(lastProps, newProps) {\n        if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {\n            var equals = true;\n            zrUtil.each(newProps, function (item, key) {\n                equals &= propsEqual(lastProps[key], item);\n            });\n            return !!equals;\n        }\n        else {\n            return lastProps === newProps;\n        }\n    }\n\n    function updateLabelShowHide(labelEl, axisPointerModel) {\n        labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();\n    }\n\n    function getHandleTransProps(trans) {\n        return {\n            position: trans.position.slice(),\n            rotation: trans.rotation || 0\n        };\n    }\n\n    function createIcon(handleModel, handlers) {\n        var iconStr = handleModel.get('icon');\n        var style = {\n            x: -1, y: -1, width: 2, height: 2\n        };\n        var opt = zrUtil.extend({\n            style: {\n                strokeNoScale: true\n            },\n            rectHover: true,\n            cursor: 'move',\n            draggable: true\n        }, handlers);\n\n        return iconStr.indexOf('image://') === 0\n            ? (\n                style.image = iconStr.slice(8),\n                opt.style = style,\n                new graphic.Image(opt)\n            )\n            : graphic.makePath(\n                iconStr.replace('path://', ''),\n                opt,\n                style,\n                'center'\n            );\n    }\n\n    function updateMandatoryProps(group, axisPointerModel, silent) {\n        var z = axisPointerModel.get('z');\n        var zlevel = axisPointerModel.get('zlevel');\n\n        group && group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n                el.silent = silent;\n            }\n        });\n    }\n\n    clazzUtil.enableClassExtend(BaseAxisPointer);\n\n    module.exports = BaseAxisPointer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/BaseAxisPointer.js\n// module id = 267\n// module chunks = 0 1 2 3 4 5","\n\n    var createListFromArray = require('./chart/helper/createListFromArray');\n    var symbolUtil = require('./util/symbol');\n    var axisHelper = require('./coord/axisHelper');\n    var axisModelCommonMixin = require('./coord/axisModelCommonMixin');\n    var Model = require('./model/Model');\n    var util = require('zrender/lib/core/util');\n\n    module.exports = {\n        /**\n         * Create a muti dimension List structure from seriesModel.\n         * @param  {module:echarts/model/Model} seriesModel\n         * @return {module:echarts/data/List} list\n         */\n        createList: function (seriesModel) {\n            var data = seriesModel.get('data');\n            return createListFromArray(data, seriesModel, seriesModel.ecModel);\n        },\n\n        /**\n         * @see {module:echarts/data/helper/completeDimensions}\n         */\n        completeDimensions: require('./data/helper/completeDimensions'),\n\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @see http://echarts.baidu.com/option.html#series-scatter.symbol\n         * @param {string} symbolDesc\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: symbolUtil.createSymbol,\n\n        /**\n         * Create scale\n         * @param {Array.<number>} dataExtent\n         * @param {Object|module:echarts/Model} option\n         */\n        createScale: function (dataExtent, option) {\n            var axisModel = option;\n            if (!(option instanceof Model)) {\n                axisModel = new Model(option);\n                util.mixin(axisModel, axisModelCommonMixin);\n            }\n\n            var scale = axisHelper.createScaleByModel(axisModel);\n            scale.setExtent(dataExtent[0], dataExtent[1]);\n\n            axisHelper.niceScaleExtent(scale, axisModel);\n            return scale;\n        },\n\n        /**\n         * Mixin common methods to axis model,\n         *\n         * Inlcude methods\n         * `getFormattedLabels() => Array.<string>`\n         * `getCategories() => Array.<string>`\n         * `getMin(origin: boolean) => number`\n         * `getMax(origin: boolean) => number`\n         * `getNeedCrossZero() => boolean`\n         * `setRange(start: number, end: number)`\n         * `resetRange()`\n         */\n        mixinAxisModelCommonMethods: function (Model) {\n            util.mixin(Model, axisModelCommonMixin);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/helper.js\n// module id = 268\n// module chunks = 0 1 2 3 4 5 6","\n\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    module.exports = function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n            style: {\n                fill: opts.maskColor\n            },\n            zlevel: opts.zlevel,\n            z: 10000\n        });\n        var arc = new graphic.Arc({\n            shape: {\n                startAngle: -PI / 2,\n                endAngle: -PI / 2 + 0.1,\n                r: 10\n            },\n            style: {\n                stroke: opts.color,\n                lineCap: 'round',\n                lineWidth: 5\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n        var labelRect = new graphic.Rect({\n            style: {\n                fill: 'none',\n                text: opts.text,\n                textPosition: 'right',\n                textDistance: 10,\n                textFill: opts.textColor\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n\n        arc.animateShape(true)\n            .when(1000, {\n                endAngle: PI * 3 / 2\n            })\n            .start('circularInOut');\n        arc.animateShape(true)\n            .when(1000, {\n                startAngle: PI * 3 / 2\n            })\n            .delay(300)\n            .start('circularInOut');\n\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/loading/default.js\n// module id = 269\n// module chunks = 0 1 2 3 4 5 6","/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n\n    /**\n     * Caution: If the mechanism should be changed some day, these cases\n     * should be considered:\n     *\n     * (1) In `merge option` mode, if using the same option to call `setOption`\n     * many times, the result should be the same (try our best to ensure that).\n     * (2) In `merge option` mode, if a component has no id/name specified, it\n     * will be merged by index, and the result sequence of the components is\n     * consistent to the original sequence.\n     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n     * `mergeOption` in module:echarts/model/OptionManager.\n     */\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var Model = require('./Model');\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n\n    var ComponentModel = require('./Component');\n\n    var globalDefault = require('./globalDefault');\n\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n\n        constructor: GlobalModel,\n\n        init: function (option, parentModel, theme, optionManager) {\n            theme = theme || {};\n\n            this.option = null; // Mark as not initialized.\n\n            /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n            this._theme = new Model(theme);\n\n            /**\n             * @type {module:echarts/model/OptionManager}\n             */\n            this._optionManager = optionManager;\n        },\n\n        setOption: function (option, optionPreprocessorFuncs) {\n            zrUtil.assert(\n                !(OPTION_INNER_KEY in option),\n                'please use chart.getOption()'\n            );\n\n            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n            this.resetOption(null);\n        },\n\n        /**\n         * @param {string} type null/undefined: reset all.\n         *                      'recreate': force recreate all.\n         *                      'timeline': only reset timeline option\n         *                      'media': only reset media query option\n         * @return {boolean} Whether option changed.\n         */\n        resetOption: function (type) {\n            var optionChanged = false;\n            var optionManager = this._optionManager;\n\n            if (!type || type === 'recreate') {\n                var baseOption = optionManager.mountOption(type === 'recreate');\n\n                if (!this.option || type === 'recreate') {\n                    initBase.call(this, baseOption);\n                }\n                else {\n                    this.restoreData();\n                    this.mergeOption(baseOption);\n                }\n                optionChanged = true;\n            }\n\n            if (type === 'timeline' || type === 'media') {\n                this.restoreData();\n            }\n\n            if (!type || type === 'recreate' || type === 'timeline') {\n                var timelineOption = optionManager.getTimelineOption(this);\n                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n            }\n\n            if (!type || type === 'recreate' || type === 'media') {\n                var mediaOptions = optionManager.getMediaOption(this, this._api);\n                if (mediaOptions.length) {\n                    each(mediaOptions, function (mediaOption) {\n                        this.mergeOption(mediaOption, optionChanged = true);\n                    }, this);\n                }\n            }\n\n            return optionChanged;\n        },\n\n        /**\n         * @protected\n         */\n        mergeOption: function (newOption) {\n            var option = this.option;\n            var componentsMap = this._componentsMap;\n            var newCptTypes = [];\n\n            //  component model  merge\n            each(newOption, function (componentOption, mainType) {\n                if (componentOption == null) {\n                    return;\n                }\n\n                if (!ComponentModel.hasClass(mainType)) {\n                    option[mainType] = option[mainType] == null\n                        ? zrUtil.clone(componentOption)\n                        : zrUtil.merge(option[mainType], componentOption, true);\n                }\n                else {\n                    newCptTypes.push(mainType);\n                }\n            });\n\n            // FIXME OPTION \n            ComponentModel.topologicalTravel(\n                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n            );\n\n            this._seriesIndices = this._seriesIndices || [];\n\n            function visitComponent(mainType, dependencies) {\n                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\n                var mapResult = modelUtil.mappingToExists(\n                    componentsMap.get(mainType), newCptOptionList\n                );\n\n                modelUtil.makeIdAndName(mapResult);\n\n                // Set mainType and complete subType.\n                each(mapResult, function (item, index) {\n                    var opt = item.option;\n                    if (isObject(opt)) {\n                        item.keyInfo.mainType = mainType;\n                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n                    }\n                });\n\n                var dependentModels = getComponentsByTypes(\n                    componentsMap, dependencies\n                );\n\n                option[mainType] = [];\n                componentsMap.set(mainType, []);\n\n                each(mapResult, function (resultItem, index) {\n                    var componentModel = resultItem.exist;\n                    var newCptOption = resultItem.option;\n\n                    zrUtil.assert(\n                        isObject(newCptOption) || componentModel,\n                        'Empty component definition'\n                    );\n\n                    // Consider where is no new option and should be merged using {},\n                    // see removeEdgeAndAdd in topologicalTravel and\n                    // ComponentModel.getAllClassMainTypes.\n                    if (!newCptOption) {\n                        componentModel.mergeOption({}, this);\n                        componentModel.optionUpdated({}, false);\n                    }\n                    else {\n                        var ComponentModelClass = ComponentModel.getClass(\n                            mainType, resultItem.keyInfo.subType, true\n                        );\n\n                        if (componentModel && componentModel instanceof ComponentModelClass) {\n                            componentModel.name = resultItem.keyInfo.name;\n                            componentModel.mergeOption(newCptOption, this);\n                            componentModel.optionUpdated(newCptOption, false);\n                        }\n                        else {\n                            // PENDING Global as parent ?\n                            var extraOpt = zrUtil.extend(\n                                {\n                                    dependentModels: dependentModels,\n                                    componentIndex: index\n                                },\n                                resultItem.keyInfo\n                            );\n                            componentModel = new ComponentModelClass(\n                                newCptOption, this, this, extraOpt\n                            );\n                            zrUtil.extend(componentModel, extraOpt);\n                            componentModel.init(newCptOption, this, this, extraOpt);\n                            // Call optionUpdated after init.\n                            // newCptOption has been used as componentModel.option\n                            // and may be merged with theme and default, so pass null\n                            // to avoid confusion.\n                            componentModel.optionUpdated(null, true);\n                        }\n                    }\n\n                    componentsMap.get(mainType)[index] = componentModel;\n                    option[mainType][index] = componentModel.option;\n                }, this);\n\n                // Backup series for filtering.\n                if (mainType === 'series') {\n                    this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n                }\n            }\n        },\n\n        /**\n         * Get option for output (cloned option and inner info removed)\n         * @public\n         * @return {Object}\n         */\n        getOption: function () {\n            var option = zrUtil.clone(this.option);\n\n            each(option, function (opts, mainType) {\n                if (ComponentModel.hasClass(mainType)) {\n                    var opts = modelUtil.normalizeToArray(opts);\n                    for (var i = opts.length - 1; i >= 0; i--) {\n                        // Remove options with inner id.\n                        if (modelUtil.isIdInner(opts[i])) {\n                            opts.splice(i, 1);\n                        }\n                    }\n                    option[mainType] = opts;\n                }\n            });\n\n            delete option[OPTION_INNER_KEY];\n\n            return option;\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        getTheme: function () {\n            return this._theme;\n        },\n\n        /**\n         * @param {string} mainType\n         * @param {number} [idx=0]\n         * @return {module:echarts/model/Component}\n         */\n        getComponent: function (mainType, idx) {\n            var list = this._componentsMap.get(mainType);\n            if (list) {\n                return list[idx || 0];\n            }\n        },\n\n        /**\n         * If none of index and id and name used, return all components with mainType.\n         * @param {Object} condition\n         * @param {string} condition.mainType\n         * @param {string} [condition.subType] If ignore, only query by mainType\n         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        queryComponents: function (condition) {\n            var mainType = condition.mainType;\n            if (!mainType) {\n                return [];\n            }\n\n            var index = condition.index;\n            var id = condition.id;\n            var name = condition.name;\n\n            var cpts = this._componentsMap.get(mainType);\n\n            if (!cpts || !cpts.length) {\n                return [];\n            }\n\n            var result;\n\n            if (index != null) {\n                if (!isArray(index)) {\n                    index = [index];\n                }\n                result = filter(map(index, function (idx) {\n                    return cpts[idx];\n                }), function (val) {\n                    return !!val;\n                });\n            }\n            else if (id != null) {\n                var isIdArray = isArray(id);\n                result = filter(cpts, function (cpt) {\n                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n                        || (!isIdArray && cpt.id === id);\n                });\n            }\n            else if (name != null) {\n                var isNameArray = isArray(name);\n                result = filter(cpts, function (cpt) {\n                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n                        || (!isNameArray && cpt.name === name);\n                });\n            }\n            else {\n                // Return all components with mainType\n                result = cpts.slice();\n            }\n\n            return filterBySubType(result, condition);\n        },\n\n        /**\n         * The interface is different from queryComponents,\n         * which is convenient for inner usage.\n         *\n         * @usage\n         * var result = findComponents(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series'},\n         *     function (model, index) {...}\n         * );\n         * // result like [component0, componnet1, ...]\n         *\n         * @param {Object} condition\n         * @param {string} condition.mainType Mandatory.\n         * @param {string} [condition.subType] Optional.\n         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n         *        where xxx is mainType.\n         *        If query attribute is null/undefined or has no index/id/name,\n         *        do not filtering by query conditions, which is convenient for\n         *        no-payload situations or when target of action is global.\n         * @param {Function} [condition.filter] parameter: component, return boolean.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        findComponents: function (condition) {\n            var query = condition.query;\n            var mainType = condition.mainType;\n\n            var queryCond = getQueryCond(query);\n            var result = queryCond\n                ? this.queryComponents(queryCond)\n                : this._componentsMap.get(mainType);\n\n            return doFilter(filterBySubType(result, condition));\n\n            function getQueryCond(q) {\n                var indexAttr = mainType + 'Index';\n                var idAttr = mainType + 'Id';\n                var nameAttr = mainType + 'Name';\n                return q && (\n                        q[indexAttr] != null\n                        || q[idAttr] != null\n                        || q[nameAttr] != null\n                    )\n                    ? {\n                        mainType: mainType,\n                        // subType will be filtered finally.\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    }\n                    : null;\n            }\n\n            function doFilter(res) {\n                return condition.filter\n                     ? filter(res, condition.filter)\n                     : res;\n            }\n        },\n\n        /**\n         * @usage\n         * eachComponent('legend', function (legendModel, index) {\n         *     ...\n         * });\n         * eachComponent(function (componentType, model, index) {\n         *     // componentType does not include subType\n         *     // (componentType is 'xxx' but not 'xxx.aa')\n         * });\n         * eachComponent(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n         *     function (model, index) {...}\n         * );\n         * eachComponent(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n         *     function (model, index) {...}\n         * );\n         *\n         * @param {string|Object=} mainType When mainType is object, the definition\n         *                                  is the same as the method 'findComponents'.\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachComponent: function (mainType, cb, context) {\n            var componentsMap = this._componentsMap;\n\n            if (typeof mainType === 'function') {\n                context = cb;\n                cb = mainType;\n                componentsMap.each(function (components, componentType) {\n                    each(components, function (component, index) {\n                        cb.call(context, componentType, component, index);\n                    });\n                });\n            }\n            else if (zrUtil.isString(mainType)) {\n                each(componentsMap.get(mainType), cb, context);\n            }\n            else if (isObject(mainType)) {\n                var queryResult = this.findComponents(mainType);\n                each(queryResult, cb, context);\n            }\n        },\n\n        /**\n         * @param {string} name\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByName: function (name) {\n            var series = this._componentsMap.get('series');\n            return filter(series, function (oneSeries) {\n                return oneSeries.name === name;\n            });\n        },\n\n        /**\n         * @param {number} seriesIndex\n         * @return {module:echarts/model/Series}\n         */\n        getSeriesByIndex: function (seriesIndex) {\n            return this._componentsMap.get('series')[seriesIndex];\n        },\n\n        /**\n         * @param {string} subType\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByType: function (subType) {\n            var series = this._componentsMap.get('series');\n            return filter(series, function (oneSeries) {\n                return oneSeries.subType === subType;\n            });\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeries: function () {\n            return this._componentsMap.get('series').slice();\n        },\n\n        /**\n         * After filtering, series may be different\n         * frome raw series.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.get('series')[rawSeriesIndex];\n                cb.call(context, series, rawSeriesIndex);\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeries: function (cb, context) {\n            each(this._componentsMap.get('series'), cb, context);\n        },\n\n        /**\n         * After filtering, series may be different.\n         * frome raw series.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeriesByType: function (subType, cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.get('series')[rawSeriesIndex];\n                if (series.subType === subType) {\n                    cb.call(context, series, rawSeriesIndex);\n                }\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered of given type.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeriesByType: function (subType, cb, context) {\n            return each(this.getSeriesByType(subType), cb, context);\n        },\n\n        /**\n         * @param {module:echarts/model/Series} seriesModel\n         */\n        isSeriesFiltered: function (seriesModel) {\n            assertSeriesInitialized(this);\n            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getCurrentSeriesIndices: function () {\n            return (this._seriesIndices || []).slice();\n        },\n\n        /**\n         * @param {Function} cb\n         * @param {*} context\n         */\n        filterSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            var filteredSeries = filter(\n                this._componentsMap.get('series'), cb, context\n            );\n            this._seriesIndices = createSeriesIndices(filteredSeries);\n        },\n\n        restoreData: function () {\n            var componentsMap = this._componentsMap;\n\n            this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n\n            var componentTypes = [];\n            componentsMap.each(function (components, componentType) {\n                componentTypes.push(componentType);\n            });\n\n            ComponentModel.topologicalTravel(\n                componentTypes,\n                ComponentModel.getAllClassMainTypes(),\n                function (componentType, dependencies) {\n                    each(componentsMap.get(componentType), function (component) {\n                        component.restoreData();\n                    });\n                }\n            );\n        }\n\n    });\n\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        zrUtil.each(theme, function (themeItem, name) {\n            //  component model  merge  model \n            if (!ComponentModel.hasClass(name)) {\n                if (typeof themeItem === 'object') {\n                    option[name] = !option[name]\n                        ? zrUtil.clone(themeItem)\n                        : zrUtil.merge(option[name], themeItem, false);\n                }\n                else {\n                    if (option[name] == null) {\n                        option[name] = themeItem;\n                    }\n                }\n            }\n        });\n    }\n\n    function initBase(baseOption) {\n        baseOption = baseOption;\n\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n\n        /**\n         * Init with series: [], in case of calling findSeries method\n         * before series initialized.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = zrUtil.createHashMap({series: []});\n\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n\n        mergeTheme(baseOption, this._theme.option);\n\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n\n        this.mergeOption(baseOption);\n    }\n\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap.get(type) || []).slice();\n        });\n\n        return ret;\n    }\n\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type\n            ? newCptOption.type\n            : existComponent\n            ? existComponent.subType\n            // Use determineSubType only when there is no existComponent.\n            : ComponentModel.determineSubType(mainType, newCptOption);\n\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType')\n            ? filter(components, function (cpt) {\n                return cpt.subType === condition.subType;\n            })\n            : components;\n    }\n\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (__DEV__) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Option should contains series.');\n            }\n        }\n    }\n\n    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n\n    module.exports = GlobalModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Global.js\n// module id = 270\n// module chunks = 0 1 2 3 4 5 6","/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n    OptionManager.prototype = {\n\n        constructor: OptionManager,\n\n        /**\n         * @public\n         * @param {Object} rawOption Raw option.\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Array.<Function>} optionPreprocessorFuncs\n         * @return {Object} Init option\n         */\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n\n            // FIXME\n            //  timeline options  media baseOption\n\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(\n                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n            );\n            this._newBaseOption = newParsedOption.baseOption;\n\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            }\n            else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n\n        /**\n         * @param {boolean} isRecreate\n         * @return {Object}\n         */\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n\n            // TODO\n            // resetclone\n\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n\n            return clone(isRecreate\n                // this._optionBackup.baseOption, which is created at the first `setOption`\n                // called, and is merged into every new option by inner method `mergeOption`\n                // each time `setOption` called, can be only used in `isRecreate`, because\n                // its reliability is under suspicion. In other cases option merge is\n                // performed by `model.mergeOption`.\n                ? optionBackup.baseOption : this._newBaseOption\n            );\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object}\n         */\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(\n                        timelineOptions[timelineModel.getCurrentIndex()],\n                        true\n                    );\n                }\n            }\n\n            return option;\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Array.<Object>}\n         */\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n\n            // FIXME\n            // mediaDefault\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(\n                        index === -1 ? mediaDefault.option : mediaList[index].option\n                    );\n                });\n            }\n            // Otherwise return nothing.\n\n            this._currentMediaIndices = indices;\n\n            return result;\n        }\n    };\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    }\n                    else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n\n        // Preprocess.\n        each([baseOption].concat(timelineOptions)\n            .concat(zrUtil.map(mediaList, function (media) {\n                return media.option;\n            })),\n            function (option) {\n                each(optionPreprocessorFuncs, function (preProcess) {\n                    preProcess(option, isNew);\n                });\n            }\n        );\n\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n            width: ecWidth,\n            height: ecHeight,\n            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n        };\n\n        var applicatable = true;\n\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n\n        return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        }\n        else if (operator === 'max') {\n            return real <= expect;\n        }\n        else { // Equals\n            return real === expect;\n        }\n    }\n\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n\n            var oldCptOpt = oldOption[mainType];\n\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            }\n            else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return (item.option && item.exist)\n                        ? merge(item.exist, item.option, true)\n                        : (item.exist || item.option);\n                });\n            }\n        });\n    }\n\n    module.exports = OptionManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/OptionManager.js\n// module id = 271\n// module chunks = 0 1 2 3 4 5 6","\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    module.exports = {\n        // \n        // backgroundColor: 'rgba(0,0,0,0)',\n\n        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n        // \n        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n        // \n        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n        //  Grid \n        // grid: {},\n        // \n        textStyle: {\n            // color: '#000',\n            // decoration: 'none',\n            // PENDING\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            // fontFamily: 'Arial, Verdana, sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n\n        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n        // Default is source-over\n        blendMode: null,\n\n        animation: 'auto',\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n\n        animationThreshold: 2000,\n        // Configuration for progressive/incremental rendering\n        progressiveThreshold: 3000,\n        progressive: 400,\n\n        // Threshold of if use single hover layer to optimize.\n        // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n        // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n        // which is unexpected.\n        // see example <echarts/test/heatmap-large.html>.\n        hoverLayerThreshold: 3000,\n\n        // See: module:echarts/scale/Time\n        useUTC: false\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/globalDefault.js\n// module id = 272\n// module chunks = 0 1 2 3 4 5 6","\n    module.exports = {\n        getAreaStyle: require('./makeStyleMapper')(\n            [\n                ['fill', 'color'],\n                ['shadowBlur'],\n                ['shadowOffsetX'],\n                ['shadowOffsetY'],\n                ['opacity'],\n                ['shadowColor']\n            ]\n        )\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/areaStyle.js\n// module id = 273\n// module chunks = 0 1 2 3 4 5 6","\n\n    module.exports = {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/boxLayout.js\n// module id = 274\n// module chunks = 0 1 2 3 4 5 6","\n    var getItemStyle = require('./makeStyleMapper')(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor'],\n            ['textPosition'],\n            ['textAlign']\n        ]\n    );\n    module.exports = {\n        getItemStyle: function (excludes, includes) {\n            var style = getItemStyle.call(this, excludes, includes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/itemStyle.js\n// module id = 275\n// module chunks = 0 1 2 3 4 5 6","\n    var getLineStyle = require('./makeStyleMapper')(\n        [\n            ['lineWidth', 'width'],\n            ['stroke', 'color'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash(style.lineWidth);\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getLineDash: function (lineWidth) {\n            if (lineWidth == null) {\n                lineWidth = 1;\n            }\n            var lineType = this.get('type');\n            var dotSize = Math.max(lineWidth, 2);\n            var dashSize = lineWidth * 4;\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/lineStyle.js\n// module id = 276\n// module chunks = 0 1 2 3 4 5 6","\n\n    var textContain = require('zrender/lib/contain/text');\n    var graphicUtil = require('../../util/graphic');\n\n    module.exports = {\n        /**\n         * Get color property or get color from option.textStyle.color\n         * @return {string}\n         */\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color')\n                || (ecModel && ecModel.get('textStyle.color'));\n        },\n\n        /**\n         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n         * @return {string}\n         */\n        getFont: function () {\n            return graphicUtil.getFont({\n                fontStyle: this.getShallow('fontStyle'),\n                fontWeight: this.getShallow('fontWeight'),\n                fontSize: this.getShallow('fontSize'),\n                fontFamily: this.getShallow('fontFamily')\n            }, this.ecModel);\n        },\n\n        getTextRect: function (text) {\n            return textContain.getBoundingRect(\n                text,\n                this.getFont(),\n                this.getShallow('align'),\n                this.getShallow('baseline')\n            );\n        },\n\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(\n                text, containerWidth, this.getFont(), ellipsis, options\n            );\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/textStyle.js\n// module id = 277\n// module chunks = 0 1 2 3 4 5 6","// Compatitable with 2.0\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var compatStyle = require('./helper/compatStyle');\n\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n\n    var LAYOUT_PROPERTIES = [\n        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n    ];\n\n    var COMPATITABLE_COMPONENTS = [\n        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n    ];\n\n    var COMPATITABLE_SERIES = [\n        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n    ];\n\n    var each = zrUtil.each;\n\n    module.exports = function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n\n            var seriesType = seriesOpt.type;\n\n            compatStyle(seriesOpt);\n\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null\n                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/preprocessor/backwardCompat.js\n// module id = 278\n// module chunks = 0 1 2 3 4 5 6","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var POSSIBLE_STYLES = [\n        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n        'chordStyle', 'label', 'labelLine'\n    ];\n\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n\n    module.exports = function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    }\n                    else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/preprocessor/helper/compatStyle.js\n// module id = 279\n// module chunks = 0 1 2 3 4 5 6","/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n    var numberUtil = require('../util/number');\n\n    // Use some method of IntervalScale\n    var IntervalScale = require('./Interval');\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n\n    var mathLog = Math.log;\n\n    var LogScale = Scale.extend({\n\n        type: 'log',\n\n        base: 10,\n\n        $constructor: function () {\n            Scale.apply(this, arguments);\n            this._originalScale = new IntervalScale();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            var originalScale = this._originalScale;\n            var extent = this._extent;\n            var originalExtent = originalScale.getExtent();\n\n            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                var powVal = numberUtil.round(mathPow(this.base, val));\n\n                // Fix #4158\n                powVal = (val === extent[0] && originalScale.__fixMin)\n                    ? fixRoundingError(powVal, originalExtent[0])\n                    : powVal;\n                powVal = (val === extent[1] && originalScale.__fixMax)\n                    ? fixRoundingError(powVal, originalExtent[1])\n                    : powVal;\n\n                return powVal;\n            }, this);\n        },\n\n        /**\n         * @param {number} val\n         * @return {string}\n         */\n        getLabel: intervalScaleProto.getLabel,\n\n        /**\n         * @param  {number} val\n         * @return {number}\n         */\n        scale: function (val) {\n            val = scaleProto.scale.call(this, val);\n            return mathPow(this.base, val);\n        },\n\n        /**\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var base = this.base;\n            start = mathLog(start) / mathLog(base);\n            end = mathLog(end) / mathLog(base);\n            intervalScaleProto.setExtent.call(this, start, end);\n        },\n\n        /**\n         * @return {number} end\n         */\n        getExtent: function () {\n            var base = this.base;\n            var extent = scaleProto.getExtent.call(this);\n            extent[0] = mathPow(base, extent[0]);\n            extent[1] = mathPow(base, extent[1]);\n\n            // Fix #4158\n            var originalScale = this._originalScale;\n            var originalExtent = originalScale.getExtent();\n            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n            return extent;\n        },\n\n        /**\n         * @param  {Array.<number>} extent\n         */\n        unionExtent: function (extent) {\n            this._originalScale.unionExtent(extent);\n\n            var base = this.base;\n            extent[0] = mathLog(extent[0]) / mathLog(base);\n            extent[1] = mathLog(extent[1]) / mathLog(base);\n            scaleProto.unionExtent.call(this, extent);\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, true, function (val) {\n                return val > 0;\n            }));\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         * @param  {number} [approxTickNum = 10] Given approx tick number\n         */\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (span === Infinity || span <= 0) {\n                return;\n            }\n\n            var interval = numberUtil.quantity(span);\n            var err = approxTickNum / span * interval;\n\n            // Filter ticks to get closer to the desired count.\n            if (err <= 0.5) {\n                interval *= 10;\n            }\n\n            // Interval should be integer\n            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                interval *= 10;\n            }\n\n            var niceExtent = [\n                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n            ];\n\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @override\n         */\n        niceExtent: function (opt) {\n            intervalScaleProto.niceExtent.call(this, opt);\n\n            var originalScale = this._originalScale;\n            originalScale.__fixMin = opt.fixMin;\n            originalScale.__fixMax = opt.fixMax;\n        }\n\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n\n    LogScale.create = function () {\n        return new LogScale();\n    };\n\n    function fixRoundingError(val, originalVal) {\n        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n    }\n\n    module.exports = LogScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Log.js\n// module id = 280\n// module chunks = 0 1 2 3 4 5 6","/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n\n    var scaleProto = Scale.prototype;\n\n    var OrdinalScale = Scale.extend({\n\n        type: 'ordinal',\n\n        init: function (data, extent) {\n            this._data = data;\n            this._extent = extent || [0, data.length - 1];\n        },\n\n        parse: function (val) {\n            return typeof val === 'string'\n                ? zrUtil.indexOf(this._data, val)\n                // val might be float.\n                : Math.round(val);\n        },\n\n        contain: function (rank) {\n            rank = this.parse(rank);\n            return scaleProto.contain.call(this, rank)\n                && this._data[rank] != null;\n        },\n\n        /**\n         * Normalize given rank or name to linear [0, 1]\n         * @param {number|string} [val]\n         * @return {number}\n         */\n        normalize: function (val) {\n            return scaleProto.normalize.call(this, this.parse(val));\n        },\n\n        scale: function (val) {\n            return Math.round(scaleProto.scale.call(this, val));\n        },\n\n        /**\n         * @return {Array}\n         */\n        getTicks: function () {\n            var ticks = [];\n            var extent = this._extent;\n            var rank = extent[0];\n\n            while (rank <= extent[1]) {\n                ticks.push(rank);\n                rank++;\n            }\n\n            return ticks;\n        },\n\n        /**\n         * Get item on rank n\n         * @param {number} n\n         * @return {string}\n         */\n        getLabel: function (n) {\n            return this._data[n];\n        },\n\n        /**\n         * @return {number}\n         */\n        count: function () {\n            return this._extent[1] - this._extent[0] + 1;\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, false));\n        },\n\n        niceTicks: zrUtil.noop,\n        niceExtent: zrUtil.noop\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n\n    module.exports = OrdinalScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Ordinal.js\n// module id = 281\n// module chunks = 0 1 2 3 4 5 6","/**\n * Interval scale\n * @module echarts/coord/scale/Time\n */\n\n\n\n    // [About UTC and local time zone]:\n    // In most cases, `number.parseDate` will treat input data string as local time\n    // (except time zone is specified in time string). And `format.formateTime` returns\n    // local time by default. option.useUTC is false by default. This design have\n    // concidered these common case:\n    // (1) Time that is persistent in server is in UTC, but it is needed to be diplayed\n    // in local time by default.\n    // (2) By default, the input data string (e.g., '2011-01-02') should be displayed\n    // as its original time, without any time difference.\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var scaleHelper = require('./helper');\n\n    var IntervalScale = require('./Interval');\n\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n\n    // FIXME \n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            }\n            else {\n                hi  = mid;\n            }\n        }\n        return lo;\n    };\n\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n        type: 'time',\n\n        /**\n         * @override\n         */\n        getLabel: function (val) {\n            var stepLvl = this._stepLvl;\n\n            var date = new Date(val);\n\n            return formatUtil.formatTime(stepLvl[0], date, this.getSetting('useUTC'));\n        },\n\n        /**\n         * @override\n         */\n        niceExtent: function (opt) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                // Expand extent\n                extent[0] -= ONE_DAY;\n                extent[1] += ONE_DAY;\n            }\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (extent[1] === -Infinity && extent[0] === Infinity) {\n                var d = new Date();\n                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                extent[0] = extent[1] - ONE_DAY;\n            }\n\n            this.niceTicks(opt.splitNumber);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!opt.fixMin) {\n                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!opt.fixMax) {\n                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n            }\n        },\n\n        /**\n         * @override\n         */\n        niceTicks: function (approxTickNum) {\n            var timezoneOffset = this.getSetting('useUTC')\n                ? 0 : numberUtil.getTimezoneOffset() * 60 * 1000;\n            approxTickNum = approxTickNum || 10;\n\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            var approxInterval = span / approxTickNum;\n            var scaleLevelsLen = scaleLevels.length;\n            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n            var interval = level[2];\n            // Same with interval scale if span is much larger than 1 year\n            if (level[0] === 'year') {\n                var yearSpan = span / interval;\n\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\n                interval *= yearStep;\n            }\n\n            var niceExtent = [\n                Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset),\n                Math.round(mathFloor((extent[1] - timezoneOffset)/ interval) * interval + timezoneOffset)\n            ];\n\n            scaleHelper.fixExtent(niceExtent, extent);\n\n            this._stepLvl = level;\n            // Interval will be used in getTicks\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        parse: function (val) {\n            // val might be float.\n            return +numberUtil.parseDate(val);\n        }\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n\n    // Steps from d3\n    var scaleLevels = [\n        // Format       step    interval\n        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n        ['week',        7,      ONE_DAY * 7],        // 7d\n        ['month',       1,      ONE_DAY * 31],       // 1M\n        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n        ['year',        1,      ONE_DAY * 380]       // 1Y\n    ];\n\n    /**\n     * @param {module:echarts/model/Model}\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function (model) {\n        return new TimeScale({useUTC: model.ecModel.get('useUTC')});\n    };\n\n    module.exports = TimeScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Time.js\n// module id = 282\n// module chunks = 0 1 2 3 4 5 6","\n    var Gradient = require('zrender/lib/graphic/Gradient');\n    module.exports = function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(\n                            idx, 'color', color(seriesModel.getDataParams(idx))\n                        );\n                    });\n                }\n\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/visual/seriesColor.js\n// module id = 283\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n\n    var Eventful = require('./mixin/Eventful');\n\n    var SILENT = 'silent';\n\n    function makeEventPacket(eveType, targetInfo, event) {\n        return {\n            type: eveType,\n            event: event,\n            // target can only be an element that is not silent.\n            target: targetInfo.target,\n            // topTarget can be a silent element.\n            topTarget: targetInfo.topTarget,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * {target, topTarget}\n         * @private\n         * @type {Object}\n         */\n        this._hovered = {};\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var lastHovered = this._hovered;\n            var hovered = this._hovered = this.findHover(x, y);\n            var hoveredTarget = hovered.target;\n            var lastHoveredTarget = lastHovered.target;\n\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget && lastHoveredTarget.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = {};\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * cursor style\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * \n         *\n         * @private\n         * @param {Object} targetInfo {target, topTarget} \n         * @param {string} eventName \n         * @param {Object} event \n         */\n        dispatchToElement: function (targetInfo, eventName, event) {\n            targetInfo = targetInfo || {};\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n            var el = targetInfo.target;\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                //  zrender \n                this.trigger(eventName, eventPacket);\n                // \n                //  click  dispose painter \n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @return {model:zrender/Element}\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            var out = {};\n\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                var hoverCheckResult;\n                if (list[i] !== exclude\n                    // getDisplayList may include ignored item in VML mode\n                    && !list[i].ignore\n                    && (hoverCheckResult = isHover(list[i], x, y))\n                ) {\n                    !out.topTarget && (out.topTarget = list[i]);\n                    if (hoverCheckResult !== SILENT) {\n                        out.target = list[i];\n                        break;\n                    }\n                }\n            }\n\n            return out;\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY);\n            var hoveredTarget = hovered.target;\n\n            if (name === 'mousedown') {\n                this._downel = hoveredTarget;\n                // In case click triggered before mouseup\n                this._upel = hoveredTarget;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hoveredTarget;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            var isSilent;\n            while (el) {\n                // If clipped by ancestor.\n                // FIXME: If clipPath has neither stroke nor fill,\n                // el.clipPath.contain(x, y) will always return false.\n                if (el.clipPath && !el.clipPath.contain(x, y))  {\n                    return false;\n                }\n                if (el.silent) {\n                    isSilent = true;\n                }\n                el = el.parent;\n            }\n            return isSilent ? SILENT : true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Handler.js\n// module id = 284\n// module chunks = 0 1 2 3 4 5 6","/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * dom\n     *\n     * @inner\n     * @param {string} id dom id \n     * @param {string} type dom typesuch as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // append~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // \n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * \n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * \n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * alpha\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Layer.js\n// module id = 285\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n\n    var Layer = require('./Layer');\n\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.__builtin__) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n\n            clipPath.setTransform(ctx);\n            ctx.beginPath();\n            clipPath.buildPath(ctx, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // \n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root \n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * \n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            if (opts.width != null) {\n                root.width = opts.width;\n            }\n            if (opts.height != null) {\n                root.height = opts.height;\n            }\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n\n            this._domRoot = root;\n        }\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._domRoot;\n        },\n\n        /**\n         * \n         * @param {boolean} [paintAll=false] displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.__builtin__ && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuiltinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuiltinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.__builtin__) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         *  zlevel \n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.__builtin__ = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            layersMap[zlevel] = layer;\n\n            // Vitual layer will not directly show on the screen.\n            // (It can be a WebGL layer and assigned to a ZImage element)\n            // But it still under management of zrender.\n            if (!layer.virtual) {\n                if (prevLayer) {\n                    var prevDom = prevLayer.dom;\n                    if (prevDom.nextSibling) {\n                        domRoot.insertBefore(\n                            layer.dom,\n                            prevDom.nextSibling\n                        );\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n                else {\n                    if (domRoot.firstChild) {\n                        domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n            }\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuiltinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (!layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuiltinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // \n            this.eachBuiltinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * hover\n         */\n        clear: function () {\n            this.eachBuiltinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * zlevel\n         *\n         * @param {string} zlevel\n         * @param {Object} config \n         * @param {string} [config.clearColor=0] \n         * @param {string} [config.motionBlur=false] \n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 alpha\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {number} zlevel zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * \n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * \n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            var zlevel;\n\n            var self = this;\n            function findAndDrawOtherLayer(smaller, larger) {\n                var zlevelList = self._zlevelList;\n                if (smaller == null) {\n                    smaller = -Infinity;\n                }\n                var intermediateLayer;\n                for (var i = 0; i < zlevelList.length; i++) {\n                    var z = zlevelList[i];\n                    var layer = self._layers[z];\n                    if (!layer.__builtin__ && z > smaller && z < larger) {\n                        intermediateLayer = layer;\n                        break;\n                    }\n                }\n                if (intermediateLayer && intermediateLayer.renderToCanvas) {\n                    imageLayer.ctx.save();\n                    intermediateLayer.renderToCanvas(imageLayer.ctx);\n                    imageLayer.ctx.restore();\n                }\n            }\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n\n                if (el.zlevel !== zlevel) {\n                    findAndDrawOtherLayer(zlevel, el.zlevel);\n                    zlevel = el.zlevel;\n                }\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            findAndDrawOtherLayer(zlevel, Infinity);\n\n            return imageLayer.dom;\n        },\n        /**\n         * \n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * \n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        pathToImage: function (path, dpr) {\n            dpr = dpr || this.dpr;\n\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            var rect = path.getBoundingRect();\n            var style = path.style;\n            var shadowBlurSize = style.shadowBlur;\n            var shadowOffsetX = style.shadowOffsetX;\n            var shadowOffsetY = style.shadowOffsetY;\n            var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\n            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n            var width = rect.width + leftMargin + rightMargin;\n            var height = rect.height + topMargin + bottomMargin;\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.scale(dpr, dpr);\n            ctx.clearRect(0, 0, width, height);\n            ctx.dpr = dpr;\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [leftMargin - rect.x, topMargin - rect.y];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            path.updateTransform();\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Painter.js\n// module id = 286\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = require('./core/util');\n    var env = require('./core/env');\n\n    var Group = require('./container/Group');\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     *  (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} [update=false] \n         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n         *\n         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * \n         * GroupShapeShape\n         * zlevel > z > \n         * @param {boolean} [includeIgnore=false]  ignore \n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var userSetClipPath = el.clipPath;\n            if (userSetClipPath) {\n\n                // FIXME \n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                // Recursively add clip path\n                while (currentClipPath) {\n                    // clipPath  clipPath \n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n\n                    clipPaths.push(currentClipPath);\n\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.clipPath;\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            if (el.__storage === this) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToStorage(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {string|Array.<string>} [el] Storage\n         */\n        delRoot: function (el) {\n            if (el == null) {\n                // el\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (el instanceof Array) {\n                for (var i = 0, l = el.length; i < l; i++) {\n                    this.delRoot(el[i]);\n                }\n                return;\n            }\n\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromStorage(el);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToStorage: function (el) {\n            el.__storage = this;\n            el.dirty(false);\n\n            return this;\n        },\n\n        delFromStorage: function (el) {\n            if (el) {\n                el.__storage = null;\n            }\n\n            return this;\n        },\n\n        /**\n         * Storage\n         */\n        dispose: function () {\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Storage.js\n// module id = 287\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n\n    var requestAnimationFrame = require('./requestAnimationFrame');\n\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         *  clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         *  animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * \n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * \n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time, delta);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * \n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * \n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * \n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * animator\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] \n         * @param  {Function} [options.getter=null]\n         *         gettergetter\n         * @param  {Function} [options.setter=null]\n         *         settersetter\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            this.addAnimator(animator);\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animation.js\n// module id = 288\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = require('./easing');\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // \n        this._life = options.life || 1000;\n        // \n        this._delay = options.delay || 0;\n        // \n        // this._startTime = new Date().getTime() + this._delay;// \n        this._initialized = false;\n\n        // \n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n\n        this._pausedTime = 0;\n        this._paused = false;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime, deltaTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            if (this._paused) {\n                this._pausedTime += deltaTime;\n                return;\n            }\n\n            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n\n            // \n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // \n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // \n                    //  stage.update \n                    return 'restart';\n                }\n\n                // \n                // Animation.update\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._pausedTime = 0;\n\n            this._needsRemove = false;\n        },\n\n        fire: function (eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        },\n\n        pause: function () {\n            this._paused = true;\n        },\n\n        resume: function () {\n            this._paused = false;\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Clip.js\n// module id = 289\n// module chunks = 0 1 2 3 4 5 6","/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // t^3\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // t^4\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // t^5\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // sin(t)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 2^t\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // sqrt(1-t^2)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/easing.js\n// module id = 290\n// module chunks = 0 1 2 3 4 5 6","\n\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/arc.js\n// module id = 291\n// module chunks = 0 1 2 3 4 5 6","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/cubic.js\n// module id = 292\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n\n    var windingLine = require('./windingLine');\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // \n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc \n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                //  subpath \n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE  L, C, Q  NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    //  arc \n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // \n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr scale, x\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        //  subpath \n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/path.js\n// module id = 293\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = require('./event');\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/GestureMgr.js\n// module id = 294\n// module chunks = 0 1 2 3 4 5 6","\n\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerEventNames = {\n        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n    };\n\n    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n        var nm = name.replace('mouse', 'pointer');\n        return pointerEventNames[nm] ? nm : name;\n    });\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null).target,\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        // Do not do any preventDefault here. Upper application do that if necessary.\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement({target: gestureInfo.target}, type, gestureInfo.event);\n        }\n    }\n\n    // function onMSGestureChange(proxy, event) {\n    //     if (event.translationX || event.translationY) {\n    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n    //     }\n    //     if (event.scale !== 1) {\n    //         event.pinchX = event.offsetX;\n    //         event.pinchY = event.offsetY;\n    //         event.pinchScale = event.scale;\n    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n    //     }\n    // }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // rootdommouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered, and must before `mousedown` triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        },\n\n        pointerdown: function (event) {\n            domHandlers.mousedown.call(this, event);\n\n            // if (useMSGuesture(this, event)) {\n            //     this._msGesture.addPointer(event.pointerId);\n            // }\n        },\n\n        pointermove: function (event) {\n            // FIXME\n            // pointermove is so sensitive that it always triggered when\n            // tap(click) on touch screen, which affect some judgement in\n            // upper application. So, we dont support mousemove on MS touch\n            // device yet.\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mousemove.call(this, event);\n            }\n        },\n\n        pointerup: function (event) {\n            domHandlers.mouseup.call(this, event);\n        },\n\n        pointerout: function (event) {\n            // pointerout will be triggered when tap on touch screen\n            // (IE11+/Edge on MS Surface) after click event triggered,\n            // which is inconsistent with the mousout behavior we defined\n            // in touchend. So we unify them.\n            // (check domHandlers.touchend for detailed explanation)\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n\n    // function useMSGuesture(handlerProxy, event) {\n    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n    // }\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * dom \n     *\n     * @inner\n     * @param {module:zrender/Handler} instance \n     */\n    function initDomHandler(instance) {\n        zrUtil.each(touchHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(pointerHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(mouseHandlerNames, function (name) {\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        });\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (env.pointerEventsSupported) { // Only IE11+/Edge\n            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n            // at the same time.\n            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n            // screen, which do not occurs in pointer event.\n            // So we use pointer event to both detect touch gesture and mouse behavior.\n            mountHandlers(pointerHandlerNames, this);\n\n            // FIXME\n            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n            // which does not prevent defuault behavior occasionally (which may cause view port\n            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n            // touch screen. And we only support click behavior on MS touch screen now.\n\n            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n            // We dont support touch on IE on win7.\n            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n            // if (typeof MSGesture === 'function') {\n            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n            // }\n        }\n        else {\n            if (env.touchEventsSupported) {\n                mountHandlers(touchHandlerNames, this);\n                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n            }\n\n            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n            // mouse event can not be handle in those devices.\n            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n            // mouseevent after touch event triggered, see `setTouchTimer`.\n            mountHandlers(mouseHandlerNames, this);\n        }\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/dom/HandlerProxy.js\n// module id = 295\n// module chunks = 0 1 2 3 4 5 6","// CompoundPath to improve performance\n\n\n    var Path = require('./Path');\n\n    module.exports = Path.extend({\n\n        type: 'compound',\n\n        shape: {\n\n            paths: null\n        },\n\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                if (!paths[i].path) {\n                    paths[i].createPathProxy();\n                }\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/CompoundPath.js\n// module id = 296\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'radial', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/RadialGradient.js\n// module id = 297\n// module chunks = 0 1 2 3 4 5 6","\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/roundRect.js\n// module id = 298\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * \n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points \n     * @param {number} smooth , 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint \n     *                            [[0, 0], [100, 100]], \n     *                           \n     * @param {Array} \n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // \n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothBezier.js\n// module id = 299\n// module chunks = 0 1 2 3 4 5 6","/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = require('../../core/vector');\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points \n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothSpline.js\n// module id = 300\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = require('../Path').extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Arc.js\n// module id = 301\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * \n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = require('../Path').extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/BezierCurve.js\n// module id = 302\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * \n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // else {\n            //     if (ctx.allocate && !ctx.data.length) {\n            //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n            //     }\n            // }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Circle.js\n// module id = 303\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = require('../Path').extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Line.js\n// module id = 304\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polygon.js\n// module id = 305\n// module chunks = 0 1 2 3 4 5 6","/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polyline.js\n// module id = 306\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = require('../helper/roundRect');\n\n    module.exports = require('../Path').extend({\n\n        type: 'rect',\n\n        shape: {\n            // r1r2r3r4\n            // r1          [1, 1, 1, 1]\n            // r[1]        [1, 1, 1, 1]\n            // r[1, 2]     [1, 2, 1, 2]\n            // r[1, 2, 3]  [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Rect.js\n// module id = 307\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Ring.js\n// module id = 308\n// module chunks = 0 1 2 3 4 5 6","/**\n * \n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    var env = require('../../core/env');\n    var Path = require('../Path');\n\n    var shadowTemp = [\n        ['shadowBlur', 0],\n        ['shadowColor', '#000'],\n        ['shadowOffsetX', 0],\n        ['shadowOffsetY', 0]\n    ];\n\n    module.exports = Path.extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\n            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\n            // where exception \"unexpected call to method or property access\"\n            // might be thrown when calling ctx.fill after a path whose area size\n            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\n            // (e.g.,\n            //  ctx.moveTo(10, 10);\n            //  ctx.lineTo(20, 10);\n            //  ctx.closePath();\n            //  ctx.clip();\n            //  ctx.shadowBlur = 10;\n            //  ...\n            //  ctx.fill();\n            // )\n            ? function () {\n                var clipPaths = this.__clipPaths;\n                var style = this.style;\n                var modified;\n\n                if (clipPaths) {\n                    for (var i = 0; i < clipPaths.length; i++) {\n                        var shape = clipPaths[i] && clipPaths[i].shape;\n                        if (shape && shape.startAngle === shape.endAngle) {\n                            for (var j = 0; j < shadowTemp.length; j++) {\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n                            }\n                            modified = true;\n                            break;\n                        }\n                    }\n                }\n\n                Path.prototype.brush.apply(this, arguments);\n\n                if (modified) {\n                    for (var j = 0; j < shadowTemp.length; j++) {\n                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n                    }\n                }\n            }\n            : Path.prototype.brush,\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Sector.js\n// module id = 309\n// module chunks = 0 1 2 3 4 5 6","'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * \n         *\n         * @param {string} path a.b.c\n         * @param {boolean} [loop] \n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Animatable.js\n// module id = 310\n// module chunks = 0 1 2 3 4 5 6","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget).target;\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    function param(target, e) {\n        return {target: target, topTarget: e && e.topTarget};\n    }\n\n    module.exports = Draggable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Draggable.js\n// module id = 311\n// module chunks = 0 1 2 3 4 5 6","\n\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            if (path.setData) {\n                path.setData(pathProxy.data);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            }\n            else {\n                var ctx = path;\n                pathProxy.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            transformPath(pathProxy, m);\n\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (!pathEl.path) {\n                    pathEl.createPathProxy();\n                }\n                if (pathEl.__dirtyPath) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            // Need path proxy.\n            pathBundle.createPathProxy();\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/path.js\n// module id = 312\n// module chunks = 0 1 2 3 4 5 6","\n\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i] *= sx;\n                    data[i++] += x;\n                    // cy\n                    data[i] *= sy;\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/transformPath.js\n// module id = 313\n// module chunks = 0 1 2 3 4 5 6","// FIXME Better way to pack data in graphic element\n\n\n    require('./axisPointer');\n\n    require('./tooltip/TooltipModel');\n\n    require('./tooltip/TooltipView');\n\n\n    // Show tip action\n    /**\n     * @action\n     * @property {string} type\n     * @property {number} seriesIndex\n     * @property {number} dataIndex\n     * @property {number} [x]\n     * @property {number} [y]\n     */\n    require('../echarts').registerAction(\n        {\n            type: 'showTip',\n            event: 'showTip',\n            update: 'tooltip:manuallyShowTip'\n        },\n        // noop\n        function () {}\n    );\n    // Hide tip action\n    require('../echarts').registerAction(\n        {\n            type: 'hideTip',\n            event: 'hideTip',\n            update: 'tooltip:manuallyHideTip'\n        },\n        // noop\n        function () {}\n    );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip.js\n// module id = 314\n// module chunks = 0 1 2 3 4 5","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var defaultOption = {\n        show: true,\n        zlevel: 0,                  // \n        z: 0,                       // \n        // \n        inverse: false,\n\n        // \n        name: '',\n        // 'start' | 'middle' | 'end'\n        nameLocation: 'end',\n        // degree\n        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n        nameTruncate: {\n            maxWidth: null,\n            ellipsis: '...',\n            placeholder: '.'\n        },\n        // \n        nameTextStyle: {},\n        // \n        nameGap: 15,\n\n        silent: false, // Default false to support tooltip.\n        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\n        tooltip: {\n            show: false\n        },\n\n        axisPointer: {},\n\n        // \n        axisLine: {\n            // show\n            show: true,\n            onZero: true,\n            // lineStyle\n            lineStyle: {\n                color: '#333',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        axisTick: {\n            // show\n            show: true,\n            // grid\n            inside: false,\n            // length\n            length: 5,\n            // lineStyle\n            lineStyle: {\n                width: 1\n            }\n        },\n        // axis.axisLabel\n        axisLabel: {\n            show: true,\n            // grid\n            inside: false,\n            rotate: 0,\n            showMinLabel: null, // true | false | null (auto)\n            showMaxLabel: null, // true | false | null (auto)\n            margin: 8,\n            // formatter: null,\n            // TEXTSTYLE\n            textStyle: {\n                fontSize: 12\n            }\n        },\n        // \n        splitLine: {\n            // show\n            show: true,\n            // lineStylelineStyle\n            lineStyle: {\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        splitArea: {\n            // show\n            show: false,\n            // areaStyleareaStyle\n            areaStyle: {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    };\n\n    var categoryAxis = zrUtil.merge({\n        // \n        boundaryGap: true,\n        // splitArea: {\n            // show: false\n        // },\n        splitLine: {\n            show: false\n        },\n        // \n        axisTick: {\n            // If tick is align with label when boundaryGap is true\n            alignWithLabel: false,\n            interval: 'auto'\n        },\n        // axis.axisLabel\n        axisLabel: {\n            interval: 'auto'\n        }\n    }, defaultOption);\n\n    var valueAxis = zrUtil.merge({\n        // \n        boundaryGap: [0, 0],\n        // ,  'dataMin' \n        // min: null,\n        //  'dataMax' \n        // max: null,\n        // Readonly prop, specifies start value of the range when using data zoom.\n        // rangeStart: null\n        // Readonly prop, specifies end value of the range when using data zoom.\n        // rangeEnd: null\n        // 0_min_max\n        // scale: false,\n        // 5\n        splitNumber: 5\n        // Minimum interval\n        // minInterval: null\n    }, defaultOption);\n\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n        scale: true,\n        min: 'dataMin',\n        max: 'dataMax'\n    }, valueAxis);\n\n    var logAxis = zrUtil.defaults({\n        scale: true,\n        logBase: 10\n    }, valueAxis);\n\n    module.exports = {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisDefault.js\n// module id = 315\n// module chunks = 0 1 2 3 4 6","\n\n    var axisDefault = require('./axisDefault');\n    var zrUtil = require('zrender/lib/core/util');\n    var ComponentModel = require('../model/Component');\n    var layout = require('../util/layout');\n\n    // FIXME axisType is fixed ?\n    var AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\n    /**\n     * Generate sub axis model class\n     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n     * @param {module:echarts/model/Component} BaseAxisModelClass\n     * @param {Function} axisTypeDefaulter\n     * @param {Object} [extraDefaultOption]\n     */\n    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\n        zrUtil.each(AXIS_TYPES, function (axisType) {\n\n            BaseAxisModelClass.extend({\n\n                type: axisName + 'Axis.' + axisType,\n\n                mergeDefaultAndTheme: function (option, ecModel) {\n                    var layoutMode = this.layoutMode;\n                    var inputPositionParams = layoutMode\n                        ? layout.getLayoutParams(option) : {};\n\n                    var themeModel = ecModel.getTheme();\n                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n                    zrUtil.merge(option, this.getDefaultOption());\n\n                    option.type = axisTypeDefaulter(axisName, option);\n\n                    if (layoutMode) {\n                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                    }\n                },\n\n                defaultOption: zrUtil.mergeAll(\n                    [\n                        {},\n                        axisDefault[axisType + 'Axis'],\n                        extraDefaultOption\n                    ],\n                    true\n                )\n            });\n        });\n\n        ComponentModel.registerSubTypeDefaulter(\n            axisName + 'Axis',\n            zrUtil.curry(axisTypeDefaulter, axisName)\n        );\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisModelCreator.js\n// module id = 316\n// module chunks = 0 1 2 3 4","/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\nvar factory = exports;\n\n    var layout = require('../../util/layout');\n    var axisHelper = require('../../coord/axisHelper');\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Cartesian2D = require('./Cartesian2D');\n    var Axis2D = require('./Axis2D');\n\n    var each = zrUtil.each;\n\n    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n    var niceScaleExtent = axisHelper.niceScaleExtent;\n\n    //  GridModel, AxisModel \n    require('./GridModel');\n\n    /**\n     * Check if the axis is used in the specified grid\n     * @inner\n     */\n    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n        return axisModel.getCoordSysModel() === gridModel;\n    }\n\n    function getLabelUnionRect(axis) {\n        var axisModel = axis.model;\n        var labels = axisModel.getFormattedLabels();\n        var textStyleModel = axisModel.getModel('axisLabel.textStyle');\n        var rect;\n        var step = 1;\n        var labelCount = labels.length;\n        if (labelCount > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.ceil(labelCount / 40);\n        }\n        for (var i = 0; i < labelCount; i += step) {\n            if (!axis.isLabelIgnored(i)) {\n                var singleRect = textStyleModel.getTextRect(labels[i]);\n                // FIXME consider label rotate\n                rect ? rect.union(singleRect) : (rect = singleRect);\n            }\n        }\n        return rect;\n    }\n\n    function Grid(gridModel, ecModel, api) {\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n         * @private\n         */\n        this._coordsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n         * @private\n         */\n        this._coordsList = [];\n\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesList = [];\n\n        this._initCartesian(gridModel, ecModel, api);\n\n        this.model = gridModel;\n    }\n\n    var gridProto = Grid.prototype;\n\n    gridProto.type = 'grid';\n\n    gridProto.axisPointerEnabled = true;\n\n    gridProto.getRect = function () {\n        return this._rect;\n    };\n\n    gridProto.update = function (ecModel, api) {\n\n        var axesMap = this._axesMap;\n\n        this._updateScale(ecModel, this.model);\n\n        function ifAxisCanNotOnZero(otherAxisDim) {\n            var axes = axesMap[otherAxisDim];\n            for (var idx in axes) {\n                if (axes.hasOwnProperty(idx)) {\n                    var axis = axes[idx];\n                    if (axis && (\n                        axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis)\n                    )) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        each(axesMap.x, function (xAxis) {\n            niceScaleExtent(xAxis.scale, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n            niceScaleExtent(yAxis.scale, yAxis.model);\n        });\n        // Fix configuration\n        each(axesMap.x, function (xAxis) {\n            // onZero can not be enabled in these two situations\n            // 1. When any other axis is a category axis\n            // 2. When any other axis not across 0 point\n            if (ifAxisCanNotOnZero('y')) {\n                xAxis.onZero = false;\n            }\n        });\n        each(axesMap.y, function (yAxis) {\n            if (ifAxisCanNotOnZero('x')) {\n                yAxis.onZero = false;\n            }\n        });\n\n        // Resize again if containLabel is enabled\n        // FIXME It may cause getting wrong grid size in data processing stage\n        this.resize(this.model, api);\n    };\n\n    /**\n     * Resize the grid\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    gridProto.resize = function (gridModel, api, ignoreContainLabel) {\n\n        var gridRect = layout.getLayoutRect(\n            gridModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n\n        this._rect = gridRect;\n\n        var axesList = this._axesList;\n\n        adjustAxes();\n\n        // Minus label size\n        if (!ignoreContainLabel && gridModel.get('containLabel')) {\n            each(axesList, function (axis) {\n                if (!axis.model.get('axisLabel.inside')) {\n                    var labelUnionRect = getLabelUnionRect(axis);\n                    if (labelUnionRect) {\n                        var dim = axis.isHorizontal() ? 'height' : 'width';\n                        var margin = axis.model.get('axisLabel.margin');\n                        gridRect[dim] -= labelUnionRect[dim] + margin;\n                        if (axis.position === 'top') {\n                            gridRect.y += labelUnionRect.height + margin;\n                        }\n                        else if (axis.position === 'left')  {\n                            gridRect.x += labelUnionRect.width + margin;\n                        }\n                    }\n                }\n            });\n\n            adjustAxes();\n        }\n\n        function adjustAxes() {\n            each(axesList, function (axis) {\n                var isHorizontal = axis.isHorizontal();\n                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n                var idx = axis.inverse ? 1 : 0;\n                axis.setExtent(extent[idx], extent[1 - idx]);\n                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n            });\n        }\n    };\n\n    /**\n     * @param {string} axisType\n     * @param {ndumber} [axisIndex]\n     */\n    gridProto.getAxis = function (axisType, axisIndex) {\n        var axesMapOnDim = this._axesMap[axisType];\n        if (axesMapOnDim != null) {\n            if (axisIndex == null) {\n                // Find first axis\n                for (var name in axesMapOnDim) {\n                    if (axesMapOnDim.hasOwnProperty(name)) {\n                        return axesMapOnDim[name];\n                    }\n                }\n            }\n            return axesMapOnDim[axisIndex];\n        }\n    };\n\n    /**\n     * @return {Array.<module:echarts/coord/Axis>}\n     */\n    gridProto.getAxes = function () {\n        return this._axesList.slice();\n    };\n\n    /**\n     * Usage:\n     *      grid.getCartesian(xAxisIndex, yAxisIndex);\n     *      grid.getCartesian(xAxisIndex);\n     *      grid.getCartesian(null, yAxisIndex);\n     *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n     *\n     * @param {number|Object} [xAxisIndex]\n     * @param {number} [yAxisIndex]\n     */\n    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            return this._coordsMap[key];\n        }\n\n        if (zrUtil.isObject(xAxisIndex)) {\n            yAxisIndex = xAxisIndex.yAxisIndex;\n            xAxisIndex = xAxisIndex.xAxisIndex;\n        }\n        // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n        for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n            if (coordList[i].getAxis('x').index === xAxisIndex\n                || coordList[i].getAxis('y').index === yAxisIndex\n            ) {\n                return coordList[i];\n            }\n        }\n    };\n\n    gridProto.getCartesians = function () {\n        return this._coordsList.slice();\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertToPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.dataToPoint(value)\n            : target.axis\n            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n            : null;\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertFromPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.pointToData(value)\n            : target.axis\n            ? target.axis.coordToData(target.axis.toLocalCoord(value))\n            : null;\n    };\n\n    /**\n     * @inner\n     */\n    gridProto._findConvertTarget = function (ecModel, finder) {\n        var seriesModel = finder.seriesModel;\n        var xAxisModel = finder.xAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n        var yAxisModel = finder.yAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n        var gridModel = finder.gridModel;\n        var coordsList = this._coordsList;\n        var cartesian;\n        var axis;\n\n        if (seriesModel) {\n            cartesian = seriesModel.coordinateSystem;\n            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n        }\n        else if (xAxisModel && yAxisModel) {\n            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        }\n        else if (xAxisModel) {\n            axis = this.getAxis('x', xAxisModel.componentIndex);\n        }\n        else if (yAxisModel) {\n            axis = this.getAxis('y', yAxisModel.componentIndex);\n        }\n        // Lowest priority.\n        else if (gridModel) {\n            var grid = gridModel.coordinateSystem;\n            if (grid === this) {\n                cartesian = this._coordsList[0];\n            }\n        }\n\n        return {cartesian: cartesian, axis: axis};\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.containPoint = function (point) {\n        var coord = this._coordsList[0];\n        if (coord) {\n            return coord.containPoint(point);\n        }\n    };\n\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    gridProto._initCartesian = function (gridModel, ecModel, api) {\n        var axisPositionUsed = {\n            left: false,\n            right: false,\n            top: false,\n            bottom: false\n        };\n\n        var axesMap = {\n            x: {},\n            y: {}\n        };\n        var axesCount = {\n            x: 0,\n            y: 0\n        };\n\n        /// Create axis\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n        if (!axesCount.x || !axesCount.y) {\n            // Roll back when there no either x or y axis\n            this._axesMap = {};\n            this._axesList = [];\n            return;\n        }\n\n        this._axesMap = axesMap;\n\n        /// Create cartesian2d\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n            each(axesMap.y, function (yAxis, yAxisIndex) {\n                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n                var cartesian = new Cartesian2D(key);\n\n                cartesian.grid = this;\n                cartesian.model = gridModel;\n\n                this._coordsMap[key] = cartesian;\n                this._coordsList.push(cartesian);\n\n                cartesian.addAxis(xAxis);\n                cartesian.addAxis(yAxis);\n            }, this);\n        }, this);\n\n        function createAxisCreator(axisType) {\n            return function (axisModel, idx) {\n                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                    return;\n                }\n\n                var axisPosition = axisModel.get('position');\n                if (axisType === 'x') {\n                    // Fix position\n                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                        // Default bottom of X\n                        axisPosition = 'bottom';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                        }\n                    }\n                }\n                else {\n                    // Fix position\n                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n                        // Default left of Y\n                        axisPosition = 'left';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                        }\n                    }\n                }\n                axisPositionUsed[axisPosition] = true;\n\n                var axis = new Axis2D(\n                    axisType, axisHelper.createScaleByModel(axisModel),\n                    [0, 0],\n                    axisModel.get('type'),\n                    axisPosition\n                );\n\n                var isCategory = axis.type === 'category';\n                axis.onBand = isCategory && axisModel.get('boundaryGap');\n                axis.inverse = axisModel.get('inverse');\n\n                axis.onZero = axisModel.get('axisLine.onZero');\n\n                // Inject axis into axisModel\n                axisModel.axis = axis;\n\n                // Inject axisModel into axis\n                axis.model = axisModel;\n\n                // Inject grid info axis\n                axis.grid = this;\n\n                // Index of axis, can be used as key\n                axis.index = idx;\n\n                this._axesList.push(axis);\n\n                axesMap[axisType][idx] = axis;\n                axesCount[axisType]++;\n            };\n        }\n    };\n\n    /**\n     * Update cartesian properties from series\n     * @param  {module:echarts/model/Option} option\n     * @private\n     */\n    gridProto._updateScale = function (ecModel, gridModel) {\n        // Reset scale\n        zrUtil.each(this._axesList, function (axis) {\n            axis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCartesian2D(seriesModel)) {\n                var axesModels = findAxesModels(seriesModel, ecModel);\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n\n                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n                 ) {\n                    return;\n                }\n\n                var cartesian = this.getCartesian(\n                    xAxisModel.componentIndex, yAxisModel.componentIndex\n                );\n                var data = seriesModel.getData();\n                var xAxis = cartesian.getAxis('x');\n                var yAxis = cartesian.getAxis('y');\n\n                if (data.type === 'list') {\n                    unionExtent(data, xAxis, seriesModel);\n                    unionExtent(data, yAxis, seriesModel);\n                }\n            }\n        }, this);\n\n        function unionExtent(data, axis, seriesModel) {\n            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n                axis.scale.unionExtentFromData(data, dim);\n            });\n        }\n    };\n\n    /**\n     * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n     * @return {Object} {baseAxes: [], otherAxes: []}\n     */\n    gridProto.getTooltipAxes = function (dim) {\n        var baseAxes = [];\n        var otherAxes = [];\n\n        each(this.getCartesians(), function (cartesian) {\n            var baseAxis = (dim != null && dim !== 'auto')\n                ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n            var otherAxis = cartesian.getOtherAxis(baseAxis);\n            zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n            zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n        });\n\n        return {baseAxes: baseAxes, otherAxes: otherAxes};\n    };\n\n    /**\n     * @inner\n     */\n    function updateAxisTransfrom(axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\n        // Fast transform\n        axis.toGlobalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord + coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n        axis.toLocalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord - coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n    }\n\n    var axesTypes = ['xAxis', 'yAxis'];\n    /**\n     * @inner\n     */\n    function findAxesModels(seriesModel, ecModel) {\n        return zrUtil.map(axesTypes, function (axisType) {\n            var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\n            if (__DEV__) {\n                if (!axisModel) {\n                    throw new Error(axisType + ' \"' + zrUtil.retrieve(\n                        seriesModel.get(axisType + 'Index'),\n                        seriesModel.get(axisType + 'Id'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n            return axisModel;\n        });\n    }\n\n    /**\n     * @inner\n     */\n    function isCartesian2D(seriesModel) {\n        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n\n    Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n            var grid = new Grid(gridModel, ecModel, api);\n            grid.name = 'grid_' + idx;\n            // dataSampling requires axis extent, so resize\n            // should be performed in create stage.\n            grid.resize(gridModel, api, true);\n\n            gridModel.coordinateSystem = grid;\n\n            grids.push(grid);\n        });\n\n        // Inject the coordinateSystems into seriesModel\n        ecModel.eachSeries(function (seriesModel) {\n            if (!isCartesian2D(seriesModel)) {\n                return;\n            }\n\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            var gridModel = xAxisModel.getCoordSysModel();\n\n            if (__DEV__) {\n                if (!gridModel) {\n                    throw new Error(\n                        'Grid \"' + zrUtil.retrieve(\n                            xAxisModel.get('gridIndex'),\n                            xAxisModel.get('gridId'),\n                            0\n                        ) + '\" not found'\n                    );\n                }\n                if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n                    throw new Error('xAxis and yAxis must use the same grid');\n                }\n            }\n\n            var grid = gridModel.coordinateSystem;\n\n            seriesModel.coordinateSystem = grid.getCartesian(\n                xAxisModel.componentIndex, yAxisModel.componentIndex\n            );\n        });\n\n        return grids;\n    };\n\n    // For deciding which dimensions to use when creating list data\n    Grid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\n\n    require('../../CoordinateSystem').register('cartesian2d', Grid);\n\n    module.exports = Grid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Grid.js\n// module id = 317\n// module chunks = 0 1 2 3 4","\n\n    var echarts = require('../../echarts');\n\n    var AxisPointerModel = echarts.extendComponentModel({\n\n        type: 'axisPointer',\n\n        coordSysAxesInfo: null,\n\n        defaultOption: {\n            // 'auto' means that show when triggered by tooltip or handle.\n            show: 'auto',\n            // 'click' | 'mousemove' | 'none'\n            triggerOn: null, // set default in AxisPonterView.js\n\n            zlevel: 0,\n            z: 50,\n\n            type: 'line',\n            // axispointer triggered by tootip determine snap automatically,\n            // see `modelHelper`.\n            snap: false,\n            triggerTooltip: true,\n\n            value: null,\n            status: null, // Init value depends on whether handle is used.\n\n            // [group0, group1, ...]\n            // Each group can be: {\n            //      mapper: function () {},\n            //      singleTooltip: 'multiple',  // 'multiple' or 'single'\n            //      xAxisId: ...,\n            //      yAxisName: ...,\n            //      angleAxisIndex: ...\n            // }\n            // mapper: can be ignored.\n            //      input: {axisInfo, value}\n            //      output: {axisInfo, value}\n            link: [],\n\n            // Do not set 'auto' here, otherwise global animation: false\n            // will not effect at this axispointer.\n            animation: null,\n            animationDurationUpdate: 200,\n\n            lineStyle: {\n                color: '#aaa',\n                width: 1,\n                type: 'solid'\n            },\n\n            shadowStyle: {\n                color: 'rgba(150,150,150,0.3)'\n            },\n\n            label: {\n                show: true,\n                formatter: null, // string | Function\n                precision: 'auto', // Or a number like 0, 1, 2 ...\n                margin: 3,\n                textStyle: {\n                    color: '#fff'\n                },\n                padding: [5, 7, 5, 7],\n                backgroundColor: 'auto', // default: axis line color\n                borderColor: null,\n                borderWidth: 0,\n                shadowBlur: 3,\n                shadowColor: '#aaa'\n                // Considering applicability, common style should\n                // better not have shadowOffset.\n                // shadowOffsetX: 0,\n                // shadowOffsetY: 2\n            },\n\n            handle: {\n                show: false,\n                icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z', // jshint ignore:line\n                size: 45,\n                // handle margin is from symbol center to axis, which is stable when circular move.\n                margin: 50,\n                // color: '#1b8bbd'\n                // color: '#2f4554'\n                color: '#333',\n                shadowBlur: 3,\n                shadowColor: '#aaa',\n                shadowOffsetX: 0,\n                shadowOffsetY: 2,\n\n                // For mobile performance\n                throttle: 40\n            }\n        }\n\n    });\n\n    module.exports = AxisPointerModel;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/AxisPointerModel.js\n// module id = 319\n// module chunks = 0 1 2 3 4 5","\n\n    var globalListener = require('./globalListener');\n\n    var AxisPonterView = require('../../echarts').extendComponentView({\n\n        type: 'axisPointer',\n\n        render: function (globalAxisPointerModel, ecModel, api) {\n            var globalTooltipModel = ecModel.getComponent('tooltip');\n            var triggerOn = globalAxisPointerModel.get('triggerOn')\n                || (globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click');\n\n            // Register global listener in AxisPointerView to enable\n            // AxisPointerView to be independent to Tooltip.\n            globalListener.register(\n                'axisPointer',\n                api,\n                function (currTrigger, e, dispatchAction) {\n                    // If 'none', it is not controlled by mouse totally.\n                    if (triggerOn !== 'none'\n                        && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)\n                    ) {\n                        dispatchAction({\n                            type: 'updateAxisPointer',\n                            currTrigger: currTrigger,\n                            x: e && e.offsetX,\n                            y: e && e.offsetY\n                        });\n                    }\n                }\n            );\n        },\n\n        /**\n         * @override\n         */\n        remove: function (ecModel, api) {\n            globalListener.disopse(api.getZr(), 'axisPointer');\n            AxisPonterView.superApply(this._model, 'remove', arguments);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function (ecModel, api) {\n            globalListener.unregister('axisPointer', api);\n            AxisPonterView.superApply(this._model, 'dispose', arguments);\n        }\n\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/AxisPointerView.js\n// module id = 320\n// module chunks = 0 1 2 3 4 5","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var modelHelper = require('./modelHelper');\n    var findPointFromSeries = require('./findPointFromSeries');\n\n    var each = zrUtil.each;\n    var curry = zrUtil.curry;\n    var get = modelUtil.makeGetter();\n\n    /**\n     * Basic logic: check all axis, if they do not demand show/highlight,\n     * then hide/downplay them.\n     *\n     * @param {Object} coordSysAxesInfo\n     * @param {Object} payload\n     * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'\n     * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to\n     *              trigger axisPointer and tooltip.\n     * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to\n     *              trigger axisPointer and tooltip.\n     * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.\n     * @param {Object} [payload.dataIndex] finder, restrict target axes.\n     * @param {Object} [payload.axesInfo] finder, restrict target axes.\n     *        [{\n     *          axisDim: 'x'|'y'|'angle'|...,\n     *          axisIndex: ...,\n     *          value: ...\n     *        }, ...]\n     * @param {Function} [payload.dispatchAction]\n     * @param {Object} [payload.tooltipOption]\n     * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,\n     *        which can be specified in dispatchAction\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     * @return {Object} content of event obj for echarts.connect.\n     */\n    function axisTrigger(payload, ecModel, api) {\n        var currTrigger = payload.currTrigger;\n        var point = [payload.x, payload.y];\n        var finder = payload;\n        var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n        var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n        if (illegalPoint(point)) {\n            // Used in the default behavior of `connection`: use the sample seriesIndex\n            // and dataIndex. And also used in the tooltipView trigger.\n            point = findPointFromSeries({\n                seriesIndex: finder.seriesIndex,\n                // Do not use dataIndexInside from other ec instance.\n                // FIXME: auto detect it?\n                dataIndex: finder.dataIndex\n            }, ecModel).point;\n        }\n        var isIllegalPoint = illegalPoint(point);\n\n        // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).\n        // Notice: In this case, it is difficult to get the `point` (which is necessary to show\n        // tooltip, so if point is not given, we just use the point found by sample seriesIndex\n        // and dataIndex.\n        var inputAxesInfo = finder.axesInfo;\n\n        var axesInfo = coordSysAxesInfo.axesInfo;\n        var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n        var outputFinder = {};\n\n        var showValueMap = {};\n        var dataByCoordSys = {list: [], map: {}};\n        var updaters = {\n            showPointer: curry(showPointer, showValueMap),\n            showTooltip: curry(showTooltip, dataByCoordSys)\n        };\n\n        // Process for triggered axes.\n        each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n            // If a point given, it must be contained by the coordinate system.\n            var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);\n\n            each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n                var axis = axisInfo.axis;\n                var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);\n                // If no inputAxesInfo, no axis is restricted.\n                if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {\n                    var val = inputAxisInfo && inputAxisInfo.value;\n                    if (val == null && !isIllegalPoint) {\n                        val = axis.pointToData(point);\n                    }\n                    val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);\n                }\n            });\n        });\n\n        // Process for linked axes.\n        var linkTriggers = {};\n        each(axesInfo, function (tarAxisInfo, tarKey) {\n            var linkGroup = tarAxisInfo.linkGroup;\n\n            // If axis has been triggered in the previous stage, it should not be triggered by link.\n            if (linkGroup && !showValueMap[tarKey]) {\n                each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n                    var srcValItem = showValueMap[srcKey];\n                    // If srcValItem exist, source axis is triggered, so link to target axis.\n                    if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n                        var val = srcValItem.value;\n                        linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(\n                            val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo)\n                        )));\n                        linkTriggers[tarAxisInfo.key] = val;\n                    }\n                });\n            }\n        });\n        each(linkTriggers, function (val, tarKey) {\n            processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);\n        });\n\n        updateModelActually(showValueMap, axesInfo, outputFinder);\n        dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);\n        dispatchHighDownActually(axesInfo, dispatchAction, api);\n\n        return outputFinder;\n    }\n\n    function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {\n        var axis = axisInfo.axis;\n\n        if (axis.scale.isBlank() || !axis.containData(newValue)) {\n            return;\n        }\n\n        if (!axisInfo.involveSeries) {\n            updaters.showPointer(axisInfo, newValue);\n            return;\n        }\n\n        // Heavy calculation. So put it after axis.containData checking.\n        var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n        var payloadBatch = payloadInfo.payloadBatch;\n        var snapToValue = payloadInfo.snapToValue;\n\n        // Fill content of event obj for echarts.connect.\n        // By defualt use the first involved series data as a sample to connect.\n        if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n            zrUtil.extend(outputFinder, payloadBatch[0]);\n        }\n\n        // If no linkSource input, this process is for collecting link\n        // target, where snap should not be accepted.\n        if (!dontSnap && axisInfo.snap) {\n            if (axis.containData(snapToValue) && snapToValue != null) {\n                newValue = snapToValue;\n            }\n        }\n\n        updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder);\n        // Tooltip should always be snapToValue, otherwise there will be\n        // incorrect \"axis value ~ series value\" mapping displayed in tooltip.\n        updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n    }\n\n    function buildPayloadsBySeries(value, axisInfo) {\n        var axis = axisInfo.axis;\n        var dim = axis.dim;\n        var snapToValue = value;\n        var payloadBatch = [];\n        var minDist = Number.MAX_VALUE;\n        var minDiff = -1;\n\n        each(axisInfo.seriesModels, function (series, idx) {\n            var dataDim = series.coordDimToDataDim(dim);\n            var seriesNestestValue;\n            var dataIndices;\n\n            if (series.getAxisTooltipData) {\n                var result = series.getAxisTooltipData(dataDim, value, axis);\n                dataIndices = result.dataIndices;\n                seriesNestestValue = result.nestestValue;\n            }\n            else {\n                dataIndices = series.getData().indicesOfNearest(\n                    dataDim[0],\n                    value,\n                    // Add a threshold to avoid find the wrong dataIndex\n                    // when data length is not same.\n                    false, axis.type === 'category' ? 0.5 : null\n                );\n                if (!dataIndices.length) {\n                    return;\n                }\n                seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n            }\n\n            if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n                return;\n            }\n\n            var diff = value - seriesNestestValue;\n            var dist = Math.abs(diff);\n            // Consider category case\n            if (dist <= minDist) {\n                if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                    minDist = dist;\n                    minDiff = diff;\n                    snapToValue = seriesNestestValue;\n                    payloadBatch.length = 0;\n                }\n                each(dataIndices, function (dataIndex) {\n                    payloadBatch.push({\n                        seriesIndex: series.seriesIndex,\n                        dataIndexInside: dataIndex,\n                        dataIndex: series.getData().getRawIndex(dataIndex)\n                    });\n                });\n            }\n        });\n\n        return {\n            payloadBatch: payloadBatch,\n            snapToValue: snapToValue\n        };\n    }\n\n    function showPointer(showValueMap, axisInfo, value, payloadBatch) {\n        showValueMap[axisInfo.key] = {value: value, payloadBatch: payloadBatch};\n    }\n\n    function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n        var payloadBatch = payloadInfo.payloadBatch;\n        var axis = axisInfo.axis;\n        var axisModel = axis.model;\n        var axisPointerModel = axisInfo.axisPointerModel;\n\n        // If no data, do not create anything in dataByCoordSys,\n        // whose length will be used to judge whether dispatch action.\n        if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n            return;\n        }\n\n        var coordSysModel = axisInfo.coordSys.model;\n        var coordSysKey = modelHelper.makeKey(coordSysModel);\n        var coordSysItem = dataByCoordSys.map[coordSysKey];\n        if (!coordSysItem) {\n            coordSysItem = dataByCoordSys.map[coordSysKey] = {\n                coordSysId: coordSysModel.id,\n                coordSysIndex: coordSysModel.componentIndex,\n                coordSysType: coordSysModel.type,\n                coordSysMainType: coordSysModel.mainType,\n                dataByAxis: []\n            };\n            dataByCoordSys.list.push(coordSysItem);\n        }\n\n        coordSysItem.dataByAxis.push({\n            axisDim: axis.dim,\n            axisIndex: axisModel.componentIndex,\n            axisType: axisModel.type,\n            axisId: axisModel.id,\n            value: value,\n            // Caustion: viewHelper.getValueLabel is actually on \"view stage\", which\n            // depends that all models have been updated. So it should not be performed\n            // here. Considering axisPointerModel used here is volatile, which is hard\n            // to be retrieve in TooltipView, we prepare parameters here.\n            valueLabelOpt: {\n                precision: axisPointerModel.get('label.precision'),\n                formatter: axisPointerModel.get('label.formatter')\n            },\n            seriesDataIndices: payloadBatch.slice()\n        });\n    }\n\n    function updateModelActually(showValueMap, axesInfo, outputFinder) {\n        var outputAxesInfo = outputFinder.axesInfo = [];\n        // Basic logic: If no 'show' required, 'hide' this axisPointer.\n        each(axesInfo, function (axisInfo, key) {\n            var option = axisInfo.axisPointerModel.option;\n            var valItem = showValueMap[key];\n\n            if (valItem) {\n                !axisInfo.useHandle && (option.status = 'show');\n                option.value = valItem.value;\n                // For label formatter param and highlight.\n                option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n            }\n            // When always show (e.g., handle used), remain\n            // original value and status.\n            else {\n                // If hide, value still need to be set, consider\n                // click legend to toggle axis blank.\n                !axisInfo.useHandle && (option.status = 'hide');\n            }\n\n            // If status is 'hide', should be no info in payload.\n            option.status === 'show' && outputAxesInfo.push({\n                axisDim: axisInfo.axis.dim,\n                axisIndex: axisInfo.axis.model.componentIndex,\n                value: option.value\n            });\n        });\n    }\n\n    function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {\n        // Basic logic: If no showTip required, hideTip will be dispatched.\n        if (illegalPoint(point) || !dataByCoordSys.list.length) {\n            dispatchAction({type: 'hideTip'});\n            return;\n        }\n\n        // In most case only one axis (or event one series is used). It is\n        // convinient to fetch payload.seriesIndex and payload.dataIndex\n        // dirtectly. So put the first seriesIndex and dataIndex of the first\n        // axis on the payload.\n        var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n\n        dispatchAction({\n            type: 'showTip',\n            escapeConnect: true,\n            x: point[0],\n            y: point[1],\n            tooltipOption: payload.tooltipOption,\n            position: payload.position,\n            dataIndexInside: sampleItem.dataIndexInside,\n            dataIndex: sampleItem.dataIndex,\n            seriesIndex: sampleItem.seriesIndex,\n            dataByCoordSys: dataByCoordSys.list\n        });\n    }\n\n    function dispatchHighDownActually(axesInfo, dispatchAction, api) {\n        // FIXME\n        // highlight status modification shoule be a stage of main process?\n        // (Consider confilct (e.g., legend and axisPointer) and setOption)\n\n        var zr = api.getZr();\n        var highDownKey = 'axisPointerLastHighlights';\n        var lastHighlights = get(zr)[highDownKey] || {};\n        var newHighlights = get(zr)[highDownKey] = {};\n\n        // Update highlight/downplay status according to axisPointer model.\n        // Build hash map and remove duplicate incidentally.\n        each(axesInfo, function (axisInfo, key) {\n            var option = axisInfo.axisPointerModel.option;\n            option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {\n                var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n                newHighlights[key] = batchItem;\n            });\n        });\n\n        // Diff.\n        var toHighlight = [];\n        var toDownplay = [];\n        zrUtil.each(lastHighlights, function (batchItem, key) {\n            !newHighlights[key] && toDownplay.push(batchItem);\n        });\n        zrUtil.each(newHighlights, function (batchItem, key) {\n            !lastHighlights[key] && toHighlight.push(batchItem);\n        });\n\n        toDownplay.length && api.dispatchAction({\n            type: 'downplay', escapeConnect: true, batch: toDownplay\n        });\n        toHighlight.length && api.dispatchAction({\n            type: 'highlight', escapeConnect: true, batch: toHighlight\n        });\n    }\n\n    function findInputAxisInfo(inputAxesInfo, axisInfo) {\n        for (var i = 0; i < (inputAxesInfo || []).length; i++) {\n            var inputAxisInfo = inputAxesInfo[i];\n            if (axisInfo.axis.dim === inputAxisInfo.axisDim\n                && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex\n            ) {\n                return inputAxisInfo;\n            }\n        }\n    }\n\n    function makeMapperParam(axisInfo) {\n        var axisModel = axisInfo.axis.model;\n        var item = {};\n        var dim = item.axisDim = axisInfo.axis.dim;\n        item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n        item.axisName = item[dim + 'AxisName'] = axisModel.name;\n        item.axisId = item[dim + 'AxisId'] = axisModel.id;\n        return item;\n    }\n\n    function illegalPoint(point) {\n        return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n    }\n\n    module.exports = axisTrigger;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/axisTrigger.js\n// module id = 321\n// module chunks = 0 1 2 3 4 5","/**\n * @module echarts/component/tooltip/TooltipContent\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var zrColor = require('zrender/lib/tool/color');\n    var eventUtil = require('zrender/lib/core/event');\n    var formatUtil = require('../../util/format');\n    var each = zrUtil.each;\n    var toCamelCase = formatUtil.toCamelCase;\n    var env = require('zrender/lib/core/env');\n\n    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\n    /**\n     * @param {number} duration\n     * @return {string}\n     * @inner\n     */\n    function assembleTransition(duration) {\n        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n                            + 'top ' + duration + 's ' + transitionCurve;\n        return zrUtil.map(vendors, function (vendorPrefix) {\n            return vendorPrefix + 'transition:' + transitionText;\n        }).join(';');\n    }\n\n    /**\n     * @param {Object} textStyle\n     * @return {string}\n     * @inner\n     */\n    function assembleFont(textStyleModel) {\n        var cssText = [];\n\n        var fontSize = textStyleModel.get('fontSize');\n        var color = textStyleModel.getTextColor();\n\n        color && cssText.push('color:' + color);\n\n        cssText.push('font:' + textStyleModel.getFont());\n\n        fontSize &&\n            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\n        each(['decoration', 'align'], function (name) {\n            var val = textStyleModel.get(name);\n            val && cssText.push('text-' + name + ':' + val);\n        });\n\n        return cssText.join(';');\n    }\n\n    /**\n     * @param {Object} tooltipModel\n     * @return {string}\n     * @inner\n     */\n    function assembleCssText(tooltipModel) {\n\n        var cssText = [];\n\n        var transitionDuration = tooltipModel.get('transitionDuration');\n        var backgroundColor = tooltipModel.get('backgroundColor');\n        var textStyleModel = tooltipModel.getModel('textStyle');\n        var padding = tooltipModel.get('padding');\n\n        // Animation transition. Do not animate when transitionDuration is 0.\n        transitionDuration &&\n            cssText.push(assembleTransition(transitionDuration));\n\n        if (backgroundColor) {\n            if (env.canvasSupported) {\n                cssText.push('background-Color:' + backgroundColor);\n            }\n            else {\n                // for ie\n                cssText.push(\n                    'background-Color:#' + zrColor.toHex(backgroundColor)\n                );\n                cssText.push('filter:alpha(opacity=70)');\n            }\n        }\n\n        // Border style\n        each(['width', 'color', 'radius'], function (name) {\n            var borderName = 'border-' + name;\n            var camelCase = toCamelCase(borderName);\n            var val = tooltipModel.get(camelCase);\n            val != null &&\n                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n        });\n\n        // Text style\n        cssText.push(assembleFont(textStyleModel));\n\n        // Padding\n        if (padding != null) {\n            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n        }\n\n        return cssText.join(';') + ';';\n    }\n\n    /**\n     * @alias module:echarts/component/tooltip/TooltipContent\n     * @constructor\n     */\n    function TooltipContent(container, api) {\n        var el = document.createElement('div');\n        var zr = this._zr = api.getZr();\n\n        this.el = el;\n\n        this._x = api.getWidth() / 2;\n        this._y = api.getHeight() / 2;\n\n        container.appendChild(el);\n\n        this._container = container;\n\n        this._show = false;\n\n        /**\n         * @private\n         */\n        this._hideTimeout;\n\n        var self = this;\n        el.onmouseenter = function () {\n            // clear the timeout in hideLater and keep showing tooltip\n            if (self._enterable) {\n                clearTimeout(self._hideTimeout);\n                self._show = true;\n            }\n            self._inContent = true;\n        };\n        el.onmousemove = function (e) {\n            e = e || window.event;\n            if (!self._enterable) {\n                // Try trigger zrender event to avoid mouse\n                // in and out shape too frequently\n                var handler = zr.handler;\n                eventUtil.normalizeEvent(container, e, true);\n                handler.dispatch('mousemove', e);\n            }\n        };\n        el.onmouseleave = function () {\n            if (self._enterable) {\n                if (self._show) {\n                    self.hideLater(self._hideDelay);\n                }\n            }\n            self._inContent = false;\n        };\n    }\n\n    TooltipContent.prototype = {\n\n        constructor: TooltipContent,\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _enterable: true,\n\n        /**\n         * Update when tooltip is rendered\n         */\n        update: function () {\n            // FIXME\n            // Move this logic to ec main?\n            var container = this._container;\n            var stl = container.currentStyle\n                || document.defaultView.getComputedStyle(container);\n            var domStyle = container.style;\n            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n                domStyle.position = 'relative';\n            }\n            // Hide the tooltip\n            // PENDING\n            // this.hide();\n        },\n\n        show: function (tooltipModel) {\n            clearTimeout(this._hideTimeout);\n            var el = this.el;\n\n            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n                + (tooltipModel.get('extraCssText') || '');\n\n            el.style.display = el.innerHTML ?  'block' : 'none';\n\n            this._show = true;\n        },\n\n        setContent: function (content) {\n            this.el.innerHTML = content == null ? '' : content;\n        },\n\n        setEnterable: function (enterable) {\n            this._enterable = enterable;\n        },\n\n        getSize: function () {\n            var el = this.el;\n            return [el.clientWidth, el.clientHeight];\n        },\n\n        moveTo: function (x, y) {\n            // xy should be based on canvas root. But tooltipContent is\n            // the sibling of canvas root. So padding of ec container\n            // should be considered here.\n            var zr = this._zr;\n            var viewportRoot;\n            if (zr && zr.painter && (viewportRoot = zr.painter.getViewportRoot())) {\n                x += viewportRoot.offsetLeft || 0;\n                y += viewportRoot.offsetTop || 0;\n            }\n\n            var style = this.el.style;\n            style.left = x + 'px';\n            style.top = y + 'px';\n\n            this._x = x;\n            this._y = y;\n        },\n\n        hide: function () {\n            this.el.style.display = 'none';\n            this._show = false;\n        },\n\n        hideLater: function (time) {\n            if (this._show && !(this._inContent && this._enterable)) {\n                if (time) {\n                    this._hideDelay = time;\n                    // Set show false to avoid invoke hideLater mutiple times\n                    this._show = false;\n                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n                }\n                else {\n                    this.hide();\n                }\n            }\n        },\n\n        isShow: function () {\n            return this._show;\n        }\n    };\n\n    module.exports = TooltipContent;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipContent.js\n// module id = 322\n// module chunks = 0 1 2 3 4 5","\n\n    require('../../echarts').extendComponentModel({\n\n        type: 'tooltip',\n\n        dependencies: ['axisPointer'],\n\n        defaultOption: {\n            zlevel: 0,\n\n            z: 8,\n\n            show: true,\n\n            // tooltip\n            showContent: true,\n\n            // 'trigger' only works on coordinate system.\n            // 'item' | 'axis' | 'none'\n            trigger: 'item',\n\n            // 'click' | 'mousemove' | 'none'\n            triggerOn: 'mousemove|click',\n\n            alwaysShowContent: false,\n\n            displayMode: 'single', // 'single' | 'multipleByCoordSys'\n\n            //  {Array} | {Function}\n            // position: null\n            // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\n            // align: null,\n            // verticalAlign: null,\n\n            //  content  viewRect  false \n            confine: false,\n\n            // {string}Template  {Function}\n            // formatter: null\n\n            showDelay: 0,\n\n            // ms\n            hideDelay: 100,\n\n            // s\n            transitionDuration: 0.4,\n\n            enterable: false,\n\n            // 0.7\n            backgroundColor: 'rgba(50,50,50,0.7)',\n\n            // \n            borderColor: '#333',\n\n            // px4\n            borderRadius: 4,\n\n            // px0\n            borderWidth: 0,\n\n            // px5\n            // css\n            padding: 5,\n\n            // Extra css text\n            extraCssText: '',\n\n            // \n            axisPointer: {\n                // \n                // 'line' | 'shadow' | 'cross'\n                type: 'line',\n\n                // type  line  tooltip line \n                //  'x' | 'y' | 'angle' | 'radius' | 'auto'\n                //  'auto' cateogry  x \n                //  angle \n                axis: 'auto',\n\n                animation: 'auto',\n                animationDurationUpdate: 200,\n                animationEasingUpdate: 'exponentialOut',\n\n                crossStyle: {\n                    color: '#999',\n                    width: 1,\n                    type: 'dashed',\n\n                    // TODO formatter\n                    textStyle: {}\n                }\n\n                // lineStyle and shadowStyle should not be specified here,\n                // otherwise it will always override those styles on option.axisPointer.\n            },\n            textStyle: {\n                color: '#fff',\n                fontSize: 14\n            }\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipModel.js\n// module id = 323\n// module chunks = 0 1 2 3 4 5","\n\n    var TooltipContent = require('./TooltipContent');\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var numberUtil = require('../../util/number');\n    var graphic = require('../../util/graphic');\n    var findPointFromSeries = require('../axisPointer/findPointFromSeries');\n    var layoutUtil = require('../../util/layout');\n    var env = require('zrender/lib/core/env');\n    var Model = require('../../model/Model');\n    var globalListener = require('../axisPointer/globalListener');\n    var axisHelper = require('../../coord/axisHelper');\n    var axisPointerViewHelper = require('../axisPointer/viewHelper');\n\n    var bind = zrUtil.bind;\n    var each = zrUtil.each;\n    var parsePercent = numberUtil.parsePercent;\n\n\n    var proxyRect = new graphic.Rect({\n        shape: {x: -1, y: -1, width: 2, height: 2}\n    });\n\n    require('../../echarts').extendComponentView({\n\n        type: 'tooltip',\n\n        init: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var tooltipContent = new TooltipContent(api.getDom(), api);\n            this._tooltipContent = tooltipContent;\n        },\n\n        render: function (tooltipModel, ecModel, api) {\n            if (env.node) {\n                return;\n            }\n\n            // Reset\n            this.group.removeAll();\n\n            /**\n             * @private\n             * @type {module:echarts/component/tooltip/TooltipModel}\n             */\n            this._tooltipModel = tooltipModel;\n\n            /**\n             * @private\n             * @type {module:echarts/model/Global}\n             */\n            this._ecModel = ecModel;\n\n            /**\n             * @private\n             * @type {module:echarts/ExtensionAPI}\n             */\n            this._api = api;\n\n            /**\n             * Should be cleaned when render.\n             * @private\n             * @type {Array.<Array.<Object>>}\n             */\n            this._lastDataByCoordSys = null;\n\n            /**\n             * @private\n             * @type {boolean}\n             */\n            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\n            var tooltipContent = this._tooltipContent;\n            tooltipContent.update();\n            tooltipContent.setEnterable(tooltipModel.get('enterable'));\n\n            this._initGlobalListener();\n\n            this._keepShow();\n        },\n\n        _initGlobalListener: function () {\n            var tooltipModel = this._tooltipModel;\n            var triggerOn = tooltipModel.get('triggerOn');\n\n            globalListener.register(\n                'itemTooltip',\n                this._api,\n                bind(function (currTrigger, e, dispatchAction) {\n                    // If 'none', it is not controlled by mouse totally.\n                    if (triggerOn !== 'none') {\n                        if (triggerOn.indexOf(currTrigger) >= 0) {\n                            this._tryShow(e, dispatchAction);\n                        }\n                        else if (currTrigger === 'leave') {\n                            this._hide(dispatchAction);\n                        }\n                    }\n                }, this)\n            );\n        },\n\n        _keepShow: function () {\n            var tooltipModel = this._tooltipModel;\n            var ecModel = this._ecModel;\n            var api = this._api;\n\n            // Try to keep the tooltip show when refreshing\n            if (this._lastX != null\n                && this._lastY != null\n                // When user is willing to control tooltip totally using API,\n                // self.manuallyShowTip({x, y}) might cause tooltip hide,\n                // which is not expected.\n                && tooltipModel.get('triggerOn') !== 'none'\n            ) {\n                var self = this;\n                clearTimeout(this._refreshUpdateTimeout);\n                this._refreshUpdateTimeout = setTimeout(function () {\n                    // Show tip next tick after other charts are rendered\n                    // In case highlight action has wrong result\n                    // FIXME\n                    self.manuallyShowTip(tooltipModel, ecModel, api, {\n                        x: self._lastX,\n                        y: self._lastY\n                    });\n                });\n            }\n        },\n\n        /**\n         * Show tip manually by\n         * dispatchAction({\n         *     type: 'showTip',\n         *     x: 10,\n         *     y: 10\n         * });\n         * Or\n         * dispatchAction({\n         *      type: 'showTip',\n         *      seriesIndex: 0,\n         *      dataIndex or dataIndexInside or name\n         * });\n         *\n         *  TODO Batch\n         */\n        manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n            if (payload.from === this.uid || env.node) {\n                return;\n            }\n\n            var dispatchAction = makeDispatchAction(payload, api);\n\n            // Reset ticket\n            this._ticket = '';\n\n            // When triggered from axisPointer.\n            var dataByCoordSys = payload.dataByCoordSys;\n\n            if (payload.tooltip && payload.x != null && payload.y != null) {\n                var el = proxyRect;\n                el.position = [payload.x, payload.y];\n                el.update();\n                el.tooltip = payload.tooltip;\n                // Manually show tooltip while view is not using zrender elements.\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    target: el\n                }, dispatchAction);\n            }\n            else if (dataByCoordSys) {\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    event: {},\n                    dataByCoordSys: payload.dataByCoordSys,\n                    tooltipOption: payload.tooltipOption\n                }, dispatchAction);\n            }\n            else if (payload.seriesIndex != null) {\n\n                if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n                    return;\n                }\n\n                var pointInfo = findPointFromSeries(payload, ecModel);\n                var cx = pointInfo.point[0];\n                var cy = pointInfo.point[1];\n                if (cx != null && cy != null) {\n                    this._tryShow({\n                        offsetX: cx,\n                        offsetY: cy,\n                        position: payload.position,\n                        target: pointInfo.el,\n                        event: {}\n                    }, dispatchAction);\n                }\n            }\n            else if (payload.x != null && payload.y != null) {\n                // FIXME\n                // should wrap dispatchAction like `axisPointer/globalListener` ?\n                api.dispatchAction({\n                    type: 'updateAxisPointer',\n                    x: payload.x,\n                    y: payload.y\n                });\n\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    target: api.getZr().findHover(payload.x, payload.y).target,\n                    event: {}\n                }, dispatchAction);\n            }\n        },\n\n        manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n            var tooltipContent = this._tooltipContent;\n\n            if (!this._alwaysShowContent) {\n                tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n            }\n\n            this._lastX = this._lastY = null;\n\n            if (payload.from !== this.uid) {\n                this._hide(makeDispatchAction(payload, api));\n            }\n        },\n\n        // Be compatible with previous design, that is, when tooltip.type is 'axis' and\n        // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer\n        // and tooltip.\n        _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {\n            var seriesIndex = payload.seriesIndex;\n            var dataIndex = payload.dataIndex;\n            var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n            if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n                return;\n            }\n\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n            if (!seriesModel) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var tooltipModel = buildTooltipModel([\n                data.getItemModel(dataIndex),\n                seriesModel,\n                (seriesModel.coordinateSystem || {}).model,\n                tooltipModel\n            ]);\n\n            if (tooltipModel.get('trigger') !== 'axis') {\n                return;\n            }\n\n            api.dispatchAction({\n                type: 'updateAxisPointer',\n                seriesIndex: seriesIndex,\n                dataIndex: dataIndex,\n                position: payload.position\n            });\n\n            return true;\n        },\n\n        _tryShow: function (e, dispatchAction) {\n            var el = e.target;\n            var tooltipModel = this._tooltipModel;\n\n            if (!tooltipModel) {\n                return;\n            }\n\n            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n            this._lastX = e.offsetX;\n            this._lastY = e.offsetY;\n\n            var dataByCoordSys = e.dataByCoordSys;\n            if (dataByCoordSys && dataByCoordSys.length) {\n                this._showAxisTooltip(dataByCoordSys, e);\n            }\n            // Always show item tooltip if mouse is on the element with dataIndex\n            else if (el && el.dataIndex != null) {\n                this._lastDataByCoordSys = null;\n                this._showSeriesItemTooltip(e, el, dispatchAction);\n            }\n            // Tooltip provided directly. Like legend.\n            else if (el && el.tooltip) {\n                this._lastDataByCoordSys = null;\n                this._showComponentItemTooltip(e, el, dispatchAction);\n            }\n            else {\n                this._lastDataByCoordSys = null;\n                this._hide(dispatchAction);\n            }\n        },\n\n        _showOrMove: function (tooltipModel, cb) {\n            // showDelay is used in this case: tooltip.enterable is set\n            // as true. User intent to move mouse into tooltip and click\n            // something. `showDelay` makes it easyer to enter the content\n            // but tooltip do not move immediately.\n            var delay = tooltipModel.get('showDelay');\n            cb = zrUtil.bind(cb, this);\n            clearTimeout(this._showTimout);\n            delay > 0\n                ? (this._showTimout = setTimeout(cb, delay))\n                : cb();\n        },\n\n        _showAxisTooltip: function (dataByCoordSys, e) {\n            var ecModel = this._ecModel;\n            var globalTooltipModel = this._tooltipModel;\n            var point = [e.offsetX, e.offsetY];\n            var singleDefaultHTML = [];\n            var singleParamsList = [];\n            var singleTooltipModel = buildTooltipModel([\n                e.tooltipOption,\n                globalTooltipModel\n            ]);\n\n            each(dataByCoordSys, function (itemCoordSys) {\n                // var coordParamList = [];\n                // var coordDefaultHTML = [];\n                // var coordTooltipModel = buildTooltipModel([\n                //     e.tooltipOption,\n                //     itemCoordSys.tooltipOption,\n                //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),\n                //     globalTooltipModel\n                // ]);\n                // var displayMode = coordTooltipModel.get('displayMode');\n                // var paramsList = displayMode === 'single' ? singleParamsList : [];\n\n                each(itemCoordSys.dataByAxis, function (item) {\n                    var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);\n                    var axisValue = item.value;\n                    var seriesDefaultHTML = [];\n\n                    if (!axisModel || axisValue == null) {\n                        return;\n                    }\n\n                    var valueLabel = axisPointerViewHelper.getValueLabel(\n                        axisValue, axisModel.axis, ecModel,\n                        item.seriesDataIndices,\n                        item.valueLabelOpt\n                    );\n\n                    zrUtil.each(item.seriesDataIndices, function (idxItem) {\n                        var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n                        var dataIndex = idxItem.dataIndexInside;\n                        var dataParams = series && series.getDataParams(dataIndex);\n                        dataParams.axisDim = item.axisDim;\n                        dataParams.axisIndex = item.axisIndex;\n                        dataParams.axisType = item.axisType;\n                        dataParams.axisId = item.axisId;\n                        dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);\n                        dataParams.axisValueLabel = valueLabel;\n\n                        if (dataParams) {\n                            singleParamsList.push(dataParams);\n                            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));\n                        }\n                    });\n\n                    // Default tooltip content\n                    // FIXME\n                    // (1) shold be the first data which has name?\n                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n                    var firstLine = valueLabel;\n                    singleDefaultHTML.push(\n                        (firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '')\n                        + seriesDefaultHTML.join('<br />')\n                    );\n                });\n            }, this);\n\n            // In most case, the second axis is shown upper than the first one.\n            singleDefaultHTML.reverse();\n            singleDefaultHTML = singleDefaultHTML.join('<br /><br />');\n\n            var positionExpr = e.position;\n            this._showOrMove(singleTooltipModel, function () {\n                if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {\n                    this._updatePosition(\n                        singleTooltipModel,\n                        positionExpr,\n                        point[0], point[1],\n                        this._tooltipContent,\n                        singleParamsList\n                    );\n                }\n                else {\n                    this._showTooltipContent(\n                        singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(),\n                        point[0], point[1], positionExpr\n                    );\n                }\n            });\n\n            // Do not trigger events here, because this branch only be entered\n            // from dispatchAction.\n        },\n\n        _showSeriesItemTooltip: function (e, el, dispatchAction) {\n            var ecModel = this._ecModel;\n            // Use dataModel in element if possible\n            // Used when mouseover on a element like markPoint or edge\n            // In which case, the data is not main data in series.\n            var seriesIndex = el.seriesIndex;\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n            // For example, graph link.\n            var dataModel = el.dataModel || seriesModel;\n            var dataIndex = el.dataIndex;\n            var dataType = el.dataType;\n            var data = dataModel.getData();\n\n            var tooltipModel = buildTooltipModel([\n                data.getItemModel(dataIndex),\n                dataModel,\n                seriesModel && (seriesModel.coordinateSystem || {}).model,\n                this._tooltipModel\n            ]);\n\n            var tooltipTrigger = tooltipModel.get('trigger');\n            if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n                return;\n            }\n\n            var params = dataModel.getDataParams(dataIndex, dataType);\n            var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);\n            var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n\n            this._showOrMove(tooltipModel, function () {\n                this._showTooltipContent(\n                    tooltipModel, defaultHtml, params, asyncTicket,\n                    e.offsetX, e.offsetY, e.position, e.target\n                );\n            });\n\n            // FIXME\n            // duplicated showtip if manuallyShowTip is called from dispatchAction.\n            dispatchAction({\n                type: 'showTip',\n                dataIndexInside: dataIndex,\n                dataIndex: data.getRawIndex(dataIndex),\n                seriesIndex: seriesIndex,\n                from: this.uid\n            });\n        },\n\n        _showComponentItemTooltip: function (e, el, dispatchAction) {\n            var tooltipOpt = el.tooltip;\n            if (typeof tooltipOpt === 'string') {\n                var content = tooltipOpt;\n                tooltipOpt = {\n                    content: content,\n                    // Fixed formatter\n                    formatter: content\n                };\n            }\n            var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);\n            var defaultHtml = subTooltipModel.get('content');\n            var asyncTicket = Math.random();\n\n            // Do not check whether `trigger` is 'none' here, because `trigger`\n            // only works on cooridinate system. In fact, we have not found case\n            // that requires setting `trigger` nothing on component yet.\n\n            this._showOrMove(subTooltipModel, function () {\n                this._showTooltipContent(\n                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n                    asyncTicket, e.offsetX, e.offsetY, e.position, el\n                );\n            });\n\n            // If not dispatch showTip, tip may be hide triggered by axis.\n            dispatchAction({\n                type: 'showTip',\n                from: this.uid\n            });\n        },\n\n        _showTooltipContent: function (\n            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el\n        ) {\n            // Reset ticket\n            this._ticket = '';\n\n            if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n                return;\n            }\n\n            var tooltipContent = this._tooltipContent;\n\n            var formatter = tooltipModel.get('formatter');\n            positionExpr = positionExpr || tooltipModel.get('position');\n            var html = defaultHtml;\n\n            if (formatter && typeof formatter === 'string') {\n                html = formatUtil.formatTpl(formatter, params, true);\n            }\n            else if (typeof formatter === 'function') {\n                var callback = bind(function (cbTicket, html) {\n                    if (cbTicket === this._ticket) {\n                        tooltipContent.setContent(html);\n                        this._updatePosition(\n                            tooltipModel, positionExpr, x, y, tooltipContent, params, el\n                        );\n                    }\n                }, this);\n                this._ticket = asyncTicket;\n                html = formatter(params, asyncTicket, callback);\n            }\n\n            tooltipContent.setContent(html);\n            tooltipContent.show(tooltipModel);\n\n            this._updatePosition(\n                tooltipModel, positionExpr, x, y, tooltipContent, params, el\n            );\n        },\n\n        /**\n         * @param  {string|Function|Array.<number>} positionExpr\n         * @param  {number} x Mouse x\n         * @param  {number} y Mouse y\n         * @param  {boolean} confine Whether confine tooltip content in view rect.\n         * @param  {Object|<Array.<Object>} params\n         * @param  {module:zrender/Element} el target element\n         * @param  {module:echarts/ExtensionAPI} api\n         * @return {Array.<number>}\n         */\n        _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {\n            var viewWidth = this._api.getWidth();\n            var viewHeight = this._api.getHeight();\n            positionExpr = positionExpr || tooltipModel.get('position');\n\n            var contentSize = content.getSize();\n            var align = tooltipModel.get('align');\n            var vAlign = tooltipModel.get('verticalAlign');\n            var rect = el && el.getBoundingRect().clone();\n            el && rect.applyTransform(el.transform);\n\n            if (typeof positionExpr === 'function') {\n                // Callback of position can be an array or a string specify the position\n                positionExpr = positionExpr([x, y], params, content.el, rect, {\n                    viewSize: [viewWidth, viewHeight],\n                    contentSize: contentSize.slice()\n                });\n            }\n\n            if (zrUtil.isArray(positionExpr)) {\n                x = parsePercent(positionExpr[0], viewWidth);\n                y = parsePercent(positionExpr[1], viewHeight);\n            }\n            else if (zrUtil.isObject(positionExpr)) {\n                positionExpr.width = contentSize[0];\n                positionExpr.height = contentSize[1];\n                var layoutRect = layoutUtil.getLayoutRect(\n                    positionExpr, {width: viewWidth, height: viewHeight}\n                );\n                x = layoutRect.x;\n                y = layoutRect.y;\n                align = null;\n                // When positionExpr is left/top/right/bottom,\n                // align and verticalAlign will not work.\n                vAlign = null;\n            }\n            // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n            else if (typeof positionExpr === 'string' && el) {\n                var pos = calcTooltipPosition(\n                    positionExpr, rect, contentSize\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n            else {\n                var pos = refixTooltipPosition(\n                    x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n\n            align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n            vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n\n            if (tooltipModel.get('confine')) {\n                var pos = confineTooltipPosition(\n                    x, y, content.el, viewWidth, viewHeight\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n\n            content.moveTo(x, y);\n        },\n\n        // FIXME\n        // Should we remove this but leave this to user?\n        _updateContentNotChangedOnAxis: function (dataByCoordSys) {\n            var lastCoordSys = this._lastDataByCoordSys;\n            var contentNotChanged = !!lastCoordSys\n                && lastCoordSys.length === dataByCoordSys.length;\n\n            contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n                var lastDataByAxis = lastItemCoordSys.dataByAxis || {};\n                var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n                var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n                contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;\n\n                contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {\n                    var thisItem = thisDataByAxis[indexAxis] || {};\n                    var lastIndices = lastItem.seriesDataIndices || [];\n                    var newIndices = thisItem.seriesDataIndices || [];\n\n                    contentNotChanged &=\n                        lastItem.value === thisItem.value\n                        && lastItem.axisType === thisItem.axisType\n                        && lastItem.axisId === thisItem.axisId\n                        && lastIndices.length === newIndices.length;\n\n                    contentNotChanged && each(lastIndices, function (lastIdxItem, j) {\n                        var newIdxItem = newIndices[j];\n                        contentNotChanged &=\n                            lastIdxItem.seriesIndex === newIdxItem.seriesIndex\n                            && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n                    });\n                });\n            });\n\n            this._lastDataByCoordSys = dataByCoordSys;\n\n            return !!contentNotChanged;\n        },\n\n        _hide: function (dispatchAction) {\n            // Do not directly hideLater here, because this behavior may be prevented\n            // in dispatchAction when showTip is dispatched.\n\n            // FIXME\n            // duplicated hideTip if manuallyHideTip is called from dispatchAction.\n            this._lastDataByCoordSys = null;\n            dispatchAction({\n                type: 'hideTip',\n                from: this.uid\n            });\n        },\n\n        dispose: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            this._tooltipContent.hide();\n            globalListener.unregister('itemTooltip', api);\n        }\n    });\n\n\n    /**\n     * @param {Array.<Object|module:echarts/model/Model>} modelCascade\n     * From top to bottom. (the last one should be globalTooltipModel);\n     */\n    function buildTooltipModel(modelCascade) {\n        var resultModel = modelCascade.pop();\n        while (modelCascade.length) {\n            var tooltipOpt = modelCascade.pop();\n            if (tooltipOpt) {\n                if (tooltipOpt instanceof Model) {\n                    tooltipOpt = tooltipOpt.get('tooltip', true);\n                }\n                // In each data item tooltip can be simply write:\n                // {\n                //  value: 10,\n                //  tooltip: 'Something you need to know'\n                // }\n                if (typeof tooltipOpt === 'string') {\n                    tooltipOpt = {formatter: tooltipOpt};\n                }\n                resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);\n            }\n        }\n        return resultModel;\n    }\n\n    function makeDispatchAction(payload, api) {\n        return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n    }\n\n    function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        if (gapH != null) {\n            if (x + width + gapH > viewWidth) {\n                x -= width + gapH;\n            }\n            else {\n                x += gapH;\n            }\n        }\n        if (gapV != null) {\n            if (y + height + gapV > viewHeight) {\n                y -= height + gapV;\n            }\n            else {\n                y += gapV;\n            }\n        }\n        return [x, y];\n    }\n\n    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        x = Math.min(x + width, viewWidth) - width;\n        y = Math.min(y + height, viewHeight) - height;\n        x = Math.max(x, 0);\n        y = Math.max(y, 0);\n\n        return [x, y];\n    }\n\n    function calcTooltipPosition(position, rect, contentSize) {\n        var domWidth = contentSize[0];\n        var domHeight = contentSize[1];\n        var gap = 5;\n        var x = 0;\n        var y = 0;\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n        switch (position) {\n            case 'inside':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'top':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y - domHeight - gap;\n                break;\n            case 'bottom':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight + gap;\n                break;\n            case 'left':\n                x = rect.x - domWidth - gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'right':\n                x = rect.x + rectWidth + gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n        }\n        return [x, y];\n    }\n\n    function isCenterAlign(align) {\n        return align === 'center' || align === 'middle';\n    }\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipView.js\n// module id = 324\n// module chunks = 0 1 2 3 4 5","'use strict';\n// TODO boundaryGap\n\n\n    require('../coord/cartesian/AxisModel');\n\n    require('./axis/CartesianAxisView');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis.js\n// module id = 326\n// module chunks = 0 1 2 3 4","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var AxisBuilder = require('./AxisBuilder');\n    var AxisView = require('./AxisView');\n    var cartesianAxisHelper = require('./cartesianAxisHelper');\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n    var getInterval = AxisBuilder.getInterval;\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n    var selfBuilderAttrs = [\n        'splitArea', 'splitLine'\n    ];\n\n    // function getAlignWithLabel(model, axisModel) {\n    //     var alignWithLabel = model.get('alignWithLabel');\n    //     if (alignWithLabel === 'auto') {\n    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n    //     }\n    //     return alignWithLabel;\n    // }\n\n    var CartesianAxisView = AxisView.extend({\n\n        type: 'cartesianAxis',\n\n        axisPointerClass: 'CartesianAxisPointer',\n\n        /**\n         * @override\n         */\n        render: function (axisModel, ecModel, api, payload) {\n\n            this.group.removeAll();\n\n            var oldAxisGroup = this._axisGroup;\n            this._axisGroup = new graphic.Group();\n\n            this.group.add(this._axisGroup);\n\n            if (!axisModel.get('show')) {\n                return;\n            }\n\n            var gridModel = axisModel.getCoordSysModel();\n\n            var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n\n            var axisBuilder = new AxisBuilder(axisModel, layout);\n\n            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n            this._axisGroup.add(axisBuilder.getGroup());\n\n            zrUtil.each(selfBuilderAttrs, function (name) {\n                if (axisModel.get(name + '.show')) {\n                    this['_' + name](axisModel, gridModel, layout.labelInterval);\n                }\n            }, this);\n\n            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n\n            CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitLine: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.scale.isBlank()) {\n                return;\n            }\n\n            var splitLineModel = axisModel.getModel('splitLine');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var lineColors = lineStyleModel.get('color');\n\n            var lineInterval = getInterval(splitLineModel, labelInterval);\n\n            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n            var isHorizontal = axis.isHorizontal();\n\n            var lineCount = 0;\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitLineModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var p1 = [];\n            var p2 = [];\n            // Simple optimization\n            // Batching the lines if color are the same\n            var lineStyle = lineStyleModel.getLineStyle();\n            for (var i = 0; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, lineInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                if (isHorizontal) {\n                    p1[0] = tickCoord;\n                    p1[1] = gridRect.y;\n                    p2[0] = tickCoord;\n                    p2[1] = gridRect.y + gridRect.height;\n                }\n                else {\n                    p1[0] = gridRect.x;\n                    p1[1] = tickCoord;\n                    p2[0] = gridRect.x + gridRect.width;\n                    p2[1] = tickCoord;\n                }\n\n                var colorIndex = (lineCount++) % lineColors.length;\n                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                    anid: 'line_' + ticks[i],\n\n                    shape: {\n                        x1: p1[0],\n                        y1: p1[1],\n                        x2: p2[0],\n                        y2: p2[1]\n                    },\n                    style: zrUtil.defaults({\n                        stroke: lineColors[colorIndex]\n                    }, lineStyle),\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitArea: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.scale.isBlank()) {\n                return;\n            }\n\n            var splitAreaModel = axisModel.getModel('splitArea');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n            var areaColors = areaStyleModel.get('color');\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitAreaModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var prevX = axis.toGlobalCoord(ticksCoords[0]);\n            var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\n            var count = 0;\n\n            var areaInterval = getInterval(splitAreaModel, labelInterval);\n\n            var areaStyle = areaStyleModel.getAreaStyle();\n            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n            for (var i = 1; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, areaInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                var x;\n                var y;\n                var width;\n                var height;\n                if (axis.isHorizontal()) {\n                    x = prevX;\n                    y = gridRect.y;\n                    width = tickCoord - x;\n                    height = gridRect.height;\n                }\n                else {\n                    x = gridRect.x;\n                    y = prevY;\n                    width = gridRect.width;\n                    height = tickCoord - y;\n                }\n\n                var colorIndex = (count++) % areaColors.length;\n                this._axisGroup.add(new graphic.Rect({\n                    anid: 'area_' + ticks[i],\n\n                    shape: {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    },\n                    style: zrUtil.defaults({\n                        fill: areaColors[colorIndex]\n                    }, areaStyle),\n                    silent: true\n                }));\n\n                prevX = x + width;\n                prevY = y + height;\n            }\n        }\n    });\n\n    CartesianAxisView.extend({\n        type: 'xAxis'\n    });\n    CartesianAxisView.extend({\n        type: 'yAxis'\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/CartesianAxisView.js\n// module id = 327\n// module chunks = 0 1 2 3 4","\n\n    require('./gridSimple');\n\n    require('./axisPointer/CartesianAxisPointer');\n\n    require('./axisPointer');\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/grid.js\n// module id = 328\n// module chunks = 0 1 2 3 4","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Axis = require('../Axis');\n\n    /**\n     * Extend axis 2d\n     * @constructor module:echarts/coord/cartesian/Axis2D\n     * @extends {module:echarts/coord/cartesian/Axis}\n     * @param {string} dim\n     * @param {*} scale\n     * @param {Array.<number>} coordExtent\n     * @param {string} axisType\n     * @param {string} position\n     */\n    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n        Axis.call(this, dim, scale, coordExtent);\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = axisType || 'value';\n\n        /**\n         * Axis position\n         *  - 'top'\n         *  - 'bottom'\n         *  - 'left'\n         *  - 'right'\n         */\n        this.position = position || 'bottom';\n    };\n\n    Axis2D.prototype = {\n\n        constructor: Axis2D,\n\n        /**\n         * Index of axis, can be used as key\n         */\n        index: 0,\n        /**\n         * If axis is on the zero position of the other axis\n         * @type {boolean}\n         */\n        onZero: false,\n\n        /**\n         * Axis model\n         * @param {module:echarts/coord/cartesian/AxisModel}\n         */\n        model: null,\n\n        isHorizontal: function () {\n            var position = this.position;\n            return position === 'top' || position === 'bottom';\n        },\n\n        /**\n         * Each item cooresponds to this.getExtent(), which\n         * means globalExtent[0] may greater than globalExtent[1],\n         * unless `asc` is input.\n         *\n         * @param {boolean} [asc]\n         * @return {Array.<number>}\n         */\n        getGlobalExtent: function (asc) {\n            var ret = this.getExtent();\n            ret[0] = this.toGlobalCoord(ret[0]);\n            ret[1] = this.toGlobalCoord(ret[1]);\n            asc && ret[0] > ret[1] && ret.reverse();\n            return ret;\n        },\n\n        getOtherAxis: function () {\n            this.grid.getOtherAxis();\n        },\n\n        /**\n         * If label is ignored.\n         * Automatically used when axis is category and label can not be all shown\n         * @param  {number}  idx\n         * @return {boolean}\n         */\n        isLabelIgnored: function (idx) {\n            if (this.type === 'category') {\n                var labelInterval = this.getLabelInterval();\n                return ((typeof labelInterval === 'function')\n                    && !labelInterval(idx, this.scale.getLabel(idx)))\n                    || idx % (labelInterval + 1);\n            }\n        },\n\n        /**\n         * @override\n         */\n        pointToData: function (point, clamp) {\n            return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n        },\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var localCoord = axis.toLocalCoord(80);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toLocalCoord: null,\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var globalCoord = axis.toLocalCoord(40);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toGlobalCoord: null\n\n    };\n    zrUtil.inherits(Axis2D, Axis);\n\n    module.exports = Axis2D;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Axis2D.js\n// module id = 329\n// module chunks = 0 1 2 3 4","'use strict';\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    function dimAxisMapper(dim) {\n        return this._axes[dim];\n    }\n\n    /**\n     * @alias module:echarts/coord/Cartesian\n     * @constructor\n     */\n    var Cartesian = function (name) {\n        this._axes = {};\n\n        this._dimList = [];\n\n        /**\n         * @type {string}\n         */\n        this.name = name || '';\n    };\n\n    Cartesian.prototype = {\n\n        constructor: Cartesian,\n\n        type: 'cartesian',\n\n        /**\n         * Get axis\n         * @param  {number|string} dim\n         * @return {module:echarts/coord/Cartesian~Axis}\n         */\n        getAxis: function (dim) {\n            return this._axes[dim];\n        },\n\n        /**\n         * Get axes list\n         * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n         */\n        getAxes: function () {\n            return zrUtil.map(this._dimList, dimAxisMapper, this);\n        },\n\n        /**\n         * Get axes list by given scale type\n         */\n        getAxesByScale: function (scaleType) {\n            scaleType = scaleType.toLowerCase();\n            return zrUtil.filter(\n                this.getAxes(),\n                function (axis) {\n                    return axis.scale.type === scaleType;\n                }\n            );\n        },\n\n        /**\n         * Add axis\n         * @param {module:echarts/coord/Cartesian.Axis}\n         */\n        addAxis: function (axis) {\n            var dim = axis.dim;\n\n            this._axes[dim] = axis;\n\n            this._dimList.push(dim);\n        },\n\n        /**\n         * Convert data to coord in nd space\n         * @param {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        dataToCoord: function (val) {\n            return this._dataCoordConvert(val, 'dataToCoord');\n        },\n\n        /**\n         * Convert coord in nd space to data\n         * @param  {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        coordToData: function (val) {\n            return this._dataCoordConvert(val, 'coordToData');\n        },\n\n        _dataCoordConvert: function (input, method) {\n            var dimList = this._dimList;\n\n            var output = input instanceof Array ? [] : {};\n\n            for (var i = 0; i < dimList.length; i++) {\n                var dim = dimList[i];\n                var axis = this._axes[dim];\n\n                output[dim] = axis[method](input[dim]);\n            }\n\n            return output;\n        }\n    };\n\n    module.exports = Cartesian;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Cartesian.js\n// module id = 330\n// module chunks = 0 1 2 3 4","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Cartesian = require('./Cartesian');\n\n    function Cartesian2D(name) {\n\n        Cartesian.call(this, name);\n    }\n\n    Cartesian2D.prototype = {\n\n        constructor: Cartesian2D,\n\n        type: 'cartesian2d',\n\n        /**\n         * @type {Array.<string>}\n         * @readOnly\n         */\n        dimensions: ['x', 'y'],\n\n        /**\n         * Base axis will be used on stacking.\n         *\n         * @return {module:echarts/coord/cartesian/Axis2D}\n         */\n        getBaseAxis: function () {\n            return this.getAxesByScale('ordinal')[0]\n                || this.getAxesByScale('time')[0]\n                || this.getAxis('x');\n        },\n\n        /**\n         * If contain point\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        containPoint: function (point) {\n            var axisX = this.getAxis('x');\n            var axisY = this.getAxis('y');\n            return axisX.contain(axisX.toLocalCoord(point[0]))\n                && axisY.contain(axisY.toLocalCoord(point[1]));\n        },\n\n        /**\n         * If contain data\n         * @param {Array.<number>} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.getAxis('x').containData(data[0])\n                && this.getAxis('y').containData(data[1]);\n        },\n\n        /**\n         * Convert series data to an array of points\n         * @param {module:echarts/data/List} data\n         * @param {boolean} stack\n         * @return {Array}\n         *  Return array of points. For example:\n         *  `[[10, 10], [20, 20], [30, 30]]`\n         */\n        dataToPoints: function (data, stack) {\n            return data.mapArray(['x', 'y'], function (x, y) {\n                return this.dataToPoint([x, y]);\n            }, stack, this);\n        },\n\n        /**\n         * @param {Array.<number>} data\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        dataToPoint: function (data, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n            ];\n        },\n\n        /**\n         * @param {Array.<number>} point\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        pointToData: function (point, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n            ];\n        },\n\n        /**\n         * Get other axis\n         * @param {module:echarts/coord/cartesian/Axis2D} axis\n         */\n        getOtherAxis: function (axis) {\n            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n        }\n\n    };\n\n    zrUtil.inherits(Cartesian2D, Cartesian);\n\n    module.exports = Cartesian2D;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Cartesian2D.js\n// module id = 331\n// module chunks = 0 1 2 3 4","'use strict';\n// Grid \n//  Cartesian2D \n\n\n    require('./AxisModel');\n\n    var ComponentModel = require('../../model/Component');\n\n    module.exports = ComponentModel.extend({\n\n        type: 'grid',\n\n        dependencies: ['xAxis', 'yAxis'],\n\n        layoutMode: 'box',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Grid}\n         */\n        coordinateSystem: null,\n\n        defaultOption: {\n            show: false,\n            zlevel: 0,\n            z: 0,\n            left: '10%',\n            top: 60,\n            right: '10%',\n            bottom: 60,\n            // If grid size contain label\n            containLabel: false,\n            // width: {totalWidth} - left - right,\n            // height: {totalHeight} - top - bottom,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 1,\n            borderColor: '#ccc'\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/GridModel.js\n// module id = 332\n// module chunks = 0 1 2 3 4","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../util/number');\n    var parsePercent = numberUtil.parsePercent;\n\n    var STACK_PREFIX = '__ec_stack_';\n\n    function getSeriesStackId(seriesModel) {\n        return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n    }\n\n    function getAxisKey(axis) {\n        return axis.dim + axis.index;\n    }\n\n    /**\n     * @param {Object} opt\n     * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n     * @param {number} opt.count Positive interger.\n     * @param {number} [opt.barWidth]\n     * @param {number} [opt.barMaxWidth]\n     * @param {number} [opt.barGap]\n     * @param {number} [opt.barCategoryGap]\n     * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n     */\n    function getLayoutOnAxis(opt, api) {\n        var params = [];\n        var baseAxis = opt.axis;\n        var axisKey = 'axis0';\n\n        if (baseAxis.type !== 'category') {\n            return;\n        }\n        var bandWidth = baseAxis.getBandWidth();\n\n        for (var i = 0; i < opt.count || 0; i++) {\n            params.push(zrUtil.defaults({\n                bandWidth: bandWidth,\n                axisKey: axisKey,\n                stackId: STACK_PREFIX + i\n            }, opt));\n        }\n        var widthAndOffsets = doCalBarWidthAndOffset(params, api);\n\n        var result = [];\n        for (var i = 0; i < opt.count; i++) {\n            var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n            item.offsetCenter = item.offset + item.width / 2;\n            result.push(item);\n        }\n\n        return result;\n    }\n\n    function calBarWidthAndOffset(barSeries, api) {\n        var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var axisExtent = baseAxis.getExtent();\n            var bandWidth = baseAxis.type === 'category'\n                ? baseAxis.getBandWidth()\n                : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());\n\n            var barWidth = parsePercent(\n                seriesModel.get('barWidth'), bandWidth\n            );\n            var barMaxWidth = parsePercent(\n                seriesModel.get('barMaxWidth'), bandWidth\n            );\n            var barGap = seriesModel.get('barGap');\n            var barCategoryGap = seriesModel.get('barCategoryGap');\n\n            return {\n                bandWidth: bandWidth,\n                barWidth: barWidth,\n                barMaxWidth: barMaxWidth,\n                barGap: barGap,\n                barCategoryGap: barCategoryGap,\n                axisKey: getAxisKey(baseAxis),\n                stackId: getSeriesStackId(seriesModel)\n            };\n        });\n\n        return doCalBarWidthAndOffset(seriesInfoList, api);\n    }\n\n    function doCalBarWidthAndOffset(seriesInfoList, api) {\n        // Columns info on each category axis. Key is cartesian name\n        var columnsMap = {};\n\n        zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n            var axisKey = seriesInfo.axisKey;\n            var bandWidth = seriesInfo.bandWidth;\n            var columnsOnAxis = columnsMap[axisKey] || {\n                bandWidth: bandWidth,\n                remainedWidth: bandWidth,\n                autoWidthCount: 0,\n                categoryGap: '20%',\n                gap: '30%',\n                stacks: {}\n            };\n            var stacks = columnsOnAxis.stacks;\n            columnsMap[axisKey] = columnsOnAxis;\n\n            var stackId = seriesInfo.stackId;\n\n            if (!stacks[stackId]) {\n                columnsOnAxis.autoWidthCount++;\n            }\n            stacks[stackId] = stacks[stackId] || {\n                width: 0,\n                maxWidth: 0\n            };\n\n            // Caution: In a single coordinate system, these barGrid attributes\n            // will be shared by series. Consider that they have default values,\n            // only the attributes set on the last series will work.\n            // Do not change this fact unless there will be a break change.\n\n            // TODO\n            var barWidth = seriesInfo.barWidth;\n            if (barWidth && !stacks[stackId].width) {\n                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n                stacks[stackId].width = barWidth;\n                columnsOnAxis.remainedWidth -= barWidth;\n            }\n\n            var barMaxWidth = seriesInfo.barMaxWidth;\n            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n            var barGap = seriesInfo.barGap;\n            (barGap != null) && (columnsOnAxis.gap = barGap);\n            var barCategoryGap = seriesInfo.barCategoryGap;\n            (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);\n        });\n\n        var result = {};\n\n        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\n            result[coordSysName] = {};\n\n            var stacks = columnsOnAxis.stacks;\n            var bandWidth = columnsOnAxis.bandWidth;\n            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\n            var remainedWidth = columnsOnAxis.remainedWidth;\n            var autoWidthCount = columnsOnAxis.autoWidthCount;\n            var autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            // Find if any auto calculated bar exceeded maxBarWidth\n            zrUtil.each(stacks, function (column, stack) {\n                var maxWidth = column.maxWidth;\n                if (maxWidth && maxWidth < autoWidth) {\n                    maxWidth = Math.min(maxWidth, remainedWidth);\n                    if (column.width) {\n                        maxWidth = Math.min(maxWidth, column.width);\n                    }\n                    remainedWidth -= maxWidth;\n                    column.width = maxWidth;\n                    autoWidthCount--;\n                }\n            });\n\n            // Recalculate width again\n            autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            var widthSum = 0;\n            var lastColumn;\n            zrUtil.each(stacks, function (column, idx) {\n                if (!column.width) {\n                    column.width = autoWidth;\n                }\n                lastColumn = column;\n                widthSum += column.width * (1 + barGapPercent);\n            });\n            if (lastColumn) {\n                widthSum -= lastColumn.width * barGapPercent;\n            }\n\n            var offset = -widthSum / 2;\n            zrUtil.each(stacks, function (column, stackId) {\n                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                    offset: offset,\n                    width: column.width\n                };\n\n                offset += column.width * (1 + barGapPercent);\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * @param {string} seriesType\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function barLayoutGrid(seriesType, ecModel, api) {\n\n        var barWidthAndOffset = calBarWidthAndOffset(\n            zrUtil.filter(\n                ecModel.getSeriesByType(seriesType),\n                function (seriesModel) {\n                    return !ecModel.isSeriesFiltered(seriesModel)\n                        && seriesModel.coordinateSystem\n                        && seriesModel.coordinateSystem.type === 'cartesian2d';\n                }\n            )\n        );\n\n        var lastStackCoords = {};\n        var lastStackCoordsOrigin = {};\n\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\n            // Check series coordinate, do layout for cartesian2d only\n            if (seriesModel.coordinateSystem.type !== 'cartesian2d') {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n\n            var stackId = getSeriesStackId(seriesModel);\n            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n            var columnOffset = columnLayoutInfo.offset;\n            var columnWidth = columnLayoutInfo.width;\n            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\n            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\n            var valueAxisStart = baseAxis.onZero\n                ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))\n                : valueAxis.getGlobalExtent()[0];\n\n            var coords = cartesian.dataToPoints(data, true);\n            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n            lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n            data.setLayout({\n                offset: columnOffset,\n                size: columnWidth\n            });\n\n            data.each(valueAxis.dim, function (value, idx) {\n                if (isNaN(value)) {\n                    return;\n                }\n\n                if (!lastStackCoords[stackId][idx]) {\n                    lastStackCoords[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                    lastStackCoordsOrigin[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                }\n                var sign = value >= 0 ? 'p' : 'n';\n                var coord = coords[idx];\n                var lastCoord = lastStackCoords[stackId][idx][sign];\n                var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n                var x;\n                var y;\n                var width;\n                var height;\n\n                if (valueAxis.isHorizontal()) {\n                    x = lastCoord;\n                    y = coord[1] + columnOffset;\n                    width = coord[0] - lastCoordOrigin;\n                    height = columnWidth;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += width;\n                    if (Math.abs(width) < barMinHeight) {\n                        width = (width < 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += width;\n                }\n                else {\n                    x = coord[0] + columnOffset;\n                    y = lastCoord;\n                    width = columnWidth;\n                    height = coord[1] - lastCoordOrigin;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += height;\n                    if (Math.abs(height) < barMinHeight) {\n                        // Include zero to has a positive bar\n                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += height;\n                }\n\n                data.setItemLayout(idx, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }, true);\n\n        }, this);\n    }\n\n    barLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;\n\n    module.exports = barLayoutGrid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/layout/barGrid.js\n// module id = 357\n// module chunks = 0 4","'use strict';\n\n\n    var SeriesModel = require('../../model/Series');\n    var createListFromArray = require('../helper/createListFromArray');\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.__base_bar__',\n\n        getInitialData: function (option, ecModel) {\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        getMarkerPosition: function (value) {\n            var coordSys = this.coordinateSystem;\n            if (coordSys) {\n                // PENDING if clamp ?\n                var pt = coordSys.dataToPoint(value, true);\n                var data = this.getData();\n                var offset = data.getLayout('offset');\n                var size = data.getLayout('size');\n                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n                pt[offsetIndex] += offset + size / 2;\n                return pt;\n            }\n            return [NaN, NaN];\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // \n            z: 2,                       // \n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n            // stack: null\n\n            // Cartesian coordinate system\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // 0\n            barMinHeight: 0,\n            // 0\n            barMinAngle: 0,\n            // cursor: null,\n\n            // barMaxWidth: null,\n            // \n            // barWidth: null,\n            // 30%\n            // barGap: '30%',\n            // 20%\n            // barCategoryGap: '20%',\n            // label: {\n            //     normal: {\n            //         show: false\n            //     }\n            // },\n            itemStyle: {\n                normal: {\n                    // color: ''\n                },\n                emphasis: {}\n            }\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BaseBarSeries.js\n// module id = 359\n// module chunks = 0 4","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n\n    var helper = {};\n\n    helper.setLabel = function (\n        normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside\n    ) {\n        var labelModel = itemModel.getModel('label.normal');\n        var hoverLabelModel = itemModel.getModel('label.emphasis');\n\n        if (labelModel.get('show')) {\n            setLabel(\n                normalStyle, labelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'normal'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            normalStyle.text = '';\n        }\n\n        if (hoverLabelModel.get('show')) {\n            setLabel(\n                hoverStyle, hoverLabelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'emphasis'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            hoverStyle.text = '';\n        }\n    };\n\n    function setLabel(style, model, color, labelText, labelPositionOutside) {\n        graphic.setText(style, model, color);\n        style.text = labelText;\n        if (style.textPosition === 'outside') {\n            style.textPosition = labelPositionOutside;\n        }\n    }\n\n    module.exports = helper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/helper.js\n// module id = 360\n// module chunks = 0 4","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    require('../coord/cartesian/Grid');\n\n    require('./bar/BarSeries');\n    require('./bar/BarView');\n\n    var barLayoutGrid = require('../layout/barGrid');\n    var echarts = require('../echarts');\n\n    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n\n    // Visual coding for legend\n    echarts.registerVisual(function (ecModel) {\n        ecModel.eachSeriesByType('bar', function (seriesModel) {\n            var data = seriesModel.getData();\n            data.setVisual('legendSymbol', 'roundRect');\n        });\n    });\n\n    // In case developer forget to include grid component\n    require('../component/gridSimple');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar.js\n// module id = 365\n// module chunks = 0 4","\n\n    module.exports = require('./BaseBarSeries').extend({\n\n        type: 'series.bar',\n\n        dependencies: ['grid', 'polar'],\n\n        brushSelector: 'rect'\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BarSeries.js\n// module id = 366\n// module chunks = 0 4","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var helper = require('./helper');\n\n    var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth'];\n\n    // FIXME\n    // Just for compatible with ec2.\n    zrUtil.extend(require('../../model/Model').prototype, require('./barItemStyle'));\n\n    var BarView = require('../../echarts').extendChartView({\n\n        type: 'bar',\n\n        render: function (seriesModel, ecModel, api) {\n            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n            if (coordinateSystemType === 'cartesian2d'\n                || coordinateSystemType === 'polar'\n            ) {\n                this._render(seriesModel, ecModel, api);\n            }\n            else if (__DEV__) {\n                console.warn('Only cartesian2d and polar supported for bar.');\n            }\n\n            return this.group;\n        },\n\n        dispose: zrUtil.noop,\n\n        _render: function (seriesModel, ecModel, api) {\n            var group = this.group;\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            var coord = seriesModel.coordinateSystem;\n            var baseAxis = coord.getBaseAxis();\n            var isHorizontalOrRadial;\n\n            if (coord.type === 'cartesian2d') {\n                isHorizontalOrRadial = baseAxis.isHorizontal();\n            }\n            else if (coord.type === 'polar') {\n                isHorizontalOrRadial = baseAxis.dim === 'angle';\n            }\n\n            var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n\n            data.diff(oldData)\n                .add(function (dataIndex) {\n                    if (!data.hasValue(dataIndex)) {\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(dataIndex);\n                    var layout = getLayout[coord.type](data, dataIndex, itemModel);\n                    var el = elementCreator[coord.type](\n                        data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel\n                    );\n                    data.setItemGraphicEl(dataIndex, el);\n                    group.add(el);\n\n                    updateStyle(\n                        el, data, dataIndex, itemModel, layout,\n                        seriesModel, isHorizontalOrRadial, coord.type === 'polar'\n                    );\n                })\n                .update(function (newIndex, oldIndex) {\n                    var el = oldData.getItemGraphicEl(oldIndex);\n\n                    if (!data.hasValue(newIndex)) {\n                        group.remove(el);\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(newIndex);\n                    var layout = getLayout[coord.type](data, newIndex, itemModel);\n\n                    if (el) {\n                        graphic.updateProps(el, {shape: layout}, animationModel, newIndex);\n                    }\n                    else {\n                        el = elementCreator[coord.type](\n                            data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true\n                        );\n                    }\n\n                    data.setItemGraphicEl(newIndex, el);\n                    // Add back\n                    group.add(el);\n\n                    updateStyle(\n                        el, data, newIndex, itemModel, layout,\n                        seriesModel, isHorizontalOrRadial, coord.type === 'polar'\n                    );\n                })\n                .remove(function (dataIndex) {\n                    var el = oldData.getItemGraphicEl(dataIndex);\n                    if (coord.type === 'cartesian2d') {\n                        el && removeRect(dataIndex, animationModel, el);\n                    }\n                    else {\n                        el && removeSector(dataIndex, animationModel, el);\n                    }\n                })\n                .execute();\n\n            this._data = data;\n        },\n\n        remove: function (ecModel, api) {\n            var group = this.group;\n            var data = this._data;\n            if (ecModel.get('animation')) {\n                if (data) {\n                    data.eachItemGraphicEl(function (el) {\n                        if (el.type === 'sector') {\n                            removeSector(el.dataIndex, ecModel, el);\n                        }\n                        else {\n                            removeRect(el.dataIndex, ecModel, el);\n                        }\n                    });\n                }\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    });\n\n    var elementCreator = {\n\n        cartesian2d: function (\n            data, dataIndex, itemModel, layout, isHorizontal,\n            animationModel, isUpdate\n        ) {\n            var rect = new graphic.Rect({shape: zrUtil.extend({}, layout)});\n\n            // Animation\n            if (animationModel) {\n                var rectShape = rect.shape;\n                var animateProperty = isHorizontal ? 'height' : 'width';\n                var animateTarget = {};\n                rectShape[animateProperty] = 0;\n                animateTarget[animateProperty] = layout[animateProperty];\n                graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n                    shape: animateTarget\n                }, animationModel, dataIndex);\n            }\n\n            return rect;\n        },\n\n        polar: function (\n            data, dataIndex, itemModel, layout, isRadial,\n            animationModel, isUpdate\n        ) {\n            var sector = new graphic.Sector({shape: zrUtil.extend({}, layout)});\n\n            // Animation\n            if (animationModel) {\n                var sectorShape = sector.shape;\n                var animateProperty = isRadial ? 'r' : 'endAngle';\n                var animateTarget = {};\n                sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n                animateTarget[animateProperty] = layout[animateProperty];\n                graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {\n                    shape: animateTarget\n                }, animationModel, dataIndex);\n            }\n\n            return sector;\n        }\n    };\n\n    function removeRect(dataIndex, animationModel, el) {\n        // Not show text when animating\n        el.style.text = '';\n        graphic.updateProps(el, {\n            shape: {\n                width: 0\n            }\n        }, animationModel, dataIndex, function () {\n            el.parent && el.parent.remove(el);\n        });\n    }\n\n    function removeSector(dataIndex, animationModel, el) {\n        // Not show text when animating\n        el.style.text = '';\n        graphic.updateProps(el, {\n            shape: {\n                r: el.shape.r0\n            }\n        }, animationModel, dataIndex, function () {\n            el.parent && el.parent.remove(el);\n        });\n    }\n\n    var getLayout = {\n        cartesian2d: function (data, dataIndex, itemModel) {\n            var layout = data.getItemLayout(dataIndex);\n            var fixedLineWidth = getLineWidth(itemModel, layout);\n\n            // fix layout with lineWidth\n            var signX = layout.width > 0 ? 1 : -1;\n            var signY = layout.height > 0 ? 1 : -1;\n            return {\n                x: layout.x + signX * fixedLineWidth / 2,\n                y: layout.y + signY * fixedLineWidth / 2,\n                width: layout.width - signX * fixedLineWidth,\n                height: layout.height - signY * fixedLineWidth\n            };\n        },\n\n        polar: function (data, dataIndex, itemModel) {\n            var layout = data.getItemLayout(dataIndex);\n            return {\n                cx: layout.cx,\n                cy: layout.cy,\n                r0: layout.r0,\n                r: layout.r,\n                startAngle: layout.startAngle,\n                endAngle: layout.endAngle\n            };\n        }\n    };\n\n    function updateStyle(\n        el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar\n    ) {\n        var color = data.getItemVisual(dataIndex, 'color');\n        var opacity = data.getItemVisual(dataIndex, 'opacity');\n        var itemStyleModel = itemModel.getModel('itemStyle.normal');\n        var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n        if (!isPolar) {\n            el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n        }\n\n        el.useStyle(zrUtil.defaults(\n            {\n                fill: color,\n                opacity: opacity\n            },\n            itemStyleModel.getBarItemStyle()\n        ));\n\n        var cursorStyle = itemModel.getShallow('cursor');\n        cursorStyle && el.attr('cursor', cursorStyle);\n\n        var labelPositionOutside = isHorizontal\n            ? (layout.height > 0 ? 'bottom' : 'top')\n            : (layout.width > 0 ? 'left' : 'right');\n\n        if (!isPolar) {\n            helper.setLabel(\n                el.style, hoverStyle, itemModel, color,\n                seriesModel, dataIndex, labelPositionOutside\n            );\n        }\n\n        graphic.setHoverStyle(el, hoverStyle);\n    }\n\n    // In case width or height are too small.\n    function getLineWidth(itemModel, rawLayout) {\n        var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n        return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n    }\n\n    module.exports = BarView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BarView.js\n// module id = 367\n// module chunks = 0 4","\n\n\n    var getBarItemStyle = require('../../model/mixin/makeStyleMapper')(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            // Compatitable with 2\n            ['stroke', 'barBorderColor'],\n            ['lineWidth', 'barBorderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getBarItemStyle: function (excludes) {\n            var style = getBarItemStyle.call(this, excludes);\n            if (this.getBorderLineDash) {\n                var lineDash = this.getBorderLineDash();\n                lineDash && (style.lineDash = lineDash);\n            }\n            return style;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/barItemStyle.js\n// module id = 368\n// module chunks = 0 4"],"sourceRoot":""}